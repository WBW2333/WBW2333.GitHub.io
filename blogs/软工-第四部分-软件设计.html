<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软工-第四部分-软件设计</title>
</head>
<body><h1 id='软工-第四部分-软件设计'>软工-第四部分-软件设计</h1>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%8810.28.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午10.28.29"></p>
<h2 id='八软件设计基础'>八、软件设计基础</h2>
<h3 id='1）软件设计的核心思想'>（1）软件设计的核心思想</h3>
<ol start='' >
<li><p>软件设计的核心问题是控制系统复杂度，因此“分而治之”是解决复杂度问题的主要思路。</p>
</li>
<li><p>抽象和分解是软件设计的核心思想<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%8810.40.31.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午10.40.31"></p>
<ol start='' >
<li><p>分解</p>
<ol start='' >
<li>横向上将系统分割为几个相对简单的子系统以及各子系统之间的关系。</li>
<li>分解之后每次就只需要关注经过抽象的相对简单的子系统以及各子系统之间的关系，从而降低了复杂度。</li>

</ol>
</li>
<li><p>抽象</p>
<ol start='' >
<li>纵向上聚焦各子系统的接口。</li>
<li>抽象可以分离接口和实现，更好地关注系统本质，从而降低复杂度。</li>
<li>接口是各子系统之间交流的核心，使整个系统的关键所在。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='2）软件设计'>（2）软件设计</h3>
<ol start='' >
<li><p><em>软件设计：关于软件对象的设计，是一种设计活动，具有设计的普遍特性。</em>软件设计既指软件对象实现的规格说明，也指产生这个规格说明的过程。</p>
</li>
<li><p>从工程设计的角度看，软件设计要：</p>
<ol start='' >
<li>保持以用户为中心，为其建造有用的软件产品。</li>
<li>将设计知识科学化、系统化，并能够通过职业教育产生合格的软件设计师。</li>
<li>能够进行设计决策与折中，解决设计过程中出现的不确定性、信息不充分、要求冲突等复杂情况。</li>

</ol>
</li>
<li><p>从艺术设计的角度看：</p>
<ol start='' >
<li>软件要满足：效用、坚固、美感，还需要考虑软件产品的美感因素。</li>
<li>艺术处于中心地位，比工程性更重要，为此设计师需要发散思维和创新，与用户共情。</li>

</ol>
</li>
<li><p>理性主义和经验主义</p>
</li>
<li><p>软件设计的演化性</p>
</li>
<li><p>软件设计的决策性</p>
</li>
<li><p>软件设计的约束满足和多样性</p>
<ol start='' >
<li>多样性是的设计师解决同一个问题会产生不同的设计方案，需要进行权衡和折中。</li>
<li>约束帮助设计师暂时验证解空间多样设计方案的合理性，简化设计方案的选择决策。</li>

</ol>
</li>

</ol>
<h3 id='3）软件设计的分层'>（3）软件设计的分层</h3>
<ol start='' >
<li><p>软件设计有三个层次</p>
<ol start='' >
<li>高层设计（先进行）：基于反映软件高层抽象的构建层次，描述系统的高层结构、关注点和设计决策。</li>
<li>中层设计（之后进行）：关注组成构建的模块的划分、导入/导出、过程之间调用关系或者类之间的协作。</li>
<li>底层设计（最后进行）：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</li>

</ol>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8B%E5%8D%883.51.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 下午3.51.04"></p>
</li>
<li><p>通过设计分层可以减少需要同时关注的细节，降低设计师同一时间需要处理的复杂度。</p>
</li>

</ol>
<h3 id='4）软件设计的主要活动'>（4）软件设计的主要活动</h3>
<ol start='' >
<li><p>软件设计分为4个主要活动<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8B%E5%8D%883.53.22.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 下午3.53.22"></p>
<ol start='' >
<li>分析设计出发点：了解功能性需求、非功能性需求、项目环境和人员限制等，获取设计的出发点。</li>
<li>建立候选方案</li>
<li>生成最终方案</li>
<li>评价：检查设计是否满足需求和约束，尤其要关注是否有漏洞，有未满足的情况就需要进行重新软件设计。</li>

</ol>
</li>
<li><p>要注意到返工的现象在设计中很常见。</p>
</li>

</ol>
<h3 id='5）软件设计的方法和模型'>（5）软件设计的方法和模型</h3>
<ol start='' >
<li><p>软件设计的方法</p>
<ol start='' >
<li>结构化设计</li>
<li>面向对象设计</li>
<li>数据结构为中心设计</li>
<li>基于构件的设计</li>
<li>形式化方法设计</li>

</ol>
</li>
<li><p>软件设计的模型</p>
<ol start='' >
<li>静态模型：通过快照的方式描述系统，描述状态而不是行为。如实体关系图、类图、对象图、构件图、部署图等。</li>
<li>动态模型：描述系统行为和状态转移。如数据流图、结构图、交互图（顺序图和通信图）、状态图、活动图等。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='九软件体系结构基础'>九、软件体系结构基础</h2>
<h3 id='1）软件体系结构'>（1）软件体系结构</h3>
<ol start='' >
<li>软件体系结构的定义：软件体系结构={部件，连接件，配置}，一个软件系统的体系结构规定了系统的计算部件和部件之间的交互。</li>

</ol>
<h3 id='2）体系结构风格'>（2）体系结构风格</h3>
<ol start='' >
<li><p>主程序/子程序风格</p>
<ol start='' >
<li><p>主子风格将系统组织称层次结构，包括一个主程序和一系列子程序。主程序是系统的控制器，负责调度各子程序的执行。子程序又是一个局部的控制器，负责调度其子程序的执行。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.27.01.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.27.01"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>基于声明一使用（程序调用）关系建立连接件，以层次分解的方式建立系统部件，共同组成层次结构。</li>
<li>每一个上层部件可以“使用”下层部件，但下层部件不能“使用”上层部件，即不允许逆方向调用。</li>
<li>系统应该是单线程执行。主程序部件拥有最初的执行控制权，并在“使用”中将控制权转移给下层子程序。</li>
<li>子程序只能够通过上层转移来获得控制权，可以在执行中将控制权转交给下层的子子程序，并在自身执行完成之后将控制权交还给上层部件。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>流程清晰，易于理解。</li>
<li>强控制性。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>程序调用是一种强耦合的连接方式，难以修改和复用。</li>
<li>程序调用的连接方式限制了各部件之间的数据交互，产生不必要的公告耦合。</li>

</ol>
</li>
<li><p>应用：主要用于能够将系统功能依层次分解为多个顺序执行步骤的系统。</p>
</li>

</ol>
</li>
<li><p>面向对象式风格</p>
<ol start='' >
<li><p>面对风格将系统组织为多个独立的对象，每个对象封装其内部的数据，并基于数据对外提供服务，不同对象直接协作机制共同完成系统任务。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.31.24.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.31.24"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>依照对数据的使用情况，用信息内聚的标准为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口．并隐藏内部数据的表示。</li>
<li>基于方法调用机制建立连接件，将对象部件连接起来。每个对象负责维护其自身数据的一致性与完整性，并以此为基础对外提供“正确”的服务。</li>
<li>每个对象都是一个自治单位，不同对象之间是平级的，没有主次、从属、层次、分解等关系。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>内部实现的可修改性。</li>
<li>易开发、易理解、易复用的组织结构。</li>

</ol>
</li>
<li><p>缺口：</p>
<ol start='' >
<li>接口的耦合性。</li>
<li>标识的耦合性。</li>
<li>副作用。</li>

</ol>
</li>
<li><p>应用：适用于能够基于数据信息分解和组织的软件系统，将数据信息和相关操作联系起来并封装。</p>
</li>

</ol>
</li>
<li><p>分层风格</p>
<ol start='' >
<li><p>根据不同的抽象层次，将系统组织为层次式结构。每个层次被建立为一个部件，不同部件之间通常用程序调用的方式进行连接，连接件被建立为程序调用机制。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.38.26.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.38.26"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>从最底层到最高层，部件的抽象层次逐渐提升。每个下层为邻接上层提供服务，每个上层将邻接下层作为基础设施使用。也就是说，在程序调用机制中上层调用下层。</li>
<li>两个层次之间的连接要遵守特定的交互协议，该交互协议应该是成熟、稳定和标准化的。也就是说，只要遵守交互协议，不同部件实例之问是可以互相替换的。</li>
<li>跨层次的连接是禁止的。</li>
<li>逆向的连接是禁止的。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>设计机制清晰，易于理解。</li>
<li>支持并行开发。</li>
<li>更好地可复用性与内部可修改性。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>交互协议难以修改。</li>
<li>性能损失。</li>
<li>难以确定层次数量和粒度。</li>

</ol>
</li>
<li><p>应用：</p>
<ol start='' >
<li>主要功能是在不同抽象层次上进行任务分解的复杂处理。</li>
<li>能够建立不同抽象层次之间的稳定交互协议。</li>
<li>没有很高的实时性要求。</li>

</ol>
</li>

</ol>
</li>
<li><p>MVC风格</p>
<ol start='' >
<li><p>以程序调用为连接件，将系统功能组织为模型、视图和控制三个部件。模型封装了系统的数据和状态信息，实现业务逻辑，对外提供数据服务和执行业务逻辑。视图封装了用户交互，提供业务展现，接收用户行为。控制封装了系统的控制逻辑，根据用户行为调用需要执行的业务逻辑和数据更新，并且根据执行后的系统状态决定后续的业务展现。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.42.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.42.49"></p>
</li>
<li><p>重要设计决策与约束：</p>
<ol start='' >
<li>模型、视图、控制分别是关于业务逻辑、表现和控制的三种不同内容抽象。</li>
<li>如果视图需要持续地显示某个数据的状态，那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更，模型会主动通知视图，然后再由视图查询数据的更新情况。</li>
<li>视图只能使用模型的数据查询服务，只有控制部件可以调用可能修改模型状态的程序。</li>
<li>用户行为虽然由视图发起，但是必须转交给控制部件处理。对接收到的用户行为，控制部件可能会执行两种处理中的一种或两种：调用模型的服务，执行业务逻辑；提供下一个业务展现。</li>
<li>模型部件相对独立，既不依赖于视图，也不依赖于控制。虽然模型与视图之问存在一个“通知变更〞的连接，但该连接的交互协议是非常稳定的，可以认为是非常弱的依赖。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>易开发性。</li>
<li>视图和控制的可修改性。</li>
<li>适宜于网络系统开发的特征。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>复杂性。</li>
<li>模型修改困难。</li>

</ol>
</li>
<li><p>应用：主要用于网络系统的开发。</p>
</li>
<li><p>分层风格和MVC风格的比较：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.45.25.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.45.25"></p>
</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十软件体系结构设计与构建'>十、软件体系结构设计与构建</h2>
<h3 id='1）体系结构设计过程'>（1）体系结构设计过程</h3>
<ol start='' >
<li><p>分析关键需求和项目约束</p>
</li>
<li><p>选择体系结构风格</p>
</li>
<li><p>进行软件体系结构逻辑（抽象）设计</p>
<ol start='' >
<li><p>逻辑设计的目的是建立能够满足概要功能需求、质量需求与约束的软件体系结构抽象设计方案。</p>
</li>
<li><p>设计过程：</p>
<ol start='' >
<li>依据需求和体系风格建立初始设计</li>
<li>使用非功能性需求与约束评价并改进初始设计</li>

</ol>
</li>

</ol>
</li>
<li><p>依赖逻辑设计进行软件体系结构物理（实现）设计</p>
<ol start='' >
<li><p>将逻辑设计从开发（开发包、物理模块）、发布（进程）、部署（网络部署）三个角度进行实现，建立软件体系结构的物理设计。</p>
</li>
<li><p>设计过程</p>
<ol start='' >
<li>开发包（构件）设计</li>
<li>运行时进程</li>
<li>物理部署</li>

</ol>
</li>

</ol>
</li>
<li><p>完善软件体系结构设计</p>
</li>
<li><p>定义构件接口</p>
</li>
<li><p>迭代过程3～6</p>
</li>

</ol>
<h3 id='2）体系结构的原型创建'>（2）体系结构的原型创建</h3>
<ol start='' >
<li><p>包的创建</p>
<ol start='' >
<li>包是用于将系统组织成层次结构的机制，根据构件的设计来创建项目的包。</li>
<li>包的创建原则：逻辑设计中的每一个包对应一个开发包（开发包、依赖的其他包）。</li>

</ol>
</li>
<li><p>重要文件的创建</p>
</li>
<li><p>定义构件之间的接口</p>
<ol start='' >
<li>提供的服务（供接口）：语法、前置条件、后置条件</li>
<li>需要的服务（需接口）：服务名、服务</li>

</ol>
</li>
<li><p>关键需求的实现</p>
</li>

</ol>
<h3 id='3）体系结构集成与测试'>（3）体系结构集成与测试</h3>
<ol start='' >
<li><p>集成的策略：</p>
<ol start='' >
<li><p>大爆炸式</p>
<ol start='' >
<li>一次性将所有模块组合在一起。</li>
<li>优点：可以在短时间内迅速完成集成测试。</li>
<li>缺点：问题的定位和修改困难。</li>
<li>适合应用于一个维护性项目或被测试系统规模较小。</li>

</ol>
</li>
<li><p>自顶向下式——增量式</p>
<ol start='' >
<li><p>对分层次的架构，先集成和测试上层的模块，下层的模块使用伪装的桩，然后不断加入下层模块直到集成所有模块。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>按深度优先可以首先实现和验证一个完整的功能需求</li>
<li>只需最顶端一个驱动</li>
<li>利于故障定位</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>桩的开发量大</li>
<li>底层验证被推迟，且底层组建测试不充分</li>

</ol>
</li>
<li><p>适用于控制结构比较清晰和稳定、高层接口变化小、底层接口未定义或经常可能被修改、控制组件具有较大的技术风险的软件系统。</p>
</li>

</ol>
</li>
<li><p>自底向上式——增量式</p>
<ol start='' >
<li><p>从最底层的模块集成测试起，上层用伪装的接口替换。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>对底层组件验证较早</li>
<li>底层组件开发可以并行</li>
<li>桩的工作量小</li>
<li>利于故障定位</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>驱动开发量大</li>
<li>对高层的验证被推迟，设计上的高层错误不能被及时发现</li>

</ol>
</li>
<li><p>适用于底层接口比较稳定、高层接口变化频繁、底层接口较早被完成的系统。</p>
</li>

</ol>
</li>
<li><p>三明治式——增量式</p>
</li>
<li><p>持续集成——增量式</p>
<ol start='' >
<li><p>提倡尽早集成和频繁集成。</p>
</li>
<li><p>尽早集成就是不等待一个模块开发完再集成，而是在开发之初就利用stub集成起来。</p>
</li>
<li><p>提倡集成即开发者每次完成一些开发任务之后，就用开发结果替换stub中的相应组件，进行集成与测试。</p>
</li>
<li><p>优点/可以做到：</p>
<ol start='' >
<li>防止软件开发中出现无法集成与发布的情况</li>
<li>有利于检查和发现集成缺陷</li>

</ol>
</li>
<li><p>持续集成的频率很高，所以需要版本控制工具和持续集成工具。</p>
</li>

</ol>
</li>

</ol>
</li>
<li><p>桩（stub）</p>
<ol start='' >
<li>stub在软件测试中用来替换某些模块，一般和所替换的模块有相同接口，并且模拟了模块的行为。</li>
<li>stub模仿的是下层模块，用来测试上层。</li>

</ol>
</li>
<li><p>驱动（driver）</p>
<ol start='' >
<li>模仿上层模块，用来测试下层。</li>
<li>利用下层提供的接口，实现其模仿的模块的功能，用来替换上层的接口。</li>
<li>执行的是用于测试模块接口的集成测试用例。</li>

</ol>
</li>
<li><p>软件体系结构文档</p>
<ol start='' >
<li>描述软件整体结构，包括整个系统的逻辑和物理的组成、模块与模块之间的接口、模块与模块之间的交互、模块内部的结构、模块对外提供的接口、模块需要访问的外部接口、整体数据模型、运行时进程、系统的部署等。</li>

</ol>
</li>

</ol>
<h3 id='4）体系结构评审'>（4）体系结构评审</h3>
<ol start='' >
<li><p>评审重点是体系结构中的决策是否合理，理由是否合理，是否考虑了足够的风险等。</p>
</li>
<li><p>评审考察方面：</p>
<ol start='' >
<li>设计方案正确性、先进性、可行性；</li>
<li>系统组成、系统要求及接口协调的合理性；</li>
<li>对于功能模块的输人参数、输出参数的定义是否明确；</li>
<li>系统性能、可靠性、安全性要求是否合理；</li>
<li>文档的描述是否清晰、明确。</li>

</ol>
</li>

</ol>
<h3 id='5）习题'>（5）习题</h3>
<ol start='' >
<li><p>一般从哪几个视角来描述设计体系结构？</p>
<p>一般从以下几个视角来描述设计体系结构：</p>
<ul>
<li>组合视角：描述系统的组成部分及其之间的关系。</li>
<li>逻辑视角：关注系统功能、行为和数据的组织。</li>
<li>物理视角：描述系统的物理组成、部署和运行时环境。</li>
<li>进程视角：关注系统的并发性和交互。</li>

</ul>
</li>
<li><p>组合视角一般会利用 UML 的哪些图来描述？</p>
<p>组合视角一般会利用 UML 的以下图来描述：</p>
<ul>
<li>组件图：用于表示系统的组成部分及其之间的依赖关系。</li>
<li>部署图：用于描述系统的物理组成和部署结构。</li>

</ul>
</li>
<li><p>逻辑视角和物理视角的区别是什么？</p>
<p>逻辑视角和物理视角的区别：</p>
<ul>
<li>逻辑视角关注系统的功能和行为，强调系统的功能划分和模块化设计，通常使用类图、用例图等UML图来描述。</li>
<li>物理视角关注系统的物理组成和运行时环境，描述系统的部署结构和硬件配置，通常使用部署图等UML图来描述。</li>

</ul>
</li>
<li><p>如何挑选体系结构风格？</p>
<p>挑选体系结构风格的步骤：</p>
<ul>
<li>理解需求和目标：深入理解系统的需求、质量属性和约束条件。</li>
<li>考虑技术和环境：考虑开发团队的技术能力、开发环境和运行环境。</li>
<li>对比和评估：对不同的体系结构风格进行对比和评估，看哪种风格更适合满足需求和目标。</li>
<li>考虑复用和成本：考虑现有的体系结构模式和已有的组件资源，以及体系结构的开发和维护成本。</li>

</ul>
</li>
<li><p>如何描述一个接口？</p>
<p>描述一个接口一般包括以下内容：</p>
<ul>
<li>接口名称：标识接口的名称，以便于识别和引用。</li>
<li>输入和输出：明确接口的输入数据和输出结果。</li>
<li>方法和操作：描述接口的操作或方法，说明接口的功能和行为。</li>
<li>参数和返回值：定义接口的参数和返回值的数据类型和格式。</li>
<li>用例和应用场景：描述接口的使用场景和在系统中的应用情况。</li>
<li>约束和限制：定义接口的使用约束和限制条件，如安全性要求等。</li>

</ul>
</li>
<li><p>体系结构中信息视角如何描述？</p>
<p>体系结构中的信息视角描述系统中信息的组织、流动和处理。它主要关注数据和信息的结构、传递和处理过程。信息视角使用UML的类图、序列图等图形来表示，描述数据实体、数据之间的关系，以及数据在系统内部和与外部系统之间的流动和传递。</p>
</li>
<li><p>软件体系结构设计阶段有哪些其他的开发活动？</p>
<p>软件体系结构设计阶段的其他开发活动包括：</p>
<ul>
<li>需求分析：明确系统需求，包括功能需求、性能需求、非功能性需求等。</li>
<li>风险评估：评估体系结构设计的技术风险和项目风险，确保设计方案的可行性和稳定性。</li>
<li>技术选型：选择合适的技术、框架和工具，支持体系结构的实现和开发过程。</li>
<li>成本估算：估算体系结构设计和开发的成本，以确定项目的可行性和资源规划。</li>

</ul>
</li>
<li><p>如何选定关键需求？</p>
<p>选定关键需求的步骤：</p>
<ul>
<li>理解需求：深入理解用户需求和系统的关键功能。</li>
<li>识别优先级：根据系统的目标和重要性，确定哪些需求对系统的成功和核心功能至关重要。</li>
<li>客户参与：与客户或利益相关者一起评估和确认关键需求，确保设计方案满足其期望。</li>

</ul>
</li>
<li><p>为什么要实现体系架构原型？</p>
<p>实现体系结构原型的目的是验证和评估设计方案的可行性、有效性和有效性。通过实现一个简化的体系结构原型，可以及早发现设计中的问题和风险，并快速验证系统的关键功能和性能。</p>
</li>
<li><p>为什么要对关键需求进行端到端的实现？</p>
<p>对关键需求进行端到端的实现是为了确保系统在整个生命周期中满足这些需求，从需求到设计、开发、测试和部署都需要对关键需求进行全面的覆盖和验证，以确保系统最终交付的功能和性能符合预期。</p>
</li>
<li><p>什么时候撰写集成测试计划？什么时候实施集成测试？</p>
<p>集成测试计划撰写时间通常是在系统设计和开发阶段之后，确定系统的集成测试策略、范围、资源需求和进度安排。实施集成测试通常在软件开发阶段后期进行，当所有模块或组件已经开发完成并且准备集成时开始。</p>
</li>
<li><p>集成测试策略一般包含哪几种？</p>
<p>集成测试策略一般包括以下几种：</p>
<ul>
<li>自上而下集成：从上层模块开始逐步向下集成，逐步测试系统的完整性。</li>
<li>自下而上集成：从最底层的模块开始逐步向上集成，逐步测试系统的完整性。</li>
<li>大爆炸集成：同时集成多个模块或组件，测试整个系统的完整性和稳定性。</li>
<li>逐步集成：按照功能模块或模块组进行逐步集成，逐步测试系统的完整性。</li>

</ul>
</li>
<li><p>集成测试用例如何设计？</p>
<p>集成测试用例的设计要确保覆盖系统的所有功能和交互，以验证模块和组件之间的正确集成和交互。设计集成测试用例时，需要考虑不同模块之间的接口、数据流、错误处理等情况，并确保所有关键功能和关键路径都得到覆盖和测试。集成测试用例应该着重测试系统的整体功能和性能，以确保系统在集成后能正常运行和满足需求。</p>
</li>
<li><p>集成测试中的stub和driver如何设计？</p>
<ul>
<li>Stub：在测试过程中代替尚未开发或不可用的模块，用于模拟模块的功能，使得被测试模块能够独立运行。Stub通常返回预先定义好的数据，以便测试模块能够继续进行下去。</li>
<li>Driver：在测试过程中代替被测模块的上层或下层模块，用于驱动被测试模块的执行。Driver通常调用被测试模块的功能，并传递预先定义好的测试数据，以模拟上层或下层模块的行为。</li>

</ul>
</li>
<li><p>如何做持续集成？</p>
<ol start='' >
<li>版本控制：使用版本控制工具（如Git）管理项目代码。确保所有开发人员都将代码提交到共享的版本控制库中。</li>
<li>自动构建：配置自动化构建工具（如Jenkins、Travis CI、CircleCI等）来自动执行构建任务。构建任务包括获取最新代码、编译代码、生成可执行文件或部署包等。</li>
<li>自动化测试：编写并配置自动化测试用例，包括单元测试、集成测试和端到端测试。确保所有测试用例可以自动执行，并能够在构建过程中运行。</li>
<li>触发构建：设置触发构建的条件，例如代码提交到版本控制库后自动触发构建，或定时执行构建任务。</li>
<li>构建报告：生成构建报告，记录构建过程中的日志、测试结果和代码覆盖率等信息，便于开发团队查看构建状态和测试结果。</li>
<li>快速反馈：持续集成的目标是尽早发现问题，因此需要及时向开发人员提供构建和测试的结果。如果构建或测试失败，需要及时通知相关人员，并尽快解决问题。</li>
<li>集成环境：确保持续集成的集成环境是稳定和可靠的。集成环境应该与生产环境尽可能相似，以便及早发现可能在生产环境中出现的问题。</li>
<li>持续改进：定期评估持续集成的效果，包括构建时间、测试覆盖率、错误率等指标。根据评估结果，优化构建和测试过程，提高持续集成的效率和质量。</li>

</ol>
</li>
<li><p>体系结构设计评审的目标是什么？</p>
<p>体系结构设计评审的目标是确保体系结构设计满足系统需求，符合预期目标，并满足质量属性要求。评审的目标还包括发现潜在的问题、风险和冲突，以及提供改进和优化建议。</p>
</li>
<li><p>体系结构设计评审会邀请什么人来参加？</p>
<p>参加体系结构设计评审的人员包括：</p>
<ul>
<li>项目经理：了解项目的目标、约束和风险，确保设计符合项目管理和业务目标。</li>
<li>架构师：负责体系结构设计，解释设计决策并回答技术问题。</li>
<li>开发团队：参与讨论和提供实现建议。</li>
<li>质量保障团队：确保体系结构满足质量属性要求。</li>
<li>利益相关者：可能影响系统设计和决策的相关人员。</li>

</ul>
</li>
<li><p>体系结构评审时的关注点有哪些方面？</p>
<p>体系结构评审时的关注点包括：</p>
<ul>
<li>模块划分和组织：检查模块的职责和功能划分是否合理。</li>
<li>接口设计：验证模块之间的接口定义是否清晰和一致。</li>
<li>系统质量属性：确保设计满足性能、可靠性、安全性等质量属性的要求。</li>
<li>可扩展性：评估系统的可扩展性，以适应未来的需求变化。</li>
<li>技术选型：确认所选技术是否适合系统的需求和目标。</li>

</ul>
</li>
<li><p>体系结构设计文档一般有哪些重要组成部分？</p>
<p>体系结构设计文档一般包括以下重要组成部分：</p>
<ul>
<li>需求分析：对系统需求的描述和分析，包括功能需求和非功能性需求。</li>
<li>架构设计：对系统体系结构的整体描述，包括模块划分、组件关系、接口定义等。</li>
<li>技术选型：对所选技术、框架和工具的描述和理由。</li>
<li>质量属性：对系统质量属性（性能、安全性等）的要求和设计决策。</li>
<li>接口设计：对模块之间的接口定义和数据交换方式的描述。</li>
<li>安全设计：对系统安全机制和措施的描述。</li>
<li>扩展性和可维护性：对系统的扩展性和可维护性设计的说明。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十一人机交互设计'>十一、人机交互设计</h2>
<h3 id='1）人机交互设计的目标'>（1）人机交互设计的目标</h3>
<ol start='' >
<li><p>人机交互的目的是探索在人和机器之间沟通的有效方法，让用户利用机器顺利完成任务。好的人机交互应该是透明的，需要符合用户的习惯特点，适应用户的技能和经验。</p>
</li>
<li><p>“透明”是人机交互的目标，也就是“易用性”，易用性的维度包括：</p>
<ol start='' >
<li>易学性：新手用户容易学习，度量方法是完全没有经过培训的用户完成特定任务所需时间。</li>
<li>效率：熟练用户使用系统完成任务的速度，度量方法是经过培训的熟练用户完成特定任务所需时间。</li>
<li>易记性：以前使用过系统的用户能够有效记忆或快速重新学会使用系统，度量方法是以前使用过系统的用户完成特定任务的时间。</li>
<li>出错率：用户在使用系统时犯错的程度和能否恢复错误，度量方法是用户完成特定任务或一段时间内的出错数量。</li>
<li>主观满意度：非客观度量，通过问卷获得用户的主观评价。</li>

</ol>
</li>

</ol>
<h3 id='2）人机交互设计的人类因素'>（2）人机交互设计的人类因素</h3>
<ol start='' >
<li><p>精神模型：即用户进行人机交互时头脑中的任务模型，人机交互设计需要依据精神模型进行隐喻设计，又称视觉隐喻，让用户将视觉上的图形映射为业务事物。</p>
</li>
<li><p>差异性：针对不同用户群体的设计也要有差异性，用户群体可以分为：</p>
<ol start='' >
<li>新手用户</li>
<li>专家用户</li>
<li>熟练用户</li>

</ol>
</li>

</ol>
<h3 id='3）人机交互设计的计算机因素'>（3）人机交互设计的计算机因素</h3>
<ol start='' >
<li><p>可视化设计</p>
<ol start='' >
<li>要点是按照任务模型设计界面隐喻，同时避免暴露软件系统的内部构造机制。</li>
<li>同时要基于界面隐喻，尽可能将功能和任务细节表现出来。</li>

</ol>
</li>
<li><p>常见界面类型：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%889.12.16.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午9.12.16"></p>
</li>
<li><p>软件系统通常同时使用多种界面类型，以适应差异性的用户和任务。</p>
</li>

</ol>
<h3 id='4）人机交互设计的交互性'>（4）人机交互设计的交互性</h3>
<ol start='' >
<li><p>系统计算时间过长，15s～3min就需要提供动画以减少等待感，3min以上就需要进度条让用户感到系统在工作。</p>
</li>
<li><p>人机交互设计原则</p>
<ol start='' >
<li><p>简介设计：7+-2原则，不要展现太多复杂无关的信息。</p>
</li>
<li><p>一致性设计</p>
</li>
<li><p>低出错率设计</p>
<ol start='' >
<li>使用清晰的语音而非代码</li>
<li>语言应当精炼准确，而不是空泛、模糊</li>
<li>应当对用户解决问题提供建设性的帮助</li>
<li>出错信息应该友好，不要威胁或责备</li>
<li>提供错误恢复和故障解决手册</li>

</ol>
</li>
<li><p>易记性设计</p>
<ol start='' >
<li>减少短期记忆负担</li>
<li>逐层递进的方式展示信息</li>
<li>直观的快捷方式</li>
<li>有意义的默认值</li>

</ol>
</li>

</ol>
</li>
<li><p>导航：提供完成任务的入口。</p>
</li>
<li><p>反馈：视觉、声音上的反馈，让用户能够意识到行为的结果，提示用户交互行为的后果。</p>
</li>
<li><p>协作式设计：调整计算机因素以更好地适应并帮助用户的设计方法。人和计算机是人机交互的两方，其中人的因素是比较固定的，所以需要让计算机更多的适应人的因素，这也是为什么需要以用户为中心。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十二详细设计的基础'>十二、详细设计的基础</h2>
<h3 id='1）详细设计概述'>（1）详细设计概述</h3>
<ol start='' >
<li><p>详细设计的出发点：</p>
<ol start='' >
<li>需求开发的结果（需求规格说明和需求分析模型）</li>
<li>软件体系结构的结果（软件体系结构设计方案与原型）</li>

</ol>
</li>
<li><p>详细设计应该在软件体系结构设计之后进行。</p>
</li>

</ol>
<h3 id='2）结构化设计'>（2）结构化设计</h3>
<ol start='' >
<li>结构化设计按算法对系统进行分解。</li>
<li>结构化设计主要建模技术是结构图，按照自顶向下分解法，将系统分解为一个树状结构。通过结构图可以知道系统的复杂度、实现功能需要的模块或者方法、方法是否能够被管理或再分解。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.29.51.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.29.51"></li>

</ol>
<h3 id='3）面向对象设计'>（3）面向对象设计</h3>
<ol start='' >
<li><p>面向对象将系统抽象成具有一定职责的数据个体，个体之间互相协作完成任务。每个数据个体除有自己的独特的数据信息，还包含一些依赖这些数据所做的事。</p>
</li>
<li><p>再将系统分解为小的数据个体的时候，是按照数据个体的单一职责来分解的。</p>
</li>
<li><p>设计过程：</p>
<ol start='' >
<li><p>设计模型建立</p>
<ol start='' >
<li><p>职责分配：</p>
<ol start='' >
<li><p>抽象类的职责</p>
</li>
<li><p>抽象类之间的关系</p>
<ol start='' >
<li>关系表达了相应职责的划分和组合</li>
<li>依赖&lt;关联&lt;聚合&lt;组合&lt;继承</li>
<li><img src="https://wbw2333.github.io/assets/软工-第n部分/截屏2023-07-25 上午10.39.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.39.59"> <img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.40.18.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.40.18"></li>

</ol>
</li>
<li><p>添加辅助类</p>
</li>

</ol>
</li>
<li><p>通过协作建立动态设计模型</p>
<ol start='' >
<li><p>抽象对象之间协作</p>
</li>
<li><p>明确对象的创建<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.53.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.53.59"></p>
</li>
<li><p>选择合适的控制风格<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.54.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.54.38"></p>
<ol start='' >
<li>集中式：做决策的只有一个对象，这个对象决定怎么分配职责，怎么实现大职责。所有其他对象只和这个对象进行交互。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.11.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.11"></li>
<li>委托式：做出决策的对象不止一个，这些对象分别承担一定职责，做出一些决策，共同实现大职责。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.51.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.51"></li>
<li>分散式：无明确的控制对象，每个对象只承担一个小职责，完全靠各个对象自治实现大职责。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.19.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.19"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.39"></li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>设计模型重构</p>
<ol start='' >
<li>根据模块化的思想重构，目标为高内聚、低耦合</li>
<li>根据信息隐藏的思想重构，目标为隐藏职责与变更</li>
<li>利用设计模式重构</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）为类间协作开发集成测试用例'>（4）为类间协作开发集成测试用例</h3>
<ol start='' >
<li><p>每个类在被独立开发完成后，也需要类间协作的集成测试，需要以详细设计模型为基础为类间协作开发集成测试用例，类间协作通常以协作图为线索开发模块内部的集成测试用例。</p>
</li>
<li><p>类间协作集成分为：</p>
<ol start='' >
<li>自顶向下：从协作的发起端开始向协作终端集成，需要较少的驱动代码和较多的桩程序。</li>
<li>自底向上：从协作的终端开始向协作发起端集成，需要较多的驱动代码和较少的桩代码。</li>

</ol>
</li>
<li><p>类间协作的桩程序称为Mock Object，要求自身测试代码简单，可以不测试就保证正确性。</p>
</li>

</ol>
<h3 id='5）详细设计文档描述'>（5）详细设计文档描述</h3>
<p>软件详细设计文档强调模块内部的结构和行为，如类图、类接口定义、类协作、复杂数据结构定义、复杂算法逻辑等。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8811.05.01.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午11.05.01"></p>
<h3 id='6）详细设计评审'>（6）详细设计评审</h3>
<p>评审不仅要关注详细设计阶段的工作，还要综合看待整个设计。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8811.05.35.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午11.05.35"></p>
<h3 id='7）习题'>（7）习题</h3>
<ol start='' >
<li><p>详细设计的关注点在哪里？</p>
<p>详细设计的关注点在于对系统的功能和模块进行具体的设计，包括数据结构、算法、接口、错误处理和性能优化等方面。</p>
</li>
<li><p>详细设计的过程是怎样的？</p>
<p>详细设计的过程一般包括以下步骤：</p>
<ul>
<li>理解需求：深入理解需求规格和体系结构设计，确定功能和模块划分。</li>
<li>设计数据结构：定义系统中数据的结构和类型，包括数据库表设计和数据交换格式。</li>
<li>设计算法和逻辑：设计实现各个功能和模块的具体算法和处理逻辑。</li>
<li>接口设计：定义模块之间的接口和数据交换方式。</li>
<li>错误处理：设计对异常情况和错误的处理机制，确保系统的容错性和稳定性。</li>
<li>性能优化：考虑代码的执行效率和性能，优化算法和代码结构，以提高系统的运行效率。</li>

</ul>
</li>
<li><p>什么是详细设计的上下文？</p>
<p>详细设计的上下文是指在系统体系结构设计的基础上，对具体的模块进行更为详细的设计。详细设计依赖于体系结构设计，将系统的整体设计细化为各个模块的具体实现。</p>
</li>
<li><p>存在完美的理性设计过程吗？</p>
<p>不存在完美的理性设计过程。设计是一个复杂的过程，需要考虑众多因素和权衡各种需求。即使进行了详尽的计划和分析，也难以完全预见所有情况和需求变化。因此，设计过程中难免会出现一些不完美或需要改进的地方。</p>
</li>
<li><p>真实的设计过程是如何的？</p>
<p>真实的设计过程是复杂和动态的。它通常涉及不断的反馈和迭代，从最初的草图和初步设计逐渐完善和优化。设计过程中可能会面临需求变更、技术限制、时间压力等挑战，需要不断调整和适应。</p>
</li>
<li><p>结构化详细设计的重点是什么？</p>
<p>结构化详细设计的重点在于合理划分模块和功能，确保模块之间的高内聚和低耦合。结构化设计强调模块的分解和功能的划分，使得系统的设计结构清晰、易于理解和维护。重点包括数据结构的设计、算法的设计、接口的定义和错误处理的设计。结构化设计追求模块的独立性和可重用性，以便在不同系统中进行复用和扩展。</p>
</li>
<li><p>如何将数据流图转换为结构图？</p>
<p>将数据流图转换为结构图的步骤：</p>
<ul>
<li>确定功能和模块：根据数据流图，识别各个功能和模块。</li>
<li>识别输入和输出：确定模块的输入和输出数据流。</li>
<li>划分模块：将数据流图中的功能和模块分解为更小的可处理单元。</li>
<li>确定数据存储：标识模块间的数据存储和传递方式。</li>
<li>构建结构图：使用合适的图形符号和连接线，绘制模块的结构图。</li>

</ul>
</li>
<li><p>面向对象详细设计的步骤和重点是什么？</p>
<p>步骤：</p>
<ol start='' >
<li>定义类和对象：根据需求分析和系统架构设计，确定系统中需要的类和对象，包括识别实体类、边界类和控制类。</li>
<li>确定类的属性和方法：为每个类确定合适的属性和方法，这些属性和方法应该与类的职责和功能相匹配。</li>
<li>确定类之间的关系：根据系统的业务逻辑和功能需求，确定类之间的关系，包括继承、关联、聚合、组合等。</li>
<li>设计类的接口：定义类的公共接口，即外部可以访问的方法，确保类的封装性和信息隐藏。</li>
<li>定义类的行为：描述每个类的具体行为，包括方法的算法和处理逻辑。</li>
<li>设计类的状态：如果类具有状态，需要定义类的状态和状态转换。</li>
<li>确定类的实例化：确定类在系统中如何被实例化和管理。</li>

</ol>
<p>重点：</p>
<ol start='' >
<li>类的职责和功能：确保每个类的职责清晰明确，遵循单一职责原则，一个类应该有一个明确的目标。</li>
<li>类的关系：确定类之间的关系，包括继承、关联、聚合、组合等，确保类之间的关系合理并满足系统需求。</li>
<li>类的接口：设计类的公共接口，确保接口的合理性和易用性，隐藏类的内部实现细节。</li>
<li>类的封装性：封装类的属性和方法，确保类的内部实现对外部的透明性，避免直接访问类的内部数据。</li>
<li>方法的算法和逻辑：设计方法的算法和处理逻辑，确保方法的功能正确且高效。</li>
<li>类的状态：如果类具有状态，需要设计类的状态和状态转换，确保状态的合理性和一致性。</li>
<li>可扩展性：考虑系统的可扩展性，确保类的设计可以方便地进行扩展和修改。</li>

</ol>
</li>
<li><p>类之间的关系有哪些？如何表示？</p>
<p>类之间的关系有以下几种：</p>
<ul>
<li>继承（Inheritance）：表示类之间的继承关系，子类继承父类的属性和方法。</li>
<li>关联（Association）：表示类之间的关联关系，表示一个类与另一个类之间的关系，双向关联为双向箭头，单向关联为单向箭头。</li>
<li>聚合（Aggregation）：表示整体与部分之间的关系，表示一个类包含多个其他类的对象。</li>
<li>组合（Composition）：表示整体与部分之间的关系，但是整体与部分的生命周期相互依赖。</li>
<li>依赖（Dependency）：表示一个类依赖于另一个类，即一个类使用到另一个类的方法或属性。</li>

</ul>
</li>
<li><p>同步消息与异先消息的区别是什么？</p>
<p>同步消息是发送方发送消息后立即等待接收方处理和返回结果，而异步消息是发送方发送消息后不等待接收方的即时响应，继续执行后续操作。同步消息保证了消息的顺序性和可靠性，但可能导致阻塞等待；异步消息提高了并发性和响应性，但需要另外的机制来处理结果和异常情况。选择同步消息还是异步消息取决于系统的需求和设计考虑。</p>
</li>
<li><p>对象创建有什么法则？</p>
<p>对象创建的法则：</p>
<ul>
<li>确定是否需要创建对象：只有当某个对象具有明确的角色和职责，并在系统中扮演重要的角色时，才需要创建对象。</li>
<li>确定对象的属性和方法：确定对象的属性和方法，确保对象的职责清晰明确。</li>
<li>考虑对象的生命周期：考虑对象的创建、使用和销毁，确保对象的生命周期符合系统需求。</li>

</ul>
</li>
<li><p>描述集中式、委托式和分散式控制风格的优缺点。</p>
<p>集中式、委托式和分散式控制风格的优缺点：</p>
<ul>
<li>集中式控制：优点是简单明了，易于管理和维护；缺点是扩展性较差，系统可能出现单点故障。</li>
<li>委托式控制：优点是可以灵活地委托不同的对象处理任务，便于分工和协作；缺点是可能导致过多的委托关系，增加了系统的复杂性。</li>
<li>分散式控制：优点是各个对象可以独立处理任务，系统灵活性较高；缺点是可能导致任务分散，难以维护和管理。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十三详细设计中的模块化与信息隐藏'>十三、详细设计中的模块化与信息隐藏</h2>
<h3 id='1）模块化与信息隐藏思想'>（1）模块化与信息隐藏思想</h3>
<ol>
<li>模块化与信息隐藏思想的动机：实现重要的质量标准而提出的设计方法。</li>

</ol>
<h3 id='2）模块化'>（2）模块化</h3>
<ol>
<li><p>模块：一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标识符。</p>
</li>
<li><p>模块化最重要的原则：高内聚低耦合，每个模块内部有最大关联，而模块之间有最小关联。</p>
</li>
<li><p>耦合</p>
<ol>
<li>耦合描述的是两个模块之间关系的复杂程度。</li>
<li>耦合性越高，模块的划分越差，越不利于软件的变更和复用。</li>
<li>耦合性的划分：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%889.16.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午9.16.00"></li>
<li>内容耦合、重复耦合、公共耦合是不能接受的，必须要消除，数据耦合是最好的，控制耦合、印记耦合可以接受。</li>

</ol>
</li>
<li><p>内聚</p>
<ol>
<li>内聚表达的是一个模块内部的联系的紧密性。</li>
<li>内聚性越高越好，越低越不易实现变更和复用。</li>
<li>内聚性的划分：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%889.23.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午9.23.59"></li>
<li>偶然内聚和逻辑内聚不能接受，通信内聚、过程内聚、时间内聚是可以接受且不可避免的。</li>

</ol>
</li>

</ol>
<h3 id='3）信息隐藏'>（3）信息隐藏</h3>
<ol>
<li><p>信息隐藏的核心思想：每个模块都隐藏一个重要的设计决策，抽象出类的关键细节（职责）。即抽象出接口，隐藏实现。</p>
</li>
<li><p>信息隐藏就是隐藏认为会改变的设计决策，把每个设计秘密指派给单独的模块，封装每个秘密，使得即使发生改变变化也不会对其他部分产生影响。</p>
</li>
<li><p>信息隐藏的决策：</p>
<ol>
<li>需求分配的职责</li>
<li>内部实现机制</li>

</ol>
</li>
<li><p>模块说明（模块及设计决策文档化）主要记录两个方面的四个主题：</p>
<ol>
<li><p>从内部角度说模块隐藏的秘密</p>
<ol>
<li>来自于需求的主要秘密：描述模块所实现的用户需求。</li>
<li>根源于实现的次要秘密：描述模块实现职责设计的关键实现细节。</li>

</ol>
</li>
<li><p>从外部角度看模块承担的角色</p>
<ol>
<li>模块承担的角色：描述独立的模块在整个系统中承担的角色、所起的作用、与哪些模块有关系。</li>
<li>模块提供的接口：模块提供给别的模块的接口。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题'>（4）习题</h3>
<ol>
<li><p>描述常见的设计质量的考量。</p>
<p>常见的设计质量考量包括：</p>
<ul>
<li>可维护性：设计的代码易于理解、修改和维护，遵循良好的编码规范和设计原则。</li>
<li>可扩展性：设计的系统可以方便地进行功能扩展和模块添加，不会因为新增功能而影响原有功能的稳定性。</li>
<li>可重用性：设计的模块和组件可以在多个地方被重复使用，提高代码的复用性和开发效率。</li>
<li>可测试性：设计的代码易于进行单元测试和集成测试，确保代码质量和功能正确性。</li>
<li>高效性：设计的算法和数据结构要求在时间和空间上具有高效性，避免性能瓶颈。</li>
<li>可靠性：设计的代码要具有稳定性和健壮性，能够在各种条件下正常运行，避免系统崩溃和错误。</li>
<li>安全性：设计要考虑系统的安全性，防范恶意攻击和数据泄露。</li>
<li>灵活性：设计要考虑系统的适应性，可以适应需求变化和技术进步。</li>

</ul>
</li>
<li><p>描述模块化与信息隐藏的思想及其发展。</p>
<p>模块化与信息隐藏的思想及其发展：</p>
<p>模块化是将系统划分为独立的、具有清晰功能的模块，每个模块都有明确定义的接口和功能。模块化的思想早期来源于结构化编程，将程序分解为更小的、可重复使用的模块，提高了程序的可读性和可维护性。</p>
<p>信息隐藏是将模块的内部实现细节隐藏起来，只对外暴露必要的接口，通过接口与其他模块进行交互。这样可以降低模块之间的耦合度，使得模块可以独立开发、测试和维护，提高了系统的可扩展性和可维护性。</p>
<p>随着面向对象编程的兴起，模块化和信息隐藏的思想进一步发展为对象的封装和继承。对象是一个独立的、具有状态和行为的实体，通过封装将对象的属性和方法隐藏起来，只通过接口与其他对象进行交互。继承允许对象共享相同的属性和方法，并允许子类扩展或修改父类的行为。</p>
</li>
<li><p>如何写一个模块的模块说明？</p>
<p>编写模块的模块说明一般包括以下内容：</p>
<ul>
<li>模块名称：说明模块的名称和用途。</li>
<li>输入：列出模块的输入参数和数据。</li>
<li>输出：列出模块的输出参数和数据。</li>
<li>功能：描述模块的功能和目标。</li>
<li>算法和逻辑：说明模块的实现算法和处理逻辑。</li>
<li>接口：描述模块的接口，包括输入和输出的格式、协议等。</li>
<li>使用方法：说明如何使用该模块，并提供示例。</li>
<li>限制和注意事项：列出模块的限制条件和需要注意的事项。</li>
<li>作者和修改记录：记录模块的作者和修改历史。</li>
<li>引用和参考资料：列出相关的引用和参考资料。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十四详细设计中面向对象方法下的模块化'>十四、详细设计中面向对象方法下的模块化</h2>
<h3 id='1）面向对象中的模块'>（1）面向对象中的模块</h3>
<ol>
<li><p>面向对象方法中，除了类之间调用关系外，类与类之间的关系还有：</p>
<ol>
<li>关联</li>
<li>继承</li>

</ol>
</li>

</ol>
<h3 id='2）访问耦合'>（2）访问耦合</h3>
<ol>
<li><p>如果类A拥有对类B的引用，则A可以访问B。</p>
</li>
<li><p>访问耦合程度：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.03.53.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.03.53"></p>
</li>
<li><p>类之间的耦合性还需要考虑具体的访问次数。</p>
</li>
<li><p>隐式访问需要避免，实现访问时可以接受且必要的，成员变了访问和参数变量访问是提倡的。</p>
</li>
<li><p>降低访问耦合的方法</p>
<ol>
<li><p>针对接口编程（Programming to Interface）</p>
<ol>
<li>要求在设计时明确类的契约，标明访问耦合和需接口。</li>
<li>原则：基于细化后的类契约进行设计工作。</li>

</ol>
</li>
<li><p>接口最小化/接口分离原则（Interface Segregation Principle，LSP）</p>
<ol>
<li>讲一个统一的接口匹配为多个更独立的接口，避免不必要的耦合，实现接口最小化。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.21.44.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.21.44"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.21.58.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.21.58"></li>

</ol>
</li>
<li><p>访问耦合的合理范围/迪米特法则（Demeter Law）</p>
<ol>
<li><p>迪米特法则</p>
<ol>
<li>每个单元对于其他单元只能拥有有限的知识，只是与当前单元紧密联系的单元。</li>
<li>每个单元只能和他的朋友交谈，不能和陌生单元交谈。</li>
<li>只和自己直接的朋友交谈。</li>

</ol>
</li>
<li><p>迪米特法则强调不要出现a.b.Method()，而是a.Method()，即应该是人命令狗去行走，而不是人命令狗的腿去行走。</p>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）继承耦合'>（3）继承耦合</h3>
<ol>
<li><p>由于类与类之间有继承关系，父类与子类存在耦合。</p>
</li>
<li><p>继承耦合程度：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.36.30.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.36.30"></p>
</li>
<li><p>修改规格、修改实现、精化规格是不可接受的，精化实现常被使用。</p>
</li>
<li><p>降低继承耦合的方法</p>
<ol>
<li><p>Liskov替换原则</p>
<ol>
<li>子类型必须能够替换掉基类型而起同样的作用。</li>
<li>为了满足LSP，需要保证：子类方法的前置条件必须与超类方法的前置条件相同或者更少；子类方法的后置条件必须比超类方法的后置套件相同或更少。</li>
<li>符合LSP的继承能够减少耦合，不符合LSP的继承反而会增加耦合。</li>

</ol>
</li>
<li><p>使用组合替代继承（Favor Composition Over Inheritance）</p>
<ol>
<li>继承机制具有组织类型差异和复用两种性质，在只需要复用而不需要组织类型差异的情况下是不需要继承机制的，应该使用组合替代继承实现复用。</li>
<li>使用组合关系既能复用代码又能保持接口的灵活性。</li>
<li>希望复用代码又不能满足LSP时，应使用组合替代继承。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）内聚'>（4）内聚</h3>
<ol>
<li><p>面向对象中的内聚有：</p>
<ol>
<li>方法的内聚：提现方法实现语句之间的内聚性。</li>
<li>类的内聚：衡量类的成员变量和方法之间的内聚。</li>
<li>继承内聚：继承树中类之间的内聚，如果类之间有很好的概念上的联系，则类之间的继承内聚性高。</li>

</ol>
</li>
<li><p>提高内聚方法</p>
<ol>
<li><p>集中信息与行为</p>
<ol>
<li>类的信息应该和访问这些信息的行为放在一起，集中信息与行为，即信息内聚的。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.31.36.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.31.36"></li>

</ol>
</li>
<li><p>单一职责原则（Single Responsibility Principle，SRP）</p>
<ol>
<li>信息与行为除了集中之外，还要联合起来表达一个内聚的概念。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.38.40.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.38.40"></li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='5）耦合与内聚的度量'>（5）耦合与内聚的度量</h3>
<ol>
<li><p>耦合的度量</p>
<ol>
<li><p>方法调用耦合：CBO计算一个类与外界的耦合度，包括：</p>
<ol>
<li>该类调用其他类的成员方法的数量。</li>
<li>其他类访问这个类的成员方法的数量。（其他类不包括存在继承关系的类）</li>

</ol>
</li>
<li><p>访问耦合：DAC统计一个类包含其他类的实例的数量，不包括继承关系的实例引用。</p>
</li>
<li><p>继承耦合：</p>
<ol>
<li>NOC统计直接所属的子类的数目，当NOC越大复用越多，也意味着父类越抽象越脆弱。</li>
<li>DIT统计从继承树根节点到叶节点的长度，DIT越大意味着子类遵守的越数越多且越隐晦。</li>
<li>NOC和DIT超过3就需要检查继承机制，确保能够遵守LSP。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.45.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.45.08"></li>

</ol>
</li>

</ol>
</li>
<li><p>内聚的度量：LCOM是比较容易实施的内聚度量。</p>
</li>

</ol>
<h3 id='6）习题'>（6）习题</h3>
<ol>
<li><p>如何理解面向对象中的模块？</p>
<p>在面向对象中，模块指的是独立的、具有特定功能的代码单元或组件。模块是对系统进行分解的基本单位，它包含数据和方法的封装，通过接口与其他模块进行交互。模块化是一种设计思想，将系统划分为多个模块，每个模块负责完成特定的功能，模块之间通过接口进行通信和协作。模块化设计使得系统更易于维护、扩展和理解。</p>
</li>
<li><p>类和类之间的联系有哪些？</p>
<p>类和类之间的联系有以下几种：</p>
<ul>
<li>继承关系（Inheritance）：一个类可以继承另一个类的属性和方法，形成父类和子类之间的继承关系。子类继承了父类的特性，并可以扩展和重写父类的方法。</li>
<li>关联关系（Association）：表示类之间的关联关系，表示一个类与另一个类之间的连接，通常是某个类作为另一个类的属性或方法的参数或返回值。</li>
<li>聚合关系（Aggregation）：表示整体与部分之间的关系，表示一个类包含多个其他类的对象，是一种“整体-部分”的关系。</li>
<li>组合关系（Composition）：表示整体与部分之间的关系，但整体与部分的生命周期相互依赖，是一种比聚合更强的“整体-部分”的关系。</li>
<li>依赖关系（Dependency）：表示一个类依赖于另一个类，即一个类使用到另一个类的方法或属性。</li>

</ul>
</li>
<li><p>解释接口最小化原则。</p>
<p>接口最小化原则（Interface Segregation Principle，ISP）：该原则强调一个类不应该依赖于它不需要的接口。接口应该精简和单一，只包含必要的方法，而不是将所有方法都放在一个庞大的接口中。这样可以降低类之间的耦合度，使得类的设计更加灵活和可维护。</p>
</li>
<li><p>降低访问耦合的方法有哪些？</p>
<p>降低访问耦合的方法有以下几种：</p>
<ul>
<li>封装：将类的内部实现细节隐藏起来，只暴露必要的接口。这样可以降低类之间的直接访问，减少耦合。</li>
<li>接口隔离：遵循接口最小化原则，将接口设计精简和单一，避免一个类依赖于不需要的接口。</li>
<li>使用中介者模式：引入中介者类，将类之间的交互通过中介者进行，减少类之间的直接依赖。</li>
<li>使用观察者模式：将观察者和被观察者解耦，当被观察者发生变化时，通知观察者进行相应的操作，降低彼此之间的耦合度。</li>

</ul>
</li>
<li><p>解释迪米特法则。</p>
<p>强调一个对象应该尽可能少地了解其他对象，只与直接朋友（成员变量、方法参数、方法返回值）进行交互。迪米特法则希望减少对象之间的依赖关系，降低耦合度，使得系统更加灵活、易于维护和扩展。遵循迪米特法则有助于提高代码的可维护性和可读性。</p>
</li>
<li><p>降低继承耦合的方法有哪些？</p>
<p>降低继承耦合的方法有：</p>
<ul>
<li>使用接口（Interface）：通过接口来定义类的行为，而不是直接使用继承。接口定义了类应该实现的方法，使得不同的类可以实现相同的接口，降低了继承的耦合度。</li>
<li>组合代替继承：通过将一个类作为另一个类的成员变量，而不是继承另一个类，来实现功能的复用。这种方式降低了继承的复杂性和耦合度。</li>
<li>使用委托（Delegation）：将某个功能的实现委托给另一个类，而不是通过继承来实现。委托可以减少类之间的依赖，降低继承耦合。</li>

</ul>
</li>
<li><p>解释Liscov替换原则。</p>
<p>如果一个类型是其基类的子类型，那么它应该能够替换掉基类的对象，而不影响程序的正确性。换句话说，派生类对象可以在不影响程序正确性的情况下替代基类对象。</p>
</li>
<li><p>组合替代继承的好处有哪些？</p>
<p>组合替代继承的好处有：</p>
<ul>
<li>更灵活的代码结构：组合可以将功能拆分为更小的部分，灵活地组合和复用这些部分，而不受类的继承结构限制。</li>
<li>降低耦合度：组合关系相比继承关系更加松散，减少了类之间的耦合，使得代码更易于维护和扩展。</li>
<li>避免类的膨胀：继承可能导致类的层次结构复杂，而组合可以避免类的膨胀，使得代码更加简洁和清晰。</li>
<li>支持动态组合：组合关系允许在运行时动态地更改对象的组合方式，使得系统更加灵活和可配置。</li>

</ul>
</li>
<li><p>类之问稱合的度量有哪些指标？怎么计算？</p>
<ol>
<li><p>类之间的耦合度可以通过一些指标来度量，常见的指标有：</p>
<ul>
<li>类的依赖数（Dependents）：表示其他类依赖于该类的数量。</li>
<li>类的被依赖数（Dependencies）：表示该类依赖于其他类的数量。</li>
<li>类的关联数（Associations）：表示该类与其他类之间的关联关系数量。</li>
<li>类的继承深度（Inheritance Depth）：表示该类在继承层次中的深度。</li>

</ul>
</li>

</ol>
</li>
<li><p>面向对象方法中，有哪些提高内聚的方法？</p>
<p>面向对象方法中，提高内聚的方法有：</p>
<ul>
<li>单一职责原则（Single Responsibility Principle，SRP）：每个类应该只有一个单一的责任，即一个类应该只负责完成一个功能。</li>
<li>封装：将类的属性和方法封装起来，只暴露必要的接口，隐藏内部实现细节，增强类的内聚性。</li>
<li>设计模式：采用设计模式，如工厂模式、策略模式等，可以将相关功能放在同一个类中，提高类的内聚性。</li>
<li>组合：将多个功能相近的类组合在一起，形成一个更大的类，提高类的内聚性和功能的复用性。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十五详细设计中面向对象方法下的信息隐藏'>十五、详细设计中面向对象方法下的信息隐藏</h2>
<h3 id='1）封装类的职责'>（1）封装类的职责</h3>
<ol>
<li><p>职责指的是类或对象维护一定的状态信息，并基于状态履行行为只职能的能力。类与对象的职责来源于需求。</p>
</li>
<li><p>封装的含义为：</p>
<ol>
<li>将数据和行为同时包含在类中</li>
<li>分离对外接口与内部实现</li>

</ol>
</li>
<li><p>接口通常描述以下内容：</p>
<ol>
<li>对象之间交互的消息（方法名）</li>
<li>消息中的参数</li>
<li>消息返回结果的类型</li>
<li>与状态无关的不变量</li>
<li>需要处理的异常</li>

</ol>
</li>
<li><p>需要封装的细节</p>
<ol>
<li>封装数据和行为</li>
<li>封装内部结构</li>
<li>封装其他对象的引用</li>
<li>封装类型信息：多种子类型因为具备一些共性而被视作用一种类型时，因隐藏其具体子类型的类别而只知道共性类别。</li>
<li>封装潜在变更</li>

</ol>
</li>

</ol>
<h3 id='2）为变更而设计'>（2）为变更而设计</h3>
<ol>
<li><p>封装变更/开闭原则（Open Close Principle，OCP）</p>
<ol>
<li><p>具体内容：好的设计应该对“扩展”开放对“修改”关闭。即在发生变更时，好的设计只需要添加新的代码而不需要修改原有代码就能实现变更。</p>
</li>
<li><p>选择开闭原则的原因：</p>
<ol>
<li>新增加的需求到来时，增加新的代码而不是修改已有代码是实现新增需求变更更自然的手段。</li>
<li>修改原有代码会增强其复杂度、降低其质量并可能引入新的缺陷。</li>

</ol>
</li>

</ol>
</li>
<li><p>依赖倒转原则（Dependency Inversion Principle，DIP）</p>
<ol>
<li><p>由于类之间的耦合是具有方向性的，因此需要依赖倒转原则控制耦合的方向性。</p>
</li>
<li><p>具体内容：</p>
<ol>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
<li>高层模块不应该依赖于低层模块。</li>

</ol>
</li>
<li><p>DIP会增加系统复杂度，因此如果某个行为不是明确不稳定的，不需要强行使用DIP。</p>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-1'>（3）习题</h3>
<ol>
<li><p>有哪此概念类能够称为设计类的原型？</p>
<p>可以称为设计类的原型的概念类包括：</p>
<ul>
<li>领域模型中的实体类：用于表示业务领域中的实际对象，如Customer、Product等。</li>
<li>控制器类：用于处理请求和控制业务流程的类，如Controller、Manager等。</li>
<li>数据访问类：用于封装对数据库或其他数据源的访问操作，如DAO(Data Access Object)类。</li>

</ul>
</li>
<li><p>封装的含义有哪些？</p>
<p>封装的含义有以下几个方面：</p>
<ul>
<li>封装数据：将数据成员私有化，通过公共的方法（getters和setters）来访问和修改数据，隐藏数据的内部细节。</li>
<li>封装行为：将类的行为（方法）封装在类的内部，通过公共的接口提供给外部调用，隐藏类的实现细节。</li>
<li>信息隐藏：封装使得类的内部细节对外部不可见，只暴露必要的接口，提高类的安全性和可维护性。</li>

</ul>
</li>
<li><p>职责抽象的法则有哪些？</p>
<p>职责抽象的法则（Single Responsibility Principle，SRP）：该原则指出一个类应该只有一个单一的责任，即一个类应该只负责完成一个功能。类的职责应该是高度内聚的，只有相关的行为应该归属于同一个类。</p>
</li>
<li><p>解释依赖倒置原则。</p>
<p>依赖倒置原则（Dependency Inversion Principle，DIP）：该原则指出高层模块不应该依赖于低层模块，而是应该依赖于抽象。即依赖关系应该是通过接口或抽象类来建立，而不是直接依赖于具体的实现类。这样可以降低模块之间的耦合，提高代码的灵活性和可维护性。</p>
</li>
<li><p>如何实现实现的重用？</p>
<p>实现的重用可以通过继承和组合来实现。继承是通过继承现有类，创建一个新的子类，从而复用父类的属性和方法。组合是将一个类作为另一个类的成员变量，从而实现功能的复用，而不是通过继承来实现。</p>
</li>
<li><p>如何实现接口的重用？</p>
<p>接口的重用可以通过接口继承来实现。一个类可以实现多个接口，从而复用接口中定义的方法，实现多个功能。接口的重用增加了类的灵活性，使得一个类可以适应不同的需求。</p>
</li>
<li><p>解释开闭原则。</p>
<p>开闭原则（Open-Closed Principle，OCP）：该原则指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即一个实体应该通过扩展来增加新的功能，而不是修改原有的代码。这样可以保持现有的代码稳定性，降低修改代码引入错误的风险，并提高系统的可维护性和可扩展性。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十六详细设计的设计模式'>十六、详细设计的设计模式</h2>
<h3 id='1）可修改性'>（1）可修改性</h3>
<ol>
<li><p>可修改性包含以下方面的质量：</p>
<ol>
<li>可修改性（对已有实现的修改）</li>
<li>可扩展性（对新的实现的扩展）</li>
<li>灵活性（对实现的动态配置）</li>

</ol>
</li>
<li><p>实现可修改性的方法：将接口与实现分离</p>
<ol>
<li>通过接口和实现该接口的类完成接口与实现的分离。</li>
<li>通过子类继承父类将父类的接口和子类的实现分离。</li>

</ol>
</li>

</ol>
<h3 id='2）设计模式'>（2）设计模式</h3>
<ol>
<li><p>设计模式的定义：Design Pattern是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</li>
<li><p>基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：<strong>名称、问题、解决方案、效果</strong>。</p>
</li>
<li><p>设计模式的别名是什么，记住英文名</p>
</li>
<li><p>设计模式的分类：</p>
<ol>
<li><p>根据模式的目的（模式用来干什么），可以分成：</p>
<ol>
<li>创建性（Creational）：主要用于创建对象</li>
<li>结构型（Structural）：处理类或对象的组合</li>
<li>行为型（Behavioral）：描述对类或对象怎样交互和怎样分配职责</li>
<li>分类决定了设计模式能不能联合使用</li>

</ol>
</li>
<li><p>根据范围（模式用于处理类之间的关系还是处理对象之间的关系），分成：</p>
<ol>
<li>类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被建立下来，属于<strong>静态</strong>的</li>
<li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具动态性</li>

</ol>
</li>
<li><figure><table>
<thead>
<tr><th style='text-align:left;' >范围/目的</th><th style='text-align:left;' >创建型模式</th><th style='text-align:left;' >结构型模式</th><th style='text-align:left;' >行为型模式</th></tr></thead>
<tbody><tr><td style='text-align:left;' >类模式</td><td style='text-align:left;' >工厂方法模式</td><td style='text-align:left;' >（类）适配器模式</td><td style='text-align:left;' >模版方法模式</td></tr><tr><td style='text-align:left;' >对象模式</td><td style='text-align:left;' >抽象工厂模式</td><td style='text-align:left;' >（对象）适配器模式<br>组合模式<br>装饰模式<br>外观模式<br>代理模式</td><td style='text-align:left;' >命令模式<br>中介者模式<br>观察者模式<br>状态模式<br>策略模式</td></tr></tbody>
</table></figure>
</li>

</ol>
</li>
<li><p>策略模式</p>
<ol>
<li><h5 id='在策略模式中定义了一系列算法将每一个算法封装起来并让它们可以相互替换'>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。</h5>
</li>
<li><p>前提条件：可以对算法进行封装，将算法的责任和算法本身分割开，委派给不同的对象管理。</p>
</li>
<li><p>效果：策略模式让算法独立于使用它的客户而变化，也称为<strong>政策模式</strong>。</p>
</li>
<li><p>使用的设计原则：</p>
<ol>
<li>减少耦合：减少策略的使用类和策略的实现类直接的耦合。</li>
<li>依赖倒置：策略的使用类依赖的是策略的接口而非策略的实现类。</li>

</ol>
</li>
<li><p>解法：</p>
<ol>
<li><p>把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</p>
</li>
<li><p>策略模式的三个角色：</p>
<ol>
<li>上下文类：在解决某个问题时可以采用多种策略，在上下文类中维护一个对抽象策略类的引用实例，上下文类包涵策略类，和策略类是组合关系。</li>
<li>抽象策略类：为所支持的算法声明了抽象方法，是所有策略类的父类。</li>
<li>策略类：实现了在抽象策略类中定义的算法。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.35.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.35.49"></p>
</li>

</ol>
</li>
<li><p>优点：对“开闭原则”的完美支持，可以在不修改原本代码的情况下更换或添加算法，提高代码复用率，是一种替换继承。</p>
</li>
<li><p>缺点：客户端必须知道所有的策略类并理解其区别，一定程度上增加了系统中类的个数，可能会存在很多策略类。增加隔阂、方法调用，降低软件运行的效率。（<strong>这两个是大部分模式的通用缺点</strong>）</p>
</li>
<li><p>效果：生成子类化的替代方法和策略消除条件语句。</p>
</li>
<li><p>适用场景：</p>
<ol>
<li>在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>避免使用难以维护的多重条件选择语句。</li>
<li>希望在具体策略类中封装算法和与相关的数据结构。</li>

</ol>
</li>
<li><p>模式实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.36.42.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.36.42"></p>
</li>

</ol>
</li>
<li><p>工厂方法模式（Factory Pattern）——针对Simple Factory的改进</p>
<ol>
<li><p>问题描述：简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这<strong>违背了“开闭原则”</strong>。这也导致工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重<strong>影响了系统的灵活性和扩展性</strong>。</p>
</li>
<li><p>前提条件：和简单工厂类似。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>让工厂父类负责创建产品对象的公共接口，工厂子类负责生产具体的产品对象。</p>
</li>
<li><p>四个角色：</p>
<ol>
<li>抽象产品：定义产品的接口。</li>
<li>具体产品：实现了抽象产品接口，某种具体类型的产品有专门的具体工厂建造，之间一一对应。</li>
<li>抽象工厂：声明了具体的工厂方法。</li>
<li>具体工厂：抽象工厂的子类，实现了抽象工厂中定义的工厂方法，有客户调用返回一个具体产品类的实例。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.38.23.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.38.23"></p>
</li>

</ol>
</li>
<li><p>效果：保持了简单工厂的优点，并克服了缺点，可以在允许系统不修改工厂角色情况下引进新产品。</p>
</li>
<li><p>优点：增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性，符合开闭原则。</p>
</li>
<li><p>缺点：为了实现可扩展性引入了抽象层，增加了系统的抽象性和理解难度。</p>
</li>
<li><p>适用场景：</p>
<ol>
<li>一个类不知道它所需要的对象的类。</li>
<li>一个类通过其子类来指定创建哪个对象。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li>

</ol>
</li>

</ol>
</li>
<li><p>抽象工厂模式（Abstract Factory）——<strong>Kit模式</strong></p>
<ol>
<li><p>问题描述：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>前提条件：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>使用的设计原则：</p>
<ol>
<li>职责抽象：抽象对于对象创建的职责。</li>
<li>接口的重用：提供对于对象创建的接口。</li>

</ol>
</li>
<li><p>解法：</p>
<ol>
<li><p>提供一个创建一系列相关或互相依赖对象的接口，而无需制定他们具体的类。</p>
</li>
<li><p>四个角色</p>
<ol>
<li>抽象工厂：声明了生成抽象产品的方法。</li>
<li>具体工厂：实现抽象工厂声明的生成抽象产品的方法。</li>
<li>抽象产品：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。</li>
<li>具体产品：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.39.21.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.39.21"></p>
</li>

</ol>
</li>
<li><p>优点：</p>
<ol>
<li>隔离了具体类的生成，客户不需要知道什么被创建；</li>
<li>可以通过修改具体工厂类实现修改，增加和替换产品族方便，以实现高内聚低耦合的设计目的。</li>

</ol>
</li>
<li><p>缺点：难以增加新的产品等级结构，抽象工厂中定义了所有的抽象产品，增加产品需要修改抽象工厂和其子类。</p>
</li>
<li><p>适用场景：</p>
<ol>
<li>希望系统不依赖于产品类实例如何被创建、组合和表达的细节。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.41.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.41.04"></p>
</li>

</ol>
</li>
<li><p>单件模式</p>
<ol>
<li><p>问题描述：对于某个类，希望在内存中只有一个对象存在，每次想得到这个类的对象的引用时，都指向这个唯一的对象。无论创建多少次这个类的对象，都只创建了一个对象。</p>
</li>
<li><p>前提条件：让类的构造方法变为私有，只能通过静态的get Instance方法获得对象的引用。</p>
</li>
<li><p>使用的设计原则：</p>
<ol>
<li>职责抽象：隐藏单件创建的实现</li>

</ol>
</li>
<li><p>解法：</p>
<ol>
<li><p>让类的构造方法变为私有的，然后只能通过静态的getlnstance方法获得Singleton类型的对象的引用。这要求类的成员变量中拥有一个静态的Singleton类型的引用变量uniaueInstance。getinstance方法返回引用变量uniqueInstance，如果uniqueInstance等于null，则说明首次创建，通过关键字new创建Singleton对象，并且将该对象的引用变量赋值给uniqueInstance；否则说明不是首次创建，每次只需要返回己创建的对象的引用uniqueInstance即可。</p>
</li>
<li><p>两个角色：</p>
<ol>
<li>单件：提供访问单件的接口，并实现单件。</li>
<li>客户：使用单件。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.49.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.49.49"></p>
</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol>
<li>某个类只有一个实例，并作为客户公共的访问点。</li>
<li>当单一实现需要被继承，客户能用一个子类的实例，而不需要修改他的代码。</li>

</ol>
</li>
<li><p>优点：</p>
<ol>
<li>避免使用局部变量。</li>
<li>节约系统资源，提⾼高系统效率。</li>
<li>继承之后的类，可以在配置某个应用时使用。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>单例的职责过重，难以扩展。</li>
<li>从Singleton类派生出的类并不是Singleton。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.07.41.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.07.41"></p>
</li>

</ol>
</li>
<li><p>迭代器模式</p>
<ol>
<li><p>问题描述：希望依次访问某个聚合结构，而不希望知道是什么聚合结构。</p>
</li>
<li><p>前提条件：提供一种⽅法顺序访问⼀个聚合对象中的各个元素，⽽不是暴露其内部的表示。</p>
</li>
<li><p>使用的设计原则：</p>
<ol>
<li>减少耦合：减少遍历的使用类和遍历的实现类直接的耦合。</li>
<li>依赖倒置：遍历的使用类依赖的是策略的接口，而非遍历的实现类。</li>

</ol>
</li>
<li><p>解法</p>
<ol>
<li><p>四个角色：</p>
<ol>
<li>迭代器角色(Iterator)：定义遍历元素所需要的⽅法。</li>
<li>具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。</li>
<li>容器角色（Aggregate）：一般是⼀个接口，提供一个iterator()⽅法。</li>
<li>具体容器角色（ConcreteAggregate）：抽象容器的具体实现类。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.13.18.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.13.18"></p>
</li>

</ol>
</li>
<li><p>优点：</p>
<ol>
<li>支持以不同的方式遍历一个聚合。</li>
<li>简化了了遍历⽅方式</li>
<li>简化了聚合的接口。</li>
<li>在同一个聚合上可以有多个遍历。</li>
<li>封装性好。</li>

</ol>
</li>
<li><p>缺点：对于⽐较简单的遍历(像数组或者有序列表)，使⽤迭代器方式遍历较为繁琐。</p>
</li>
<li><p>适用场景：</p>
<ol>
<li>访问一个聚合对象而不需要保留它的内部实现。</li>
<li>支持对聚合对象的多种遍历。</li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.15.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.15.39"></p>
</li>

</ol>
</li>
<li><p>设计原则</p>
<ol>
<li><p>设计原则的目的：支持可维护的复用，即在支持可维护性的同时，需要提高系统的可复用性。</p>
</li>
<li><p>目标：</p>
<ol>
<li>开闭原则（Open Closed Principle）：要求一个软件实体应该对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li>

</ol>
</li>
<li><p>指导：</p>
<ol>
<li>最小知识原则（The Least Knowledge Principle，又叫作迪米特法则（Law of Demeter）：一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话。英文简写为: LOD。</li>

</ol>
</li>
<li><p>基础：</p>
<ol>
<li>单一职责原则（Single responsibility principle）：要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li>
<li>可变性封装原则：</li>

</ol>
</li>
<li><p>实现：</p>
<ol>
<li>依赖倒转原则（Dependence Inversion Principle）：要求抽象不应该依赖于细节而细节应该依赖于抽象，要针对接口编程不是针对实现编程。</li>
<li>合成复用原则（Composite Reuse Principle）：要求复用时尽量使用对象组合，而不使用继承。</li>
<li>里氏代换原则（Liskov Substitution Principle）：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li>
<li>接口隔离原则（Interface Segregation Principle）：要求客户端不应该依赖于那些他不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li>

</ol>
</li>
<li><p>原则之间的关系（目的都是开闭原则）</p>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/00d94dd65745dd6ce1d9c79640e753aa.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-2'>（3）习题</h3>
<ol>
<li><p>什么是可修改性、可扩展性、灵活性？</p>
<ul>
<li>可修改性：指软件设计应该容易被修改，即当需要对系统进行修改或添加新功能时，应该能够在不影响原有代码稳定性的情况下进行修改。</li>
<li>可扩展性：指软件设计应该容易扩展，即当需要增加新的功能或模块时，应该能够通过扩展而不是修改来实现。</li>
<li>灵活性：指软件设计应该具有足够的灵活性，即能够适应未来的变化和需求，而不需要进行大规模的修改。</li>

</ul>
</li>
<li><p>如何实现可修改性、可扩展性、灵活性？</p>
<ul>
<li>遵循设计原则：如开闭原则、单一职责原则、依赖倒置原则等，这些原则可以指导设计，使得代码更容易修改和扩展。</li>
<li>使用设计模式：如策略模式、抽象工厂模式、单例模式等，这些设计模式可以提供灵活性和扩展性，使得系统可以适应不同的需求和变化。</li>

</ul>
</li>
<li><p>解释策略模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释抽象工厂模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释单件模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释迭代器模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
<p>&nbsp;</p>
</li>

</ol>
</body>
</html>