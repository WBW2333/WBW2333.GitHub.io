<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软工-第六部分-软件过程模型与职业基础</title>
</head>
<body><h1 id='软工-第六部分-软件过程模型与职业基础'>软工-第六部分-软件过程模型与职业基础</h1>
<h2 id='二十二软件开发过程模型'>二十二、软件开发过程模型</h2>
<h3 id='1）软件开发的典型阶段'>（1）软件开发的典型阶段</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.41.28.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.41.28"></p>
<p>明确各个阶段的目标、关注点、任务（子活动）、方法等。</p>
<h3 id='2）软件生命周期模型'>（2）软件生命周期模型</h3>
<ol>
<li>将软件从生产到报废的生命周期分割为不同阶段，每个阶段有明确的典型输入/输出、主要活动和执行人，各个阶段形成明确、连续的顺序过程，这些阶段划分称为软件生命周期模型。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.04.13.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.04.13"></li>
<li>软件生命周期模型描述了新的软件系统应该如何开发，知道软件开发活动应该按照什么顺序组织和执行。</li>

</ol>
<h3 id='3）软件过程模型'>（3）软件过程模型</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.07.22.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.07.22"></p>
<h3 id='4）构建-修复模型build-fix-model）'>（4）构建-修复模型（Build-Fix model）</h3>
<ol>
<li><p>BF模型是最自然的软件开发模型，但是并不是一个软件过程模型，因为对软件开发活动没有规划和组织，是完全依靠开发人员个人能力的开发方式。</p>
</li>
<li><p>BF模型中，开发人员在开始生产软件时，依靠个人分析和理解直接构建软件的第一个版本，并提交给用户使用。经常在提交后会发现缺陷，开发人员就修复缺陷。把发现的缺陷都修复之后，进入维护阶段。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.10.11.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.10.11"></p>
</li>
<li><p>特点：没有考虑最基本的生命周期，没有对需求真实性、设计结构质量，代码组织质量、质量保障等软件开发的复杂因素进行关注点分解处理。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>没有对开发工作进行规范和组织。</li>
<li>没有分析需求的真实性。</li>
<li>没有考虑软件结构的质量。</li>
<li>没有考虑测试和程序的可维护性，也没有文档，维护困难。</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol>
<li>软件规模很小。</li>
<li>软件对质量要求不高。</li>
<li>只关注开发活动，对后期维护要求不高。</li>

</ol>
</li>

</ol>
<h3 id='5）瀑布模型'>（5）瀑布模型</h3>
<ol>
<li><p>瀑布模型按照软件生命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付和软件维护等基本活动，并规定了自上而下、相互衔接的次序，按照“从一个阶段到另一个阶段的有序转换序列”的方式组织开发活动。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.14.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.14.00"></p>
</li>
<li><p><em>瀑布模型是允许活动出现反复和迭代的，严格线性顺序不是瀑布模型的主要特点。</em></p>
</li>
<li><p>瀑布模型的重点是要求每个活动的结果必须进行验证，只有进行验证之后才能作为后续开发活动的基础。这要求瀑布模型特别重视模型与文档，因此瀑布模型被看作是“文档驱动”，即按照文档的划分、产生和验证来规划、组织和控制开发活动。</p>
</li>
<li><p>优势（相比BF模型）：为软件开发活动定义了清晰的阶段划分，让开发者能够专注于单独的活动。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>对文档的过高期望</li>
<li>对开发活动的线性顺序假设</li>
<li>客户、用户参与不够</li>
<li>里程碑粒度过粗</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol>
<li>需求非常成熟、稳定</li>
<li>所需技术成熟、可靠</li>
<li>复杂度适中</li>

</ol>
</li>

</ol>
<h3 id='6）增量迭代模型'>（6）增量迭代模型</h3>
<ol>
<li><p>随着周期过长、渐进交付、时间压力和并行开发的挑战，促使了增量迭代模型的产生和普及。</p>
</li>
<li><p>增迭模型在项目开始时，通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，然后再将后续开发活动组织为多个迭代、并行的瀑布式开发活动。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.20.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.20.38"></p>
</li>
<li><p>增迭模型在项目早起就确定项目的目标和范围，因此需要项目的需求比较成熟和稳定。</p>
</li>
<li><p>优点：</p>
<ol>
<li>更符合软件开发的实践情况，有更好的实适用性</li>
<li>并行开发可以帮助缩短软件产品的开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>

</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>加入构架不能破坏已构造的部分</li>
<li>需要完备、清晰的项目前景和范围</li>

</ol>
</li>
<li><p>适用范围：在实践中都有广泛的应用，尤其是相对成熟稳定的领域。</p>
</li>

</ol>
<h3 id='7）演化模型'>（7）演化模型</h3>
<ol>
<li><p>演化模型相比增迭模型更适合需求变更频繁或不确定性较多的领域。</p>
</li>
<li><p>演化模型将软件开发活动组织为多个迭代、并行的瀑布式开发活动。在初始迭代中需要澄清和明确核心需求，建立和交付核心系统。之后用户在使用中发现和变更需求、澄清不确定需求，并反馈给开发者进行后续迭代，精化和增强系统。每次迭代的需求不是独立的，设计和实现都是在前代的基础上修改和扩展。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.28.56.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.28.56"></p>
</li>
<li><p>演化模型也是“需求驱动”的。</p>
</li>
<li><p>优点：</p>
<ol>
<li>使用了迭代式开发，具有更好的适用性</li>
<li>并行开发可以缩短开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>

</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>无法在项目早期确定项目范围</li>
<li>后续迭代容易变成BF模式</li>

</ol>
</li>

</ol>
<h3 id='8）原型模型'>（8）原型模型</h3>
<ol>
<li><p>演化式原型：原型产生于真正产品构建之前，被扩展后成为真正的产品。</p>
</li>
<li><p>抛弃式原型：模拟真正产品但不会出现在真正产品中，在真正产品中出现的是比原型质量更好的改进和替代。</p>
</li>
<li><p>原型模型注重使用抛弃式模型，因此适合不确定性较多的软件开发，充分利用抛弃式原型解决新颖领域的需求不确定问题，在抛弃式原型的帮助下解决不确定性，再按照瀑布模型安排后续开发活动。可以通过多次原型开发迭代得到所有清晰需求，也可以安排整体迭代。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.36.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.36.39"></p>
</li>
<li><p>原型模型可以是需求驱动也可以是风险驱动的。</p>
</li>
<li><p>优点：</p>
<ol>
<li>演化模型的优点</li>
<li>强化了与客户、用户的交流，产品有更好的满意度</li>
<li>适用于新颖的领域</li>

</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>演化模型的缺点</li>
<li>原型能够解决风险，但是自身也会带来风险，如原型成本过高等</li>
<li>实践中很多人不舍得抛弃原型，使得质量较差的代码进入了产品导致产品的低质量。</li>

</ol>
</li>

</ol>
<h3 id='9）螺旋模型'>（9）螺旋模型</h3>
<ol>
<li><p>螺旋模型的基本思想是尽早解决比较高的风险，是风险驱动的，完全按照风险解决的方式组织软件开发。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.52.15.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.52.15"></p>
</li>
<li><p>螺旋模型使用原型解决项目开发中的风险，有四次由内而外的风险解决迭代，分别解决软件开发中风险较高的几个阶段：</p>
<ol>
<li>解决系统需求开发的风险</li>
<li>解决软件需求开发的风险</li>
<li>解决软件体系结构设计中的技术风险</li>
<li>解决详细设计和实现中的关键技术风险</li>

</ol>
</li>
<li><p>螺旋模型的4次迭代和第4次迭代右下象限的活动一起构成了瀑布模型，因此螺旋模型是风险解决迭代和瀑布模型的综合。</p>
</li>
<li><p>优点：降低风险，减少项目因风险造成的损失。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>风险解决需要原型，原型自身也有风险</li>
<li>模型过于复杂，不利于管理者组织软件开发活动</li>

</ol>
</li>
<li><p>适用场景：高风险的大规模软件系统开发。</p>
</li>

</ol>
<h3 id='10）rational统一过程'>（10）Rational统一过程</h3>
<ol>
<li><p>Rational公司提出统一过程（Rational Unified Process，RUP），RUP总结和借鉴传统的各种经验，建立最佳实践方法的集合，并提供有效的过程定制手段。</p>
</li>
<li><p>RUP用二维坐标来描述：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8B%E5%8D%881.48.25.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 下午1.48.25"></p>
<ol>
<li>纵轴以内容来组织，是自然的逻辑活动，体现开发过程的静态结构。</li>
<li>横轴以时间来组织，是过程展开的生命周期特征，体现开发过程的动态结构。</li>

</ol>
</li>
<li><p>RUP将生命周期定义为四个阶段，在每个生命周期都可以安排多次迭代：</p>
<ol>
<li>初始阶段：定义项目前景、范围和业务用例。</li>
<li>细化阶段：设计软件体系结构、构建核心体系结构原型。</li>
<li>构造阶段：完成软件系统的详细设计和实现。</li>
<li>交付阶段：将软件产品交付给用户。</li>

</ol>
</li>
<li><p>RUP6个核心实践方法：</p>
<ol>
<li>迭代式开发</li>
<li>管理需求</li>
<li>基于组件的体系结构</li>
<li>可视化建模</li>
<li>验证软件质量</li>
<li>控制软件变更</li>

</ol>
</li>
<li><p>RUP是一个通用模版，因此要对RUP按以下步骤进行裁剪和配置：</p>
<ol>
<li>确定本项目需要哪些工作流</li>
<li>确定每个工作流需要哪些制品</li>
<li>确定4个阶段之间如何演进</li>
<li>确定每个阶段内的迭代计划</li>
<li>规划工作流的组织</li>

</ol>
</li>
<li><p>优点：</p>
<ol>
<li>吸收和借鉴了传统的最佳实践方法</li>
<li>RUP根据定制机制的不同可以适合小型项目和大型项目，适用面广泛。</li>
<li>RUP有一套软件工程工具的支持，帮助RUP有效实施。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>没有考虑交付之后的软件维护问题</li>
<li>裁剪和配置工作难度大，不能保证每个项目都能有效定制。</li>

</ol>
</li>
<li><p>适用场景：大型项目和小型项目皆可。</p>
</li>

</ol>
<h3 id='11）敏捷过程'>（11）敏捷过程</h3>
<ol>
<li><p>敏捷方法是为了针对用户价值不在首位、项目开发不够灵活的问题提出的轻量级方法。</p>
</li>
<li><p>敏捷思想：</p>
<ol>
<li>个体和互动高于流程和工具</li>
<li>工作的软件高于详尽的文档</li>
<li>客户合作高于合同谈判</li>
<li>相应变化高于遵循计划</li>

</ol>
</li>
<li><p>适用场景：快速变化或时间压力大的项目。</p>
</li>

</ol>
<h3 id='12）习题'>（12）习题</h3>
<ol>
<li><p>如何理解软件生命周期模型？为什么在开发一个大型软件产品时遵循一个生命周期模型很重要？</p>
<p>软件生命周期模型是描述软件从开始开发直到终止使用的整个过程，包括需求分析、设计、编码、测试、部署、维护等阶段。</p>
<p>遵循一个生命周期模型对于开发大型软件产品很重要，因为它提供了一种有组织的、系统化的方法来管理和控制软件开发过程，帮助项目团队更好地规划和实施各个阶段的活动，降低项目失败的风险，提高软件开发的效率和质量。</p>
</li>
<li><p>软件生命周期模型与软件开发过程模型有哪些区别与联系？</p>
<p>软件生命周期模型和软件开发过程模型是相关但不同的概念。软件生命周期模型描述了软件从开始到结束的整个演化过程，包括各个阶段的活动和交付物；而软件开发过程模型是对软件开发过程的组织和管理方式的抽象描述，它是实现软件生命周期的具体方法。软件开发过程模型包括瀑布模型、增量模型、原型模型、螺旋模型、迭代模型等，它们是具体的开发方法，用来实现软件生命周期模型中的各个阶段。</p>
</li>
<li><p>如果一个项目在开发时没有遵循任何系统的过程，可能会发生哪些问题？</p>
<p>如果一个项目在开发时没有遵循任何系统的过程，可能会发生诸如以下问题：</p>
<ul>
<li>缺乏组织性和规划，项目进度不可控，容易出现延期和超出预算的情况。</li>
<li>难以明确需求和目标，导致软件功能不符合用户期望，造成客户满意度低下。</li>
<li>缺乏测试和验证过程，软件质量无法保障，容易出现严重的Bug和错误。</li>
<li>缺乏文档和记录，对项目的维护和后续发展带来困难。</li>

</ul>
</li>
<li><p>为什么抛弃式原型必须被拋弃？</p>
<p>抛弃式原型必须被抛弃是因为它通常是为了快速验证或演示概念而构建的，而不是为了成为最终产品。抛弃式原型是为了帮助开发人员和用户更好地理解需求和功能，它通常不具备高质量、高可靠性和高性能。一旦验证或演示的目的达到，抛弃式原型应该被废弃，然后基于这些验证结果，进行正式的软件开发。</p>
</li>
<li><p>螺旋模型使用风险驱动的方式有哪些好处？</p>
<p>螺旋模型使用风险驱动的方式有以下好处：</p>
<ul>
<li>可以在每个迭代周期中评估和处理项目的风险，及时调整开发计划和控制措施，降低项目失败的风险。</li>
<li>随着项目的不断演化，风险评估可以帮助确定项目的重点和优先级，确保项目资源的有效分配。</li>
<li>风险驱动的方式促使项目团队更加关注风险因素，提高了项目团队的风险意识和应对能力。</li>

</ul>
</li>
<li><p>RUP 过程同时提供动态结构和静态结构的优点是什么？</p>
<p>RUP同时提供动态结构和静态结构的优点在于可以全面覆盖软件开发的各个方面。动态结构指的是关注软件开发过程中的活动、任务、阶段等动态变化的部分，如需求分析、设计、编码、测试等；静态结构指的是关注软件开发中的文档、模型、工件等静态的产物，如需求规格说明、UML图、代码等。通过同时提供动态结构和静态结构，RUP过程可以帮助团队全面理解和管理软件开发的各个方面，提高项目的可控性和质量。</p>
</li>
<li><p>你认为什么情况下不应该使用敏捷过程方法？</p>
<p>敏捷过程方法在以下情况下可能不适用：</p>
<ul>
<li>项目需求明确且稳定，不需要频繁的需求变更和灵活的迭代开发。</li>
<li>开发团队规模较大且分散，沟通和协作困难。</li>
<li>项目要求强调详细的文档和规范，敏捷方法强调简洁和实际。</li>

</ul>
</li>
<li><p>哪些模型可以适用于需求变化频繁项目的开发？为什么？</p>
<p>适用于需求变化频繁项目的开发模型包括增量模型、迭代模型和螺旋模型。因为这些模型都支持分阶段的开发过程，可以在每个阶段进行需求变更和逐步完善。</p>
</li>
<li><p>哪些模型不适用于大型软件系统的开发？为什么？</p>
<p>不适用于大型软件系统的开发的模型包括原型模型和瀑布模型。原型模型适用于需求不明确或需要快速验证的小规模项目，瀑布模型对于大型复杂项目的需求变化和迭代开发不够灵活。</p>
</li>
<li><p>哪些模型的用户参与度会更高一些？为什么？</p>
<p>模型的用户参与度会更高的有敏捷模型和原型模型。敏捷模型强调与客户的持续交互和反馈，原型模型要求用户参与原型的设计和验证过程。</p>
</li>
<li><p>为下列系统提出合适的软件过程模型，并解释你的理由：</p>
<ol>
<li>充分了解的数据处理应用程序；</li>
<li>卫星通信软件，假设之首没有卫星通信软件的开发经验：</li>
<li>超大型的软件，基于卫星通信、监控移动电话通信；</li>
<li>一个新的文本编辑器；</li>
<li>大学记账系统，准备替换一个已有的系统；</li>
<li>大型软件产品的图形用户界面。</li>

</ol>
<p>解答：</p>
<ol>
<li>充分了解的数据处理应用程序：适用于瀑布模型，因为需求较为稳定且清晰，适合一次性完整开发。</li>
<li>卫星通信软件，假设之首没有卫星通信软件的开发经验：适用于增量模型，可以分阶段开发，每个阶段逐步完善功能和解决问题。</li>
<li>超大型的软件，基于卫星通信、监控移动电话通信：适用于螺旋模型，风险较高，需要不断评估和调整开发计划。</li>
<li>一个新的文本编辑器：适用于原型模型，因为需要快速验证功能和界面，用户参与度较高。</li>
<li>大学记账系统，准备替换一个已有的系统：适用于增量模型，可以逐步替换旧系统的功能，降低风险。</li>
<li>大型软件产品的图形用户界面：适用于迭代模型，界面需要不断迭代优化和改进，可以在每个迭代周期中完善界面。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十三软件工程职业基础'>二十三、软件工程职业基础</h2>
<h3 id='1）软件工程师'>（1）软件工程师</h3>
<p>软件工程师的职业素质要求：</p>
<ol>
<li>团队工作能力</li>
<li>交流沟通能力</li>
<li>遵守职业的道德标准和操行规范</li>
<li>积极参与行业协会活动，遵守行业标准，推进行业发展</li>
<li>了解软件工程对社会、经济、法律等相关领域的影响、问题和观点</li>

</ol>
<h3 id='2）软件工程职业概况'>（2）软件工程职业概况</h3>
<ol>
<li><p>软件工程10个知识域：</p>
<ol>
<li>软件需求</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件维护</li>
<li>软件配置管理</li>
<li>软件工程管理</li>
<li>软件工程过程</li>
<li>软件工程工具和方法</li>
<li>软件质量</li>

</ol>
</li>
<li><p>新增的5个知识域：</p>
<ol>
<li>软件工程职业实践</li>
<li>工程经济学基础</li>
<li>计算基础</li>
<li>数学基础</li>
<li>工程基础</li>

</ol>
</li>

</ol>
<h3 id='3）习题'>（3）习题</h3>
<ol>
<li><p>除了软件开发技能之外，软件工程师还需要具备哪些职业素质？</p>
<p>除了软件开发技能，软件工程师还需要具备以下职业素质：</p>
<ol>
<li>分析与解决问题能力：能够快速分析和解决复杂问题，找到合理的解决方案。</li>
<li>沟通与协作能力：能够与团队成员、用户和其他相关方进行有效沟通，良好的协作能力有助于项目的顺利进行。</li>
<li>学习与创新能力：软件行业不断发展变化，软件工程师需要不断学习新技术和方法，并具备创新精神。</li>
<li>时间管理与自我管理能力：能够合理安排工作时间，高效地完成任务。</li>
<li>责任心与团队合作精神：对项目负责，能够承担责任，愿意与团队共同合作达成共同目标。</li>

</ol>
</li>
<li><p>判断一个职业出现有哪此方面的条件？软件工程目前表现如何？</p>
<p>判断一个职业是否具备一定的方面条件，通常可以从以下几个方面来考虑：</p>
<ol>
<li>行业需求：是否存在足够的就业机会和发展空间。</li>
<li>薪酬水平：行业内的薪酬待遇是否具有吸引力。</li>
<li>工作环境：职业是否提供相对稳定和舒适的工作环境。</li>
<li>技能需求：是否需要具备一定的专业技能和知识。</li>
<li>发展前景：职业的发展前景是否乐观。</li>

</ol>
<p>目前，软件工程行业在大多数地区表现良好，因为数字化转型和互联网的快速发展使得软件需求持续增长，软件工程师的需求也在增加。</p>
</li>
<li><p>为什么软件工程师要注重专业道德？</p>
<p>软件工程师要注重专业道德，因为软件工程涉及到的是人们生活中的重要信息和数据，如果不遵循专业道德准则，可能导致数据泄露、隐私侵犯等问题，对用户造成损失和影响信任。</p>
</li>
<li><p>为什么软件工程师要进行认证？</p>
<p>软件工程师进行认证是为了证明其具备一定的专业知识和技能，可以胜任相应的工作岗位。认证能够增加软件工程师的竞争力，有助于找到更好的工作机会和提升薪酬水平。同时，认证还可以帮助软件工程师不断学习和提高自己的技能，保持在行业内的竞争优势。</p>
</li>

</ol>
<p>&nbsp;</p>
</body>
</html>