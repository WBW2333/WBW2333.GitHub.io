<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>计网-05-传输层</title>
</head>
<body><h1 id='计网-05-传输层'>计网-05-传输层</h1>
<h2 id='一传输层概述'>一、传输层概述</h2>
<h3 id='1）传输层的功能'>（1）传输层的功能</h3>
<ol>
<li><p>传输层是主机才有的层次，是面向通信部分的最高层，为应用层提供通信服务，使用网络层的服务。</p>
</li>
<li><p>传输层的功能</p>
<ol>
<li>传输层提供进程和进程之间的逻辑通信。</li>
<li>复用和分用：复用指发送方的不同进程都可以使用同一个传输层协议，分用指传输层能够把数据交付给正确的进程。</li>
<li>对收到的报文进行差错检测（首部和数据，网络层只检测IP数据报的首部，不检测数据部分）。</li>
<li>提供两种不同的传输协议：面向连接的TCP和无连接的UDP。</li>

</ol>
</li>

</ol>
<h3 id='2）传输层的寻址和端口'>（2）传输层的寻址和端口</h3>
<ol>
<li><p>端口：传输层服务访问点（TSAP），他在传输层的作用类似于IP地址在网络层的作用，标识各个进程。</p>
</li>
<li><p>端口号：</p>
<ol>
<li><p>应用程序通过端口号进行标识，端口号长度为16bit，能表示65536个不同的端口号。</p>
</li>
<li><p>端口号只有本地意义，不同计算机的端口号无论是否相同之间都没有关联。</p>
</li>
<li><p>根据端口号的范围可将端口分为两类</p>
<ol>
<li><p>服务端使用的端口号，其中又分为两类。</p>
<ol>
<li>熟知端口号：数值为0～1023，被指派给TCP/IP最重要的一些进程，让所有用户都知道。</li>
<li>登记端口号：数值为1023～49151，供没有熟知端口号的进程使用的，使用这类端口号必须要在IANA登记。</li>
<li>一些熟知端口号：<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8A%E5%8D%889.33.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 上午9.33.08"></li>

</ol>
</li>
<li><p>客户端使用的端口号：数值为49152～65535，这类端口号仅在客户进程运行时才动态的选择，因此又称临时端口，通信结束后端口号的使用就撤销。</p>
</li>

</ol>
</li>

</ol>
</li>
<li><p>套接字Socket：</p>
<ol>
<li>端口号拼接到IP地址就构成套接字Socket，在网络中用发送方和接收方的套接字来识别端点。</li>
<li>套接字实际上就是一个通信端点：套接字Socket=（IP地址：端口号），套接字唯一地标识一台主机上的一个进程。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二udp'>二、UDP</h2>
<h3 id='1）udp概述'>（1）UDP概述</h3>
<ol>
<li><p>UDP仅在IP数据报服务之上增加了两个最基本的服务：复用分用和差错检测。</p>
</li>
<li><p>UDP的优点</p>
<ol>
<li>UDP无需建立连接：UDP不会引入建立连接的时延，速度快。</li>
<li>无连接状态：UDP无需维护连接状态，使用UDP的服务器能支持更多的活动客户机。</li>
<li>分组首部开销小：UDP首部8B，TCP首部20B。</li>
<li>UDP没有拥塞控制：应用层能更好的控制发送数据和发送数据，拥塞不会影响效率，适合实时应用（少量拥塞导致的错误完全可以接受）。</li>
<li>UDP支持一对一、一对多、多对多的交互通信。</li>
<li>UDP不保证可靠交付：维护可靠性的工作可在应用层完成。</li>
<li>UDP面向报文，适合一次性传输较少数据的网络应用。</li>

</ol>
</li>
<li><p>UDP首部格式<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8A%E5%8D%889.51.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 上午9.51.29"></p>
<ol>
<li>UDP数据报包括首部和用户数据，首部有8B。</li>
<li>源端口：源端口号，在需要对方回复时使用，否则可为全0。</li>
<li>目的端口：目的端口号，在终点交付报文时必须使用到。</li>
<li>长度：UDP数据报的长度（包括首部和数据），最小值是8（仅首部）。</li>
<li>校验和：检测UDP是否出错，可选，当源主机不校验时可为0。</li>

</ol>
</li>

</ol>
<h3 id='2）udp校验'>（2）UDP校验</h3>
<ol>
<li><p>伪首部：在计算校验和时临时添加在UDP的首部，构成一个临时的UDP数据报。伪首部占12B，只是用来模拟UDP数据报方便计算校验和，伪首部本身既不向下传送也不向上递交。<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8A%E5%8D%8810.04.14.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 上午10.04.14"></p>
</li>
<li><p>UDP校验和和IP数据报首部校验和类似，但是IP数据报只检验首部而UDP检验首部和数据。</p>
</li>
<li><p>检验方法：<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8A%E5%8D%8810.07.25.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 上午10.07.25"></p>
<ol>
<li><p>在发送端：</p>
<ol>
<li>填上伪首部</li>
<li>全0填充检验和字段</li>
<li>全0填充数据部分（UDP数据报要看成许多2B的字串接起来，如果数据部分是奇数B，则要填充一个全0的B）</li>
<li>伪首部＋首部＋数据部分采用二
进制反码求和</li>
<li>把和求反码填入检验和字段</li>
<li>去掉伪首部，发送</li>

</ol>
</li>
<li><p>在接收端：</p>
<ol>
<li>填上伪首部</li>
<li>伪首部+首部＋数据部分采用二
进制反码求和</li>
<li>结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告。</li>

</ol>
</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='三tcp'>三、TCP</h2>
<h3 id='1）tcp概述'>（1）TCP概述</h3>
<ol>
<li><p>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，主要解决的传输的可靠、有序、无丢失和不重复问题。</p>
</li>
<li><p>TCP的特点</p>
<ol>
<li><p>TCP是面向连接的传输层协议。</p>
</li>
<li><p>每一条TCP协议连接只能有两个端点，TCP连接只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复、按序到达。</p>
</li>
<li><p>TCP提供全双工通信，允许通信双方的进程在任何时候都能发送数据。为此TCP连接的两端都有发送缓存和接收缓存。</p>
<ol>
<li>发送缓存：准备发送的数据&amp;己发送但尚未收到确认的数据。</li>
<li>接收缓存：按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据。</li>

</ol>
</li>
<li><p>TCP是面向字节流的，TCP把进程交付的数据看成是无结构的字节流。</p>
</li>

</ol>
</li>

</ol>
<h3 id='2）tcp报文'>（2）TCP报文</h3>
<ol>
<li><p>TCP传送的数据单元称为报文段，TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</p>
</li>
<li><p>一个TCP报文段分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中。首部的前20B固定，首部最短为20B，后面按4B为单位增加。</p>
</li>
<li><p>TCP首部：<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8A%E5%8D%8811.00.18.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 上午11.00.18"></p>
<ol>
<li><p>源端口和目的端口：各2B。</p>
</li>
<li><p>序号（seq）：占4B，共2^32个序号。TCP是面向字节流的，因此TCP传送的字节是按顺序编号的，序号代表本包文传送的数据的第一个字节的序号。</p>
</li>
<li><p>确认号（ack）：占4B，指期望收到对方下一个报文的第一个数据字节的序号，确认号为N则表示N-1都收到了。</p>
</li>
<li><p>数据偏移（即首部长度）：占4位，单位是4B，因此首部最大长度为60B。数据偏移表示的是数据的起始位距离首部起始位的距离。</p>
</li>
<li><p>保留：占6位，置为0。</p>
</li>
<li><p>紧急位URG：URG=1表示紧急指针字段有效，通知系统此报文段有紧急数据，应尽快传送。URG和首部中的紧急指针字段配合使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。</p>
</li>
<li><p>确认位ACK：当ACK=1时确认号字段有效，TCP规定连接建立后所有传送的报文段都必须把ACK置为1。</p>
</li>
<li><p>推送位PSH（Push）：接收方收到PSH=1的报文段，就应当尽快交付给接受进程，而不是等待缓存满再交付。</p>
</li>
<li><p>复位位RST（Reset）：RST=1表示TCP连接中出现严重差错，必须释放连接再重新建立运输连接。</p>
</li>
<li><p>同步位SYN：</p>
<ol>
<li>SYN=1时表示这是一个连接请求或连接接受报文。</li>
<li>SYN=1，ACK=0时表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使用 SYN=1, ACK=1。</li>

</ol>
</li>
<li><p>终止位FIN（Finish）：用来释放一个连接。FIN=1时表明此报文段的发送方的数据己发送完毕，并要求释放运输连接。</p>
</li>
<li><p>窗口：占2B，范围为0~2^16-1。它指出现在允许对方发送的数据量。接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
<li><p>校验和：占 2B，校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP
一样，要在TCP 报文段的前面加上12B的伪首部（只需将 UDP 伪首部的协议字段的17改成6，UDP长度字段改成TCP长度，其他和UDP一样)。</p>
</li>
<li><p>紧急指针：占2B。紧急指仅在URG=1时才有意义，它指出在本报文段中紧急数据共有多少字节（紧急数据在报文段数据的最前面）。</p>
</li>
<li><p>选项：长度可变，TCP最初只规定了一种选项，即最大报文段长度（Maximum Segment Size，MSS），用来规定<strong>数据字段</strong>的最大长度。</p>
</li>
<li><p>填充：填充字段使整个首部长度是4B的整数倍。</p>
</li>

</ol>
</li>

</ol>
<h3 id='3）tcp连接管理'>（3）TCP连接管理</h3>
<ol>
<li><p>TCP是面向连接的协议，每个TCP连接都有三个阶段：连接建立、数据传送和连接释放。TCP连接的管理就是使连接的建立和释放都能正常进行。</p>
</li>
<li><p>TCP连接的端点是套接字，每条TCP连接都能唯一地被通信的两个端点，即两个套接字确定。</p>
</li>
<li><p>TCP连接的建立采用客户/服务器模式，主动发起连接建立的进程称为客户，等待连接建立的称为服务器。</p>
</li>
<li><p>TCP连接建立——<em>三次握手</em><img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8B%E5%8D%882.31.11.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 下午2.31.11"></p>
<ol>
<li>第一次握手（SYN发送）：客户端向服务器发送一个带有SYN=1的连接请求报文段。这表示客户端请求建立连接，并传递客户端选择的初始序列号seq=x，无应用层数据。</li>
<li>第二次握手（SYN-ACK发送）：服务器接收到客户端的SYN报文段，<strong>服务器为TCP分配缓存和变量</strong>，会发送一个带有SYN=1，ACK=1的确认报文段作为响应。服务器也会选择自己的初始序列号seq=y，并将ack=x+1。这个报文段确认了客户端的SYN请求，并表明允许建立连接，无应用层数据。</li>
<li>第三次握手（ACK发送）：客户端收到服务器的SYN-ACK报文段后，<strong>客户端为TCP分配缓存和变量</strong>，会发送一个带有SYN=0，ACK=1的TCP报文段作为最后的确认。客户端的seq=x+1，ack=y+1。这个ACK报文段告知服务器，客户端已经接收到了服务器的确认，可以携带数据。</li>
<li>需要注意到，服务器的资源是在第二次握手时分配的，而客户端的资源是在第三次握手时分配的，这就会导致SYN洪泛攻击。</li>
<li>SYN洪泛攻击：SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</li>
<li>可以通过SYN Cookie解决SYN洪泛攻击。</li>

</ol>
</li>
<li><p>TCP连接释放——<em>四次握手</em><img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8B%E5%8D%882.42.20.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 下午2.42.20"></p>
<ol>
<li>第一次握手（Client -&gt; Server）：客户端发送一个FIN=1，seq=u的连接释放报文段给服务器，停止发送数据，表示客户端希望关闭连接。</li>
<li>第二次握手（Server -&gt; Client）：服务器接收到客户端发送的FIN报文段后，会发送一个ACK=1，seq=v，ack=u+1的确认报文段给客户端，表示服务器已经收到了客户端的关闭请求，客户到服务器的方向的连接就释放了——半关闭状态。</li>
<li>第三次握手（Server -&gt; Client）：服务器发完数据，发送一个FIN=1，ACK=1，seq=w，ack=u+1的连接释放报文段给客户端，表示服务器也准备关闭连接。</li>
<li>第四次握手（Client -&gt; Server）：客户端接收到服务器发送的FIN标志的报文段后，发送一个ACK=1，seq=u+1，ack=w+1的确认报文段给服务器，表示客户端已经收到了服务器的关闭请求确认。<strong>再等待2MSL的最长报文段寿命后，连接彻底关闭</strong>。</li>

</ol>
</li>
<li><p>连接和释放的字段内容：<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8B%E5%8D%882.48.47.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 下午2.48.47"></p>
</li>

</ol>
<h3 id='4）tcp可靠传输'>（4）TCP可靠传输</h3>
<ol>
<li><p>TCP提供的可靠数据传输服务保证接收方进程从缓冲区读出的字节流与发送方发出的字节流完全一样，TCP通过校验、序号、确认和重传机制实现。</p>
</li>
<li><p>校验：TCP校验和UDP校验一样，略过。</p>
</li>
<li><p>序号<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-03%20%E4%B8%8B%E5%8D%883.03.40.png" referrerpolicy="no-referrer" alt="截屏2023-07-03 下午3.03.40"></p>
<ol>
<li>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP认为数据是一个无结构但有序的字节流，序号建立在传送的字节流上而不是报文段上。</li>
<li><strong>数据是给传送的字节流的每一个字节标记一个序号，一次可能会发送多个连续序号的字节</strong>。</li>
<li>如第一次发送了序号1、2、3的字节，则第一个报文的序号是0，第二个报文段的序号是4。</li>

</ol>
</li>
<li><p>确认</p>
<ol>
<li>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。如接收方收到序号为3、4、5的字段，则下一个报文段的确认号就为5。</li>
<li>发送方会储存那些已发送但未收到确认的报文段，以便在需要时重传。</li>
<li>TCP默认使用累计确认，TCP只确认数据流中至第一个丢失字节为止的字节，如接收方收到了1、2、3字节和7、8、9字节，则接收方仍在等待4、5、6字节，因此会反复发送确认号为3的报文段。</li>

</ol>
</li>
<li><p>重传</p>
<ol>
<li><p>超时和冗余ACK会导致重传</p>
</li>
<li><p>超时</p>
<ol>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。</li>
<li>为了计算超时计时器的重传时间，TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（Round-Trip Time，RTT），TCP保留了RTT的一个加权平均往返时间RTTs，它会随新测量 RTT 样本值的变化而变化。</li>
<li>显然，超时计时器设置的超时重传时间（Retransmission Time-Out, RTO）应略大于RTTS， 但也不能大太多，否则当报文段丢失时，TCP 不能很快重传，导致数据传输时延大。</li>

</ol>
</li>
<li><p>冗余ACK</p>
<ol>
<li>超时触发重传存在的一个问题是超时周期往往太长，发送方通常在超时事件发生之前通过冗余ACK来检测丢包情况。</li>
<li>冗余ACK就是多次确认某个报文段的ACK，TCP规定每当比期望序号大的失序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号。如发送方发送了1、2、3、4、5字节，其中3丢失，于是接收方就会发送多个对2号报文段的冗余ACK，表示自己期望接收2号报文段。</li>
<li>TCP 规定当发送方收到对同一个报文段的3个冗余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。这时发送方可以立即对丢失报文执行重传，这种技术通常称为快速重传。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='5）tcp流量控制'>（5）TCP流量控制</h3>
<ol>
<li>TCP提供流量控制服务来消除发送方（发送速率太快）使接收方缓存区溢出的可能性，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）。</li>
<li>TCP提供基于<strong>滑动窗口协议</strong>的流量控制机制，在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为拥塞窗口cwnd，其大小与网络的带宽和时延密切相关。</li>
<li>例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。rwnd即接收方允许连续接收的最大能力，单位是字节。发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存滥出。当然，A的发送窗口的实际大小取rwnd和cwnd中的最小值。图5.10中的例子说明了如何利用滑动窗口机制进行流量控制。设A向B发送数据，在连接建立时，B告诉A：“我的接收窗口rwnd=400”。接收方主机B进行了三次流量控制，这三个报文段都设置ACK=1，只有在ACK=1时确认号字段才有意义。第一次把窗口减小到rwnd=300，第二次又减到rwnd=100，最后减到rwnd=0，即不允许发送方再发送数据。这使得发送方暂停发送的状态将持续到B重新发出一个新的窗口值为止。<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-04%20%E4%B8%8A%E5%8D%889.20.57.png" referrerpolicy="no-referrer" alt="截屏2023-07-04 上午9.20.57"></li>
<li>为了防止接受方在发送零窗口值之后发送的窗口值丢失，导致发送方持续停滞的情况，TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段接收方收到探测报文段时给出现在的窗口值。</li>

</ol>
<h3 id='6）tcp拥塞控制'>（6）TCP拥塞控制</h3>
<ol>
<li><p>拥塞控制的目的是防止过多的数据进入网络，保证网络中的路由器和链路不会过载。</p>
</li>
<li><p>拥塞控制和流量控制的区别</p>
<ol>
<li>拥塞控制是让网络能够承受现有的网络负荷，是一个全局的过程，涉及整个网络。</li>
<li>流量控制则是指点对点的通信量的控制，是个端到端的问题。</li>

</ol>
</li>
<li><p>TCP进行拥塞控制，既要考虑接收方的接受能力，也要考虑网络的传输能力，因此要求发送方维护两个窗口：</p>
<ol>
<li>接受窗口rwnd：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。</li>
<li>拥塞窗口cwnd：发送方根据自己估算的网络拥塞程度设置的窗口值，反映网络的当前容量。</li>

</ol>
<p>发送窗口的上限=min[rwnd，cwnd]。</p>
</li>
<li><p>慢开始和拥塞避免算法</p>
<ol>
<li><p>慢开始</p>
<ol>
<li>在TCP开始时，令cwnd=1，即一个最法报文段长度MSS。每收到一个新报文段的确认信息，则增大一个MSS。</li>
<li>这样的可以逐步增长发送方的cwnd，可使分组进入网络的速率更加合理。</li>
<li>例如，A向B发送数据，发送方先置拥塞窗口cwnd=1，A发送第一个报文段，A收到B对第一个报文段的确认后，把cwnd从 1增大到2，于是A接着发送两个报文段，A收到B对这两个报文段的确认后，把cwnd从2增大到4，下次就可一次发送4个报文段。</li>
<li>使用慢开始算法后，每经过一个传输轮次（即往返时延RTT），cwnd就会翻倍，即cwnd的值会随传输轮次指数增长。</li>
<li>慢开始算法把cwnd增大到一个规定的<strong>慢开始门限ssthresh</strong>，然后改用拥塞避免算法。</li>

</ol>
</li>
<li><p>拥塞避免算法</p>
<ol>
<li><p>让拥塞窗口cwnd缓慢增大，每经过一个RTT就把cwnd+1，增长速率比慢开始算法慢很多。</p>
</li>
<li><p>当cwnd&lt;ssthresh时，使用慢开始算法；</p>
<p>当cwnd&gt;ssthresh时，使用拥塞避免算法；</p>
<p>当cwnd=ssthresh时，即可以使用慢开始算法又可以使用拥塞避免算法。</p>
</li>
<li><p>拥塞避免算法不能完全消除拥塞，只能减少发送的分组数，尽量避免拥塞。</p>
</li>

</ol>
</li>
<li><p>网络拥塞的处理<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-04%20%E4%B8%8A%E5%8D%889.52.09.png" referrerpolicy="no-referrer" alt="截屏2023-07-04 上午9.52.09"></p>
<ol>
<li>无论在慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到确认），就要把ssthresh设为出现拥塞时cwnd的一半（但不能小于2）。然后把cwnd=1，重新开始慢开始算法。</li>
<li>这样可以迅速减少主机发送的分组数，让发生拥塞的路由器有时间把积压的分组处理完。</li>

</ol>
</li>
<li><p>慢开始和拥塞避免算法使用了“乘法减小”和“加法增大”的方法，使得网络出现拥塞时ssthresh下降很快，cwnd缓慢增大。</p>
</li>

</ol>
</li>
<li><p>快重传和快恢复——对慢开始和拥塞避免的改进</p>
<ol>
<li><p>快重传</p>
<ol>
<li>快重传技术使用冗余ACK技术来检测丢包，发送方连续收到三个重复的ACK时直接重传。</li>
<li>冗余ACK并非取消重传计时器，而是在某些情况下加快重传丢失的报文段。</li>

</ol>
</li>
<li><p>快恢复</p>
<ol>
<li>发送方连续收到三个冗余ACK时，执行“乘法减小”算法，把ssthresh设置为当前cwnd的一半。</li>
<li>快恢复可以预防网络发生拥塞，同时由于能够收到后续的ACK，因此网络拥塞可能未必严重，因此可以跳过重新慢开始阶段，因此也称为快恢复。</li>

</ol>
</li>
<li><p>网络拥塞的处理<img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-07-04%20%E4%B8%8A%E5%8D%8810.05.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-04 上午10.05.29"></p>
</li>

</ol>
</li>
<li><p>在拥塞控制中，发送方自己通过检测网络状态决定发送量，慢开始、拥塞避免、快重传、快恢复算法是同时应用在拥塞控制机制中。</p>
</li>

</ol>
<p>&nbsp;</p>
</body>
</html>