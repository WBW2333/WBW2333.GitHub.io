<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软工-第五部分-软件构造、测试、交付与维护</title>
</head>
<body><h1 id='软工-第五部分-软件构造测试交付与维护'>软工-第五部分-软件构造、测试、交付与维护</h1>
<h2 id='十七软件构造'>十七、软件构造</h2>
<h3 id='1）软件构造'>（1）软件构造</h3>
<ol>
<li><p>软件构造的定义：通过编码、验证、单元测试、集成测试和调试等工作的结合，生产可工作的、有意义的软件的详细创建过程。即以程序员为主完成的综合性任务。</p>
</li>
<li><p>软件构造包含的活动：</p>
<ol>
<li>详细设计</li>
<li>编程</li>
<li>测试</li>
<li>调试</li>
<li>代码评审</li>
<li>集成与构建</li>
<li>构造管理</li>

</ol>
</li>

</ol>
<h3 id='2）软件构造活动'>（2）软件构造活动</h3>
<ol>
<li><p>详细设计</p>
</li>
<li><p>编程</p>
<ol>
<li><p>编程是软件构造的核心活动，目的是生产高质量的策划个女婿代码。</p>
</li>
<li><p>程序代码的典型质量：</p>
<ol>
<li>易读性：编程最重要的目标，可以使得程序更容易开发、易与调试、容易维护、减少理解代码的难度和成本、更容易复用。</li>
<li>易维护性</li>
<li>可靠性：执行正确并妥善处理故障</li>
<li>性能：包括时间和空间性能。</li>
<li>安全性</li>

</ol>
</li>

</ol>
</li>
<li><p>测试</p>
<ol>
<li>通过单元测试和集成测试验证设计的正确性。</li>
<li>通常每修改一次程序就需要最少一次单元测试，集成测试在单元测试之后，测试多个单元之间的接口是否正确。</li>

</ol>
</li>
<li><p>调试</p>
<ol>
<li><p>测试发现问题之后通过调试找到缺陷并修复。</p>
</li>
<li><p>调试可分为：</p>
<ol>
<li><p>重现问题：从控制输入、控制环境入手。</p>
</li>
<li><p>诊断缺陷：灵活使用编译器提示、检查刚修改的部分、持续缩小嫌疑代码范围、利用工具、内存或资源泄露、逻辑/编码/循环/条件/指针/分配释放/多线程/定时...错误、内存溢出</p>
</li>
<li><p>修复缺陷：</p>
<ol>
<li>一次只修复一个缺陷</li>
<li>修复前保留旧版本备份</li>
<li>使用测试和评审验证修复的有效性</li>
<li>检查和修复类似的缺陷</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>代码评审</p>
<ol>
<li>对代码的系统检查。</li>
<li>可分为正式评审、轻量级评审和结对编程三种。</li>

</ol>
</li>
<li><p>集成与构建</p>
<ol>
<li>将分散单位集成和构建为构件、子系统和完整系统。</li>
<li>集成有大爆炸式集成和增量式集成，实践中增量式集成更好。</li>

</ol>
</li>
<li><p>构造管理</p>
<ol>
<li>包括构造计划、度量和配置管理三个任务。</li>

</ol>
</li>

</ol>
<h3 id='3）软件构造的实践方法'>（3）软件构造的实践方法</h3>
<ol>
<li><p>重构：</p>
<ol>
<li><p>重构的原因：进行软件维护，由于时间变化导致软件不能满足修改要求或因为多次修改导致软件质量脆弱难以维持可修改性，就需要通过重构改进局部软件设计结构，提升其质量。</p>
</li>
<li><p>重构的定义：修改软件系统的严谨方法，在不改变代码的外观表现的情况下改进其内部结构。</p>
</li>
<li><p>重构的时机：</p>
<ol>
<li>增加新功能时</li>
<li>发现缺陷进行修复时</li>
<li>进行代码评审时</li>

</ol>
</li>
<li><p>重构的注意事项：</p>
<ol>
<li>重构是基于已有代码的改进，不是开发新代码。</li>
<li>重构要防止副作用。</li>
<li>重构的重点是改进详细设计结构。</li>

</ol>
</li>

</ol>
</li>
<li><p>测试驱动开发</p>
<ol>
<li><p> 定义：在编写完成一段代码之前，优先完成该代码的测试代码。测试代码由测试工具自动装在执行，也可以有程序员手动执行。</p>
</li>
<li><p>测试驱动开发的优点：</p>
<ol>
<li>提高程序的正确性和可靠性。</li>
<li>提高设计质量。</li>
<li>提高生产力。</li>

</ol>
</li>
<li><p>测试驱动开发过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%888.24.45.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午8.24.45"></p>
</li>

</ol>
</li>
<li><p>结对编程</p>
<ol>
<li><p>定义：两个程序员挨着坐在一起，共同协作进行软件构造活动。掌握键盘的人成为Driver，负责输入代码，另一位称为Observer，对Driver输入的代码进行评审等。两个程序员可以互换角色。</p>
</li>
<li><p>优点：</p>
<ol>
<li>提高程序质量</li>
<li>降低程序缺陷率</li>
<li>减少返工和维修成本</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题-1'>（4）习题</h3>
<ol>
<li><p>软件构造与软件实现有什么不同？</p>
<p>软件构造与软件实现有以下不同：</p>
<ul>
<li>软件构造是软件开发过程中的一个阶段，涵盖了详细设计、编码、调试、测试等活动，是将软件设计转换为可执行代码的过程。</li>
<li>软件实现是软件构造的一个子阶段，专注于将详细设计转换为源代码，并进行编码、调试和测试的过程。</li>

</ul>
</li>
<li><p>为什么软件构造要执行详细设计、代码设计、单元测试、集成测试？</p>
<p>软件构造要执行详细设计、代码设计、单元测试、集成测试的原因是为了确保代码质量和功能正确性。详细设计和代码设计是为了确保代码结构合理、模块化，易于维护和扩展；单元测试是为了验证每个独立单元的功能是否正确；集成测试是为了验证各个单元之间的交互是否正确。</p>
</li>
<li><p>实践经验表明调试比较依赖于程序员的经验，分析一下为什么？</p>
<p>调试比较依赖于程序员的经验，因为调试涉及到定位和解决问题，需要程序员具有丰富的知识和经验来理解代码逻辑、推理错误原因，以及选择合适的修复方法。经验丰富的程序员可能会更加熟悉代码库，对常见问题和解决方法有更深的了解，因此在调试时更加得心应手。</p>
</li>
<li><p>重构是在已有代码的基础上进行详细设计，它与在软件设计阶段进行的事先设计有什么不同？各自的优缺点是什么？</p>
<p>重构是在已有代码的基础上进行代码修改，而在软件设计阶段进行的事先设计是在构建系统的结构和模块之前进行规划和设计。重构强调的是在保持功能不变的前提下，优化代码结构，提高代码质量和可维护性；而事先设计则是在系统构建之前，对系统的整体结构和组织进行设计。</p>
<ul>
<li>重构的优点：提高代码质量和可维护性，优化代码结构，降低技术债务，提高开发效率。</li>
<li>事先设计的优点：在构建系统之前进行全面的规划和设计，可以避免后期重构带来的风险和工作量，降低代码修改的频率。</li>

</ul>
</li>
<li><p>实践调查显示，相较于新手，结对编程更适用于熟练程序员，你认为原因是什么？</p>
<p>实践调查显示，相较于新手，结对编程更适用于熟练程序员的原因是熟练程序员通常对代码更熟悉，对问题的解决更有经验。在结对编程中，熟练程序员可以提供更多的指导和建议，帮助新手更好地理解问题和解决方案，从而提高工作效率和代码质量。</p>
</li>
<li><p>你认为应该如何提高程序的易读性、易维护性、可靠性、性能和安全性？</p>
<p>提高程序的易读性、易维护性、可靠性、性能和安全性可以通过以下方法：</p>
<ul>
<li>易读性：遵循良好的编码规范和命名约定，提供清晰的注释，采用模块化的设计，减少复杂嵌套和冗余代码。</li>
<li>易维护性：保持代码的模块化，遵循设计原则和设计模式，减少代码耦合，提供清晰的接口和文档，使用版本控制来管理代码修改。</li>
<li>可靠性：进行充分的单元测试和集成测试，处理异常情况和错误，采用防御性编程的思想，确保代码的正确性和稳定性。</li>
<li>性能：对代码进行性能优化，使用高效的算法和数据结构，避免不必要的资源浪费，减少系统的响应时间和资源占用。</li>
<li>安全性：采用安全编程的实践，对用户输入进行验证和过滤，防范常见的安全漏洞，保护系统免受攻击和恶意行为。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十八代码设计'>十八、代码设计</h2>
<h3 id='1）易读性'>（1）易读性</h3>
<ol>
<li><p>无论是出于团队协作，还是维护的需要，易读性都应该是代码的兽药质量标准。</p>
</li>
<li><p>代码规范：</p>
<ol>
<li><p>格式：代码布局能清晰体现程序的逻辑结构</p>
<ol>
<li>使用缩进和对齐表达逻辑结构。</li>
<li>将相关逻辑组织在一起。</li>
<li>使用空行分割逻辑。</li>
<li>语句分行。</li>

</ol>
</li>
<li><p>命名：惯例和规则</p>
<ol>
<li>有意义的名称命名。</li>
<li>存在惯例则遵守惯例</li>
<li>不要太长</li>
<li>不要使用易混淆字母、太长或无逻辑的字母缩写。</li>

</ol>
</li>
<li><p>注释：</p>
<ol>
<li>文档注释：javadoc</li>
<li>内部注释</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='2）易维护性'>（2）易维护性</h3>
<ol>
<li><p>易读是易维护的前提。</p>
</li>
<li><p>易维护性：</p>
<ol>
<li><p>小型任务：控制代码复杂度，将完成一个功能的多个步骤、长代码的程序分解为多个高内聚、低耦合的小任务（小任务还能提高易读性）。</p>
</li>
<li><p>复杂决策：代码业务规则容易变化，需要修改决策（布尔表达式）</p>
<ol>
<li>使用新布尔变量简化负责决策。</li>
<li>使用有意义的名称封装决策。</li>
<li>表驱动编程</li>

</ol>
</li>
<li><p>数据使用：</p>
<ol>
<li>不要把变量用于与命名不符的目的。</li>
<li>不要将单个变量用于多个目的。</li>
<li>限制全局变量的使用。</li>
<li>不要使用突兀的数字与字符。</li>

</ol>
</li>
<li><p>明确依赖关系：类之间模糊的依赖关系容易导致未预期的连锁反应。</p>
</li>

</ol>
</li>

</ol>
<h3 id='3）可靠性'>（3）可靠性</h3>
<ol>
<li><p>提高可靠性往往会降低易读性、性能和维护性，因此只有针对对可靠性要求高的代码才会专门去提高可靠性。</p>
</li>
<li><p>可靠性：</p>
<ol>
<li><p>契约式设计</p>
<ol>
<li><p>又称断言式设计，基本思想是：如果一个函数或方法，在前置条件满足的情况下开始执行，完成后能满足后置条件那么这个函数或方法就是正确、可靠的。</p>
</li>
<li><p>编程方式：</p>
<ol>
<li>异常：在代码开始执行判断前置条件，结束执行后判断后置条件，不符合抛出异常（throw）</li>
<li>断言：代码开始执行检查前置条件，结束执行后检查后置条件，不符合抛出异常（assert）</li>
<li>比较：</li>

</ol>
</li>
<li><p>Java在Public方法中使用异常，Protected、Private方法中使用断言。</p>
</li>

</ol>
</li>
<li><p>防御式编程</p>
<ol>
<li>基本思想：在一个方法与其他方法、OS、硬件等外界环境交互时，不能确保外界都是正确的，因此要在外界发生错误时，保护方法内部不受损害。</li>
<li>防御式编程会增加整体代码的复杂度、降低易读性和性能，但是能显著提高程序可靠性。</li>

</ol>
</li>
<li><p>使用模型辅助设计复杂代码</p>
<ol>
<li><p>决策表</p>
<ol>
<li>一种决策逻辑的表示方法，用于描述复杂决策逻辑。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%889.21.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午9.21.00"></li>
<li>决策表来描述复杂决策能保证决策分析的完备性，减少规则遗漏和考虑不周。还能方便表驱动编程，将复杂决策代码简单化。</li>

</ol>
</li>
<li><p>伪代码</p>
<ol>
<li>结合编程语言和自然语言的特点。</li>
<li>不是编程语言因此不存在语法问题，不需要关心语言规范。</li>

</ol>
</li>
<li><p>程序流程图</p>
<ol>
<li>圆角矩形表示开始和结束，倾斜矩形表示输入和输出，矩形表示顺序处理步骤，菱形表示控制结构的决策分支。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%889.23.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午9.23.38"></li>
<li>利用流程图可以清晰表现程序逻辑结构的特点。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）为代码开发单元测试用例'>（4）为代码开发单元测试用例</h3>
<ol>
<li><p>在未按照测试驱动方法完成代码后，需要为代码开发单元测试用例，开发测试用例的线索有：</p>
<ol>
<li>方法的规格</li>
<li>方法代码的逻辑结构</li>

</ol>
</li>
<li><p>使用Mock Object测试类方法。</p>
</li>
<li><p>为类开发测试用例：需要为复杂类的方法和不同类方法之间的影响开发测试用例</p>
</li>

</ol>
<h3 id='5）代码复杂度度量'>（5）代码复杂度度量</h3>
<ol>
<li><p>McCabe的圈复杂度</p>
<ol>
<li>程序的复杂度由控制流定义，即控制结构最大地影响了程序复杂度。</li>
<li>圈复杂度的基本思路是计算程序中独立路径的最大数量。</li>

</ol>
</li>

</ol>
<h3 id='6）考虑'>（6）考虑</h3>
<ol>
<li>简洁性、可维护性</li>
<li>使用数据结构消减复杂判定</li>
<li>控制结构、变量使用、语句处理</li>
<li>How to write unmaintainable code</li>
<li>防御与错误处理</li>

</ol>
<h3 id='7）习题'>（7）习题</h3>
<ol>
<li><p>为什么要重视代码的易读性？</p>
<p>重视代码的易读性是因为代码在软件开发中不仅是计算机能够理解的指令集，也是程序员之间的交流工具。易读性良好的代码可以使程序员更容易理解代码的逻辑和功能，减少阅读和理解代码所需的时间，提高代码的可维护性和可理解性。同时，易读性好的代码还可以减少错误和缺陷的产生，降低代码维护的难度和成本。</p>
</li>
<li><p>代码规范的作用是什么？如果一个程序员不了解编程规范，那么他写的程序可能会有哪些不好的表现？</p>
<p>代码规范的作用是为编程提供统一的标准和规范，使得团队成员能够在同一标准下进行开发，提高代码的一致性和可读性。如果一个程序员不了解编程规范，他写的程序可能会有以下不好的表现：</p>
<ul>
<li>代码风格混乱，不统一，影响代码的可读性。</li>
<li>变量和函数命名不规范，难以理解代码的含义。</li>
<li>缺少注释或注释不清晰，导致他人难以理解代码的逻辑和用途。</li>
<li>缺乏结构化和模块化的设计，代码难以维护和扩展。</li>

</ul>
</li>
<li><p>怎样布局能够清晰地体现代码的逻辑结构？</p>
<p>要清晰地体现代码的逻辑结构，可以采用以下布局方法：</p>
<ul>
<li>使用缩进：通过缩进来表示代码的层次结构，使代码块的逻辑结构清晰可见。</li>
<li>使用空行：在代码块之间使用空行分隔，使代码的布局更加清晰，方便阅读。</li>
<li>使用合适的命名：使用有意义的变量名和函数名，能够更好地体现代码的逻辑结构和功能。</li>
<li>使用注释：适当地添加注释，解释代码的逻辑和用途，有助于他人理解代码。</li>

</ul>
</li>
<li><p>文档注释与内部注释有什么不同？各自的重点、要点是什么？</p>
<p>文档注释与内部注释的不同在于：</p>
<ul>
<li>文档注释：是指对代码进行注释并生成文档的注释方式，通常使用特定的注释格式，例如Java中的Javadoc。文档注释用于生成API文档，对外部用户提供代码的接口和使用说明。</li>
<li>内部注释：是指在代码中添加的对代码逻辑和功能的注释，用于帮助程序员理解代码的实现细节和设计思路。</li>

</ul>
<p>文档注释的重点是对代码的接口和用途进行说明，强调代码的对外展现；内部注释的重点是对代码的实现和设计进行说明，强调代码的内部逻辑和实现细节。</p>
</li>
<li><p>为什么要重视代码的易维护性？</p>
<p>重视代码的易维护性是因为软件的生命周期中，维护阶段通常占据了大部分时间和资源。易维护的代码能够降低维护成本，增加代码的可靠性和稳定性。易维护的代码应该具有清晰的结构和模块化设计，注重代码的可读性和可理解性，使用规范的命名和注释，遵循设计原则和最佳实践。</p>
</li>
<li><p>小型任务为什么能够提高代码的可维护性？</p>
<p>小型任务能够提高代码的可维护性，因为将大型任务拆分为小型任务有以下优势：</p>
<ul>
<li>小型任务更易于管理和追踪，有利于项目进度的控制和管理。</li>
<li>小型任务更易于定位和解决问题，有助于减少维护和修复的时间和成本。</li>
<li>小型任务可以更好地实现模块化和结构化的设计，使得代码更易于维护和扩展。</li>

</ul>
</li>
<li><p>为什么要处理复杂决策？有哪些处理方法？</p>
<p>处理复杂决策的方法有：</p>
<ul>
<li>将复杂决策拆分为多个简单决策，然后再进行综合考虑。</li>
<li>使用决策表或决策树来清晰地表示复杂的条件和逻辑。</li>
<li>采用面向对象的设计方法，将复杂决策抽象成类和对象的关系，提高代码的可读性和可维护性。</li>
<li>使用设计模式，如策略模式、状态模式等，来处理复杂的条件和行为，使代码更加灵活和易维护。</li>

</ul>
</li>
<li><p>有哪些常见的数据使用不当会降低代码的可维护性？请举例说明。</p>
<p>常见的数据使用不当会降低代码的可维护性包括：</p>
<ul>
<li>变量命名不合适：使用含义不明确的变量名会使代码难以理解和维护。</li>
<li>长方法或函数：一个方法或函数包含过多的代码会使其难以理解和维护。</li>
<li>魔数和硬编码：使用未解释的常量值或硬编码的数字会降低代码的可读性和可维护性。</li>
<li>冗余数据：不必要的重复数据会增加维护的难度和风险。</li>
<li>数据耦合：过度依赖其他模块的数据会增加代码的耦合性，降低可维护性。</li>

</ul>
<p>举例：一个程序中使用了大量硬编码的数字作为数组的长度和索引，当需求发生变化时，需要修改多处硬编码的值，而没有使用常量或变量进行定义，导致代码的维护困难。</p>
</li>
<li><p>类之间存在哪些模糊的依赖关系？如何将它们变得明显、清晰？</p>
<p>类之间存在的模糊依赖关系包括：</p>
<ul>
<li>非直接依赖：类之间的依赖关系通过间接调用或中介类产生，不容易被发现和理解。</li>
<li>隐式依赖：类之间的依赖关系没有明确地在代码中表达出来，需要仔细阅读代码才能发现。</li>

</ul>
<p>要将模糊的依赖关系变得明显、清晰，可以：</p>
<ul>
<li>使用明确的类之间的调用关系，避免通过中介类产生不必要的依赖。</li>
<li>使用接口或抽象类来定义类之间的关系，增加代码的可读性和可维护性。</li>

</ul>
</li>
<li><p>哪些代码需要重视可靠性？试着举例说明。</p>
<p>需要重视可靠性的代码包括：</p>
<ul>
<li>安全性相关的代码：例如涉及用户身份验证、敏感数据处理等的代码，需要保证其可靠性，防止数据泄露和安全漏洞。</li>
<li>重要业务逻辑的代码：涉及重要业务逻辑的代码需要保证其正确性和可靠性，以确保业务运行的稳定性。</li>
<li>关键系统组件的代码：涉及关键系统组件的代码需要高度可靠，以确保系统的稳定运行。</li>

</ul>
</li>
<li><p>契约式设计与防御式编程有哪此异同？</p>
<p>契约式设计与防御式编程的异同：</p>
<ul>
<li>契约式设计：通过使用前置条件、后置条件和不变式等契约来明确方法的预期行为和结果。契约式设计强调类之间的合约关系，要求类在使用时必须遵守其定义的契约。</li>
<li>防御式编程：主要是为了增强代码的健壮性，通过在代码中添加额外的检查和处理来防止错误或异常的发生。防御式编程强调在代码中主动进行防御，处理可能的异常情况，以提高代码的容错能力。</li>

</ul>
</li>
<li><p>异常方式与断言方式各自的优缺点是什么？</p>
<p>异常方式与断言方式各自的优缺点：</p>
<ul>
<li>异常方式： 优点：可以在代码中捕获和处理异常，增加代码的健壮性和容错能力，保持代码的可读性。 缺点：过度使用异常可能导致代码的复杂性增加，不适合处理所有情况，对性能有一定影响。</li>
<li>断言方式： 优点：可以在开发和测试阶段帮助发现代码中的错误和问题，提高代码的质量和稳定性。 缺点：断言只在开发和测试阶段有效，不能在生产环境中捕获和处理异常。</li>

</ul>
</li>
<li><p>为什么需要使用模型方法辅助进行复杂代码的设计？有哪些常用的代码设计模型方法？</p>
<p>使用模型方法辅助进行复杂代码的设计有助于抽象和理清代码的逻辑结构，提高代码的可读性和可维护性。常用的代码设计模型方法包括：</p>
<ul>
<li>数据流图：用于描述数据的流动和处理过程，帮助理解代码的数据流动和处理逻辑。</li>
<li>状态图：用于描述对象的状态转换和行为，帮助理解代码的状态变化和行为过程。</li>
<li>类图：用于描述类和类之间的关系，帮助理解代码的类结构和模块之间的依赖关系。</li>
<li>时序图：用于描述对象之间的交互和消息传递，帮助理解代码的时序行为。</li>

</ul>
</li>
<li><p>为什么控制流最能体现代码的复杂度？分析一下，有哪些手段可以据此降低代码的复杂度？</p>
<p>控制流最能体现代码的复杂度，因为控制流决定了代码执行的顺序和路径。降低代码的复杂度可以采取以下手段：</p>
<ul>
<li>减少条件判断和嵌套：避免过多的条件判断和嵌套结构，使代码更加直观和简洁。</li>
<li>拆分长方法或函数：将长的方法拆分为多个短小的方法，减少方法的复杂性。</li>
<li>使用多态：通过多态性来消除大量的条件判断，使代码更加灵活和易扩展。</li>
<li>使用设计模式：采用设计模式来降低代码的复杂性，提高代码的可维护性和可扩展性。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十九软件测试'>十九、软件测试</h2>
<h3 id='1）测试层次'>（1）测试层次</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%8810.01.48.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午10.01.48"></p>
<h3 id='2）测试技术'>（2）测试技术</h3>
<ol>
<li><p>随机测试</p>
<ol>
<li>一种基于工程师直觉和经验的技术，让工程师根据直觉从可能的输入值中选择输入子集，建立测试用例。</li>
<li>随机测试不是最优的，测试到缺陷的几率也很小，但是有时能发现一些其他技术发现不到的缺陷。</li>

</ol>
</li>
<li><p>黑盒测试——基于规格的技术</p>
<ol>
<li><p>将测试对象看作一个黑盒，完全基于输入和输出数据判定测试对象的正确性。</p>
</li>
<li><p>测试方法</p>
<ol>
<li><p>等价类划分</p>
<ol>
<li><p>把所有可能的输入数据划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%8810.14.46.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午10.14.46"></p>
</li>
<li><p>等价类划分有两种不同的情况：</p>
<ol>
<li>有效等价类：对于程序的规格说明来说是合理的、有意义的输入数据构成的集合，可以验证程序是否实现了规格说明中所规定的功能和性能。</li>
<li>无效等价类：相反。</li>

</ol>
</li>
<li><p>设计用例时需要考虑两种等价类，软件不仅要接受合理的数据也要接受意外的输入。</p>
</li>

</ol>
</li>
<li><p>边界值分析：错误最容易发生在各等价类的边界上，针对边界情况设计测试用例可以发现更多的缺陷。</p>
</li>
<li><p>决策表</p>
<ol>
<li>为复杂逻辑判断设计测试用例的技术。</li>
<li>决策表是由条件声明、行动声明、规则选项和行动选项四个象限组成的表格。</li>

</ol>
</li>
<li><p>状态转换</p>
<ol>
<li>针对复杂测试对象的技术，该对象对输入数据的反应是多样的，会根据自身的状态决定输出。</li>
<li>状态转换先为测试对象建立状态图，描述对象的状态集合、输入集合和输入导致的状态转换集合。</li>
<li>状态转换包括有效转换和无效转换，只需要为有效转换设计测试用例。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>白盒测试——基于代码的技术</p>
<ol>
<li><p>白盒测试将测试对象看作透明的，不关心测试对象的规则，按照测试对象的内部程序结构来设计测试用例。</p>
</li>
<li><p>测试方法</p>
<ol>
<li><p>语句覆盖</p>
<ol>
<li>标准是确保被测试对象的每一行程序都至少被执行一次。</li>
<li>语句覆盖是一种比较弱的代码覆盖技术，不能覆盖所有执行路径。</li>

</ol>
</li>
<li><p>条件覆盖</p>
<ol>
<li>标准是确保程序中每个判断的每个结果都至少满足一次。</li>
<li>条件覆盖的覆盖程度比语句覆盖强，但仍不敢保证覆盖所有执行路径。</li>

</ol>
</li>
<li><p>路径覆盖</p>
<ol>
<li>标准是确保程序中每条独立的执行路径都至少执行一次。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）测试活动'>（3）测试活动</h3>
<ol>
<li><p>测试计划</p>
<ol>
<li>测试计划明确软件测试的工作范围、资源与成本、基本策略、进度安排等。</li>
<li>明确表明测试的对象、测试的级别、测试的顺序、每个测试对象所应用的测试策略以及测试环境。</li>
<li>测试计划开始于需求开发结束之后，部分开始于体系结构设计之后，另一部分开始于详细设计之后，单元测试计划开始于编程完成之后。</li>

</ol>
</li>
<li><p>测试设计：目标是进一步明确需要被测试的对象，综合考虑测试层次、被测对象特点和软件测试的目标，选择合适的测试技术，设计能够同时满足质量目标和项目约束的测试用例。</p>
</li>
<li><p>测试执行</p>
</li>
<li><p>测试评价：评价之后还要发布测试报告。</p>
</li>

</ol>
<h3 id='4）测试度量'>（4）测试度量</h3>
<ol>
<li><p>缺陷度量：缺陷数据，分类汇总在测试中发现的缺陷。</p>
</li>
<li><p>测试覆盖率：</p>
<ol>
<li>需求覆盖率：被测试的需求数/需求总数</li>
<li>模块覆盖率：被测试的模块数/模块总数</li>
<li>代码覆盖率：被测试的代码行/代码总行</li>

</ol>
</li>

</ol>
<h3 id='5）习题'>（5）习题</h3>
<ol>
<li><p>为什么要进行验证与确认？</p>
<p>验证与确认的目的是确保软件开发满足用户需求和质量标准。验证是确认软件是否按照规格和需求正确地构建，确认是用户接受软件是否满足他们的期望和需求。</p>
</li>
<li><p>如何判断软件测试的成功？</p>
<p>软件测试的成功判断主要取决于以下几个方面：</p>
<ul>
<li>测试覆盖率：是否覆盖了软件的所有功能和边界条件。</li>
<li>缺陷率：是否发现和修复了大部分重要的缺陷。</li>
<li>可靠性：软件在测试过程中是否表现稳定，没有严重的崩溃或错误。</li>
<li>用户满意度：用户是否对软件的功能和性能感到满意。</li>

</ul>
</li>
<li><p>软件测试的代价有哪些？</p>
<p>软件测试的代价包括：</p>
<ul>
<li>人力成本：测试人员的工资和培训成本。</li>
<li>设备和工具成本：购买和维护测试所需的设备和工具。</li>
<li>时间成本：测试过程中的时间投入。</li>
<li>风险成本：如果软件中的缺陷没有被及时发现和修复，可能会导致更高的风险和损失。</li>

</ul>
</li>
<li><p>软件测试有哪些层次？请分别加以描述。</p>
<p>软件测试的层次包括：</p>
<ul>
<li>单元测试：测试软件的最小功能单元，通常是单个函数或方法。</li>
<li>集成测试：测试多个单元之间的集成，确保它们能够正确地协同工作。</li>
<li>系统测试：测试整个系统的功能和性能，确认系统是否满足用户需求。</li>
<li>验收测试：由用户或客户进行的测试，确认软件是否符合需求并满足他们的期望。</li>

</ul>
</li>
<li><p>随机测试技术有什么缺点？什么情景下可以使用？</p>
<p>随机测试技术的缺点包括：</p>
<ul>
<li>可能会漏掉一些特定情况或边界条件，导致测试覆盖率不够高。</li>
<li>难以重现问题：由于随机性，测试结果可能难以重现，使得问题难以跟踪和修复。</li>

</ul>
<p>在一些情况下可以使用随机测试技术，特别是在发现传统测试方法难以覆盖的复杂或随机性很强的场景中，随机测试可以提供一种有效的补充。</p>
</li>
<li><p>比较黑盒测试和白盒测试方法，说明各自的优缺点。</p>
<p>黑盒测试和白盒测试方法的比较：</p>
<ul>
<li><p>黑盒测试：</p>
<ul>
<li> 优点：独立于代码实现，能够更好地关注用户需求，易于发现功能缺陷。</li>
<li> 缺点：覆盖面有限，可能无法检测到所有的逻辑错误，需要依赖详细需求文档。</li>

</ul>
</li>
<li><p>白盒测试：</p>
<ul>
<li> 优点：能够更全面地测试代码的逻辑和路径，发现代码缺陷和逻辑错误。</li>
<li> 缺点：需要测试人员了解代码的实现细节，对测试人员的技术要求较高，容易忽略用户需求。</li>

</ul>
</li>

</ul>
</li>
<li><p>软件测试要执行哪些活动？请分别加以描述。</p>
<p>软件测试要执行的活动包括：</p>
<ul>
<li>测试计划编制：制定测试策略和计划，明确测试的目标和范围。</li>
<li>测试用例设计：根据需求和设计文档，编写测试用例。</li>
<li>执行测试用例：按照测试计划执行测试用例，记录测试结果和缺陷。</li>
<li>缺陷管理：记录和跟踪测试过程中发现的缺陷，并与开发团队协调修复。</li>
<li>验证和确认：确认修复后的缺陷，并验证软件是否符合用户需求和质量标准。</li>
<li>性能测试：对软件的性能进行测试，确保其能够满足性能要求。</li>
<li>安全测试：对软件的安全性进行测试，防止安全漏洞和风险。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十软件交付'>二十、软件交付</h2>
<h3 id='习题'>习题</h3>
<ol>
<li><p>软件交付的目标是什么？包括哪此活动？ </p>
<p>软件交付的目标是将已开发完成的软件产品交给用户或客户，以满足他们的需求和期望。软件交付的活动包括：</p>
<ul>
<li>软件打包：将软件源代码、可执行文件和相关文档打包成可交付的软件包。</li>
<li>软件安装：将软件安装到用户或客户的计算机系统中。</li>
<li>软件部署：将软件部署到用户或客户的服务器或云平台上。</li>
<li>用户培训：为用户提供软件的培训，使其能够熟练使用软件。</li>
<li>文档支持：为用户提供详细的使用文档和帮助手册，方便用户使用软件。</li>

</ul>
</li>
<li><p>安装与部署有什么区别？什么情况下使用安装？什么情况下使用部署？ </p>
<p>安装与部署的区别：</p>
<ul>
<li>安装：通常指将软件安装到用户或客户的本地计算机上，用户可以在自己的计算机上使用软件。</li>
<li>部署：通常指将软件部署到服务器或云平台上，多个用户可以通过网络访问和使用该软件。</li>

</ul>
<p>使用安装的情况：适用于将软件安装在用户个人计算机上，例如桌面应用程序或个人工具。 使用部署的情况：适用于将软件部署在服务器上，并供多个用户通过网络访问和使用，例如网站或企业级应用。</p>
</li>
<li><p>培训与文档支持的作用相同吗？解释你的理由。</p>
<p>培训与文档支持的作用不完全相同。培训的主要目的是为用户提供实际操作软件的技能和知识，使其能够熟练使用软件。文档支持的主要目的是为用户提供参考和帮助，解答使用过程中的常见问题。虽然两者都是为了帮助用户更好地使用软件，但培训更注重实际操作和技能培养，而文档支持更注重提供信息和帮助。</p>
</li>
<li><p>为什么在开发结束时要进行项目评价？ </p>
<p>在开发结束时进行项目评价的目的是为了总结和评估项目的整体绩效，包括项目的成功度、质量、成本、进度等方面。通过项目评价，可以从项目管理和开发过程中吸取经验教训，为未来的项目提供改进和优化的方向。</p>
</li>
<li><p>项目评价要注意哪此事项？</p>
<p>项目评价要注意以下事项：</p>
<ul>
<li>项目目标：评价项目是否达到了既定的目标和交付标准。</li>
<li>项目绩效：评估项目的成本、进度、质量等绩效指标是否符合预期。</li>
<li>项目风险：回顾项目中的风险管理措施是否有效，是否有未被充分考虑的风险。</li>
<li>项目管理：分析项目管理过程中的问题和挑战，提出改进意见。</li>
<li>团队表现：评价团队的合作效率和协作能力，认可团队成员的贡献。</li>
<li>用户反馈：收集用户的反馈意见和建议，了解用户对软件的满意度和需求。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十一软件维护与演化'>二十一、软件维护与演化</h2>
<h3 id='1）软件维护'>（1）软件维护</h3>
<ol>
<li><p>软件维护的定义：软件维护是在交付之后修改软件系统或其部件的活动过程，以修正缺陷、提高性能或其他属性、适应变化的环境。</p>
</li>
<li><p>软件维护是以变更为中心的，所以软件维护类型为：</p>
<ol>
<li>完善性维护：为了满足用户新需求、增加软件功能而进行的软件修改活动。</li>
<li>适应性维护：为了使软件能适应新环境而进行的软件修改活动。</li>
<li>修正性维护：为了排除软件产品中遗留的缺陷而进行的软件修改活动。</li>
<li>预防性维护：为了让软件产品在将来可维护，提升可维护性而进行的软件修改活动。</li>

</ol>
</li>
<li><p>软件维护的高代价性：</p>
<ol>
<li>变更的频繁性</li>
<li>维护的困难性</li>

</ol>
</li>
<li><p>软件维护过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.04.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.04.04"></p>
</li>

</ol>
<h3 id='2）软件演化'>（2）软件演化</h3>
<ol>
<li><p>由于软件开发周期的演唱，开发人员开始采用分段交付的方法来完成产品，第一次开发时只完成最基本的需求集合，在后续以增量的方式逐次开发和渐进交付，同时在每次交付时还要根据用户反馈完成对之前内容的维护，这种过程的开发和维护难以分开，因此称为演化。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.07.20.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.07.20"></p>
</li>
<li><p>软件系统演化定律：</p>
<ol>
<li>持续变化：一个大型软件系统要么不断变化，要么用处越来越少。</li>
<li>不断增加的复杂度：软件系统的复杂度会随着发展增加，除非进行工作来降低复杂度。</li>
<li>质量降低：系统的质量会不断下滑，除非采取工作来适应环境变化。</li>

</ol>
</li>
<li><p>软件演化生命周期模型<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.12.10.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.12.10"></p>
<ol>
<li>初始开发：完成的第一个版本的软件产品。</li>
<li>演化：保持软件产品的持续增值。</li>
<li>服务：不再增加价值，只周期性地修正已有缺陷。</li>
<li>逐步淘汰：不再维护软件，对开发者来说软件生命周期已经结束，但是用户可能仍在使用。</li>
<li>停止</li>

</ol>
</li>

</ol>
<h3 id='3）软件维护与演化的技术'>（3）软件维护与演化的技术</h3>
<ol>
<li><p>逆向工程</p>
<ol>
<li>定义：分析目标系统，标识系统的部件及其交互关系，并使用其他形式或者更高层的抽象创建系统表现的过程。</li>
<li>基本原理：抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li>

</ol>
</li>
<li><p>再工程</p>
<ol>
<li><p>逆向工程关心如何理解软件，不会修改软件，再工程主要关注如何修改软件，再工程的目的是对遗留软件系统进行分析和重新开发。</p>
</li>
<li><p>定义：检查和改造一个目标系统，用新的模式及实现复原目标系统。</p>
</li>
<li><p>再工程的活动：</p>
<ol>
<li>改进人们对软件的理解</li>
<li>改进软件自身，通常是提高可维护性、可复用性和可演化性</li>

</ol>
</li>
<li><p>具体活动：</p>
<ol>
<li>重新文档化</li>
<li>重组系统的结构</li>
<li>将系统转换为更新的编程语言</li>
<li>修改数据的结构组织</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题-2'>（4）习题</h3>
<ol>
<li><p>与其他工程学科的维护工作相比，软件维护有什么特点？</p>
<p>软件维护相比其他工程学科的维护工作具有以下特点：</p>
<ol>
<li>软件的不断变化：软件是可修改的，不像实体工程中的硬件构造。软件的需求和环境经常发生变化，需要不断进行更新和适应。</li>
<li>隐藏性：软件的内部实现细节通常对用户隐藏，这使得维护人员在不了解具体实现的情况下进行维护工作。</li>
<li>复杂性：大型软件系统通常包含大量的代码和复杂的逻辑，导致维护工作的复杂性增加。</li>

</ol>
</li>
<li><p>软件维护有哪些类型，</p>
<p>软件维护的主要类型包括：</p>
<ol>
<li>改正性维护：修复已发现的缺陷和错误。</li>
<li>适应性维护：根据环境和需求的变化进行调整和更新。</li>
<li>完善性维护：添加新的功能和特性。</li>
<li>预防性维护：为了预防未来可能出现的问题，进行系统优化和改进。</li>

</ol>
</li>
<li><p>为什么需要进行完善性维护？</p>
<p>需要进行完善性维护的原因是随着业务需求和技术发展的变化，软件需要不断增加新的功能和特性来适应新的需求。</p>
</li>
<li><p>为什么软件维护的代价较高？</p>
<p>软件维护的代价较高主要有以下原因：</p>
<ol>
<li>隐藏性和复杂性：由于软件的隐藏性和复杂性，维护人员需要花费更多的时间和精力来理解代码和识别问题。</li>
<li>缺乏文档和注释：缺乏详细的文档和注释，使得维护人员难以理解代码的逻辑和功能。</li>
<li>不断变化的需求：随着需求的变化，软件需要不断进行更新和修改，增加了维护的工作量。</li>

</ol>
</li>
<li><p>分析一下，为什么在维护阶段理解程序非常困难？</p>
<p>在维护阶段理解程序非常困难的原因包括：</p>
<ol>
<li>缺乏设计文档：在维护阶段，通常缺乏详细的设计文档，维护人员只能通过代码来理解系统的设计和实现。</li>
<li>复杂的逻辑和算法：大型软件系统通常包含复杂的逻辑和算法，维护人员需要花费大量时间来理解和分析这些复杂性。</li>
<li>原开发团队的离开：原开发团队可能已经离开项目或者公司，导致维护人员无法得到及时的指导和解答。</li>

</ol>
</li>
<li><p>开发阶段的哪些预备工作可以减轻维护阶段的工作？</p>
<p>开发阶段的预备工作可以减轻维护阶段的工作，包括：</p>
<ol>
<li>编写详细的设计文档和注释，使得维护人员能够更轻松地理解代码的逻辑和功能。</li>
<li>使用清晰的命名和代码结构，使得代码更易于阅读和理解。</li>
<li>实施代码审查和测试，以确保代码的质量和稳定性。</li>

</ol>
</li>
<li><p>描述软件维护过程。</p>
<p>软件维护过程包括以下步骤：</p>
<ol>
<li>问题识别：识别并记录软件中的问题和缺陷。</li>
<li>问题分析：分析问题的原因和影响。</li>
<li>问题修复：根据分析结果，对问题进行修复和改进。</li>
<li>测试和验证：对修复后的软件进行测试和验证，确保问题已经解决。</li>
<li>部署和发布：将修复后的软件部署和发布给用户或客户。</li>

</ol>
</li>
<li><p>描述软件演化生命周期模型。</p>
<p>软件演化生命周期模型是在软件维护阶段对软件进行不断改进和更新的过程。该模型包括以下阶段：</p>
<ol>
<li>问题识别：识别软件中存在的问题和缺陷。</li>
<li>变更请求：根据用户或客户的需求，提出软件的变更请求。</li>
<li>变更分析：分析变更请求的影响和可行性。</li>
<li>变更设计：设计变更的具体实现方式和方案。</li>
<li>变更实现：根据设计，对软件进行修改和更新。</li>
<li>变更测试：对变更后的软件进行测试和验证，确保变更的正确性和稳定性。</li>
<li>部署和发布：将变更后的软件部署和发布给用户或客户。</li>

</ol>
</li>
<li><p>如何使用演化模型组织大规模系统的开发？</p>
<p>在大规模系统的开发中，可以使用演化模型来组织软件的持续开发和更新。演化模型允许在软件的不断变化中保持系统的稳定性和可维护性，同时适应不断变化的业务需求和技术发展。</p>
</li>

</ol>
</body>
</html>