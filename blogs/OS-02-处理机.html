<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>OS-02-处理机</title>
</head>
<body><h1 id='os'>OS</h1>
<h2 id='二处理机'>二、处理机</h2>
<h3 id='1）进程'>（1）进程</h3>
<ol start='' >
<li><p>进程的定义</p>
<ol start='' >
<li><p>程序：一个指令序列，一个<em>具有一定独立功能的</em>程序关于某个数据集合的<em>一次运行活动</em>。</p>
</li>
<li><p>引入多道程序技术以后，计算机中同时可以有多个程序运行，内存里同时放入多道程序，每个程序的代码、数据等存放的位置都不同，操作系统如何才能找到具体位置呢？</p>
</li>
<li><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般来说把进程实体简称为进程。</p>
<p>所谓创造进程，就是创造进程实体中的PCB，撤销进程就是撤销进程实体中的PCB</p>
<p><strong>PCB是进程存在的唯一标志</strong><img src="./assets/OS_b_images//./截屏2022-09-09 上午10.06.38.png" alt="/./截屏2022-09-09 上午10.06.38.png" style="zoom:25%;" /></p>
</li>
<li><p>进程是进程实体的<strong>运行过程</strong>，是<em>系统进行资源分配和调度的一个独立单位</em>。<strong>进程实体和进程并不一样，进程实体是静态的，进程是动态的，运行过程更加强调于他这这个生命周期。</strong></p>
</li>

</ol>
</li>
<li><p>进程的组成：<code>进程由程序段、数据段、PCB组成</code>。</p>
<ol start='' >
<li><p>进程映像：</p>
<ol start='' >
<li>进程映像是某一时刻进程的内容及其执行状态的集合。</li>
<li><em>进程映像的组成部分是进程控制块（PCB）、进程执行的程序（code） / 程序块、进程执行时所用的数据（data） / 数据块、进程执行时使用的工作区/核心栈</em>。</li>
<li>进程映像是内存级的物理实体，又称为进程的内存映像。</li>

</ol>
</li>
<li><p>PCB（Process Control Block）：</p>
<ol start='' >
<li>进程管理者（操作系统）所需的数据都在PCB中，<strong>PCB是进程存在的唯一标志</strong>。</li>
<li>PCB是操作系统刻画进程的执行状态及环境信息的数据结构，是进程动态特征的汇集，是操作系统掌握进程的唯一资料结构和进程调度的主要依据。</li>
<li>主要包含标识信息、现场信息和控制信息。<img src="./assets/OS_b_images//./截屏2022-09-09 上午10.48.52.png" alt="/./截屏2022-09-09 上午10.48.52.png" style="zoom:25%;" /></li>

</ol>
</li>
<li><p>程序段：存放要执行的代码</p>
</li>
<li><p>数据段：存放程序运行过程中处理的各种数据</p>
</li>
<li><p>进程的组织：在一个系统中有成千上万个进程及其PCB，所以我们需要将他们组织起来。</p>
<ol start='' >
<li>链接方式：按照进程状态将PCB分成多个队列；操作系统持有指向各个队列的指针。<img src="./assets/OS_b_images//./截屏2022-09-09 上午10.57.08.png" alt="/./截屏2022-09-09 上午10.57.08.png" style="zoom:25%;" /></li>
<li>索引方式：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针。<img src="./assets/OS_b_images//./截屏2022-09-09 上午11.00.02.png" alt="/./截屏2022-09-09 上午11.00.02.png" style="zoom:25%;" /></li>

</ol>
</li>
<li><p>进程上下文：</p>
<ol start='' >
<li>进程物理实体和支持进程运行的环境和成进程上下文。</li>
<li>包括用户级上下文、寄存器上下文、系统级上下文。</li>

</ol>
</li>

</ol>
</li>
<li><p>进程的特征</p>
<ol start='' >
<li>动态性：进程是程序的一次执行过程，动态的产生、变化和消亡。-&gt;<strong>动态性是进程最基本的特征</strong></li>
<li>并发性；进程中有多个进程实体，各进程可并发执行。</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位。-&gt;<strong>进程是资源分配、接受调度的基本单位</strong></li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题。-&gt;<strong>异步性会导致并发程序执行结果的不确定性</strong></li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程数P组成。</li>
<li>制约性：进程因共享资源或协同工作而相互制约，造成进程执行速度的不可预测性，必须对执行次序予以协调。</li>

</ol>
</li>

</ol>
<h3 id='2）进程的状态'>（2）进程的状态</h3>
<ol start='' >
<li><p>三种基本状态</p>
<ol start='' >
<li>运行态（Running）：占有CPU，并在CPU上运行（CPU的每一个核只能运行一个进程）。</li>
<li>就绪态（Ready）：已经具备运行条件，但没有空闲CPU，而暂时不能运行。</li>
<li>等待/阻塞态（Waiting/Blocked）：：因等待某一事件而暂时不能运行。<strong>CPU是计算机中最宝贵的资源，为了提高CPU的使用率，需要先分配其他资源再得到CPU的服务</strong></li>

</ol>
</li>
<li><p>另外两种状态</p>
<ol start='' >
<li>新建态（New）：进程正在被创建，操作系统为进程分配资源，初始化PCB。</li>
<li>终止态（Terminated）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB。</li>

</ol>
</li>
<li><p>挂起态：随着不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程<strong>挂起（suspend）</strong>，对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度，起到平滑系统负荷的目的；也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再接触挂起并恢复进程运行。进程挂起的原因是多种多样的。</p>
</li>
<li><p>进程状态的转换</p>
<p><img src="./assets/OS_b_images//截屏2022-09-11 上午10.40.18.png" alt="/截屏2022-09-11 上午10.40.18.png" style="zoom:25%;" /></p>
<p><font color=green><strong>842书里面使用的五状态模型是就绪态、阻塞态、运行态、挂起就绪态、挂起阻塞态。</strong></font><img src="./assets/OS_b_images//截屏2023-02-08 下午1.39.24.png" alt="/截屏2023-02-08 下午1.39.24.png" style="zoom:25%;" /></p>
</li>

</ol>
<h3 id='3）-进程控制'>（3） 进程控制</h3>
<ol start='' >
<li><p>什么是进程控制：进程控制的主要功能就是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。-&gt;进程控制就是实现进程状态转换。</p>
</li>
<li><p>为了避免进程的一个状态没有执行完毕就进入其他状态导致错误，使用<strong>原语</strong>实现进程控制，原语的特点是执行期间不允许中断，只能一次执行完毕，这种不可被中断操作即<strong>原子操作</strong>。</p>
<p>原语采用“关中断指令”和“开中断指令”实现。</p>
<p><strong>开/关中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p>
</li>
<li><p>进程控制会导致状态的切换，无论哪个原语，无非都是要做三件事：</p>
<ol start='' >
<li><p>更新PCB信息</p>
<ol start='' >
<li>所有进程控制原语都一定会修改进程状态标志</li>
<li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复其运行环境</li>

</ol>
</li>
<li><p>将PCB插入合适的队列</p>
</li>
<li><p>分配/回收资源</p>
</li>

</ol>
</li>
<li><p>进程的创建</p>
<ol start='' >
<li><p>创建原语：申请空白PCB；为新进程分配所需资源；初始化PCB；将PCB插入就绪队列。</p>
</li>
<li><p>引起进程创建的事件：</p>
<ol start='' >
<li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程。</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程。</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求。</li>
<li>应用请求：有用户进程主动请求创建一个子进程。</li>

</ol>
</li>

</ol>
</li>
<li><p>进程的终止</p>
<ol start='' >
<li><p>撤销原语：从PCB集合中找到终止进程的PCB；若进程正在运行，立即剥夺CPU，将CPU分配给其他进程；终止其所有子进程；将该进程拥有的所有资源归还给父进程或者操作系统；删除PCB。</p>
</li>
<li><p>引起进程终止的事件：</p>
<ol start='' >
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>

</ol>
</li>

</ol>
</li>
<li><p>进程的阻塞</p>
<ol start='' >
<li>阻塞原语：阻塞原语：保存现场信息、修改 PCB、移入等待队列、调度其他进程执行。</li>
<li><img src="./assets/OS_b_images//./截屏2022-09-13 上午10.03.46.png" alt="/./截屏2022-09-13 上午10.03.46.png" style="zoom:25%;" /></li>
<li>阻塞和唤醒原语应该成对使用。</li>

</ol>
<p>&nbsp;</p>
</li>
<li><p>进程的切换<img src="./assets/OS_b_images//./截屏2022-09-13 上午10.05.24.png" alt="/./截屏2022-09-13 上午10.05.24.png" style="zoom:25%;" /></p>
</li>
<li><p>进城的挂起：</p>
<ol start='' >
<li><p>概念：OS 无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况，此时系统就会表现出<em>性能低</em>和<em>死锁</em>。<img src="./assets/OS_b_images//%E6%88%AA%E5%B1%8F2022-09-16%20%E4%B8%8A%E5%8D%889.03.22.png" alt="/./截屏2022-09-16 上午9.03.22.png" style="zoom:25%;" /></p>
</li>
<li><p>解决方法：剥夺某些进程的内存和资源，调入对换区。</p>
</li>
<li><p>挂起态与等待态有着本质区别：</p>
<ol start='' >
<li>进程挂起：<strong>没有任何资源</strong></li>
<li>进程等待：<strong>占有已申请到的资源处于等待</strong></li>

</ol>
</li>
<li><p>结束挂起状态的命令只能由<strong>操作系统和父进程</strong>发出。</p>
</li>
<li><p>注意到这里挂起进程可能是会有等待时间的，但是等待事件是独立于挂起事件的，即使挂起的时候等待时间也可以正常进行。</p>
</li>

</ol>
</li>
<li><p>进程的唤醒：</p>
<ol start='' >
<li>等待时间完成时产生一个中断，激活操作系统，在系统的控制下将被阻塞进程唤醒。</li>
<li>唤醒原语：唤醒原语：等待队列中移出、修改 PCB、移入就绪队列（该进程优先级高于运行进程触发抢占）。</li>

</ol>
</li>
<li><p>进程的激活</p>
</li>

</ol>
<h3 id='4）进程通信'>（4）进程通信</h3>
<ol start='' >
<li><p>进程通信就是进程之间的信息交换</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是有的时候进程之间的信息交换是需要实现的，所以操作系统提供了方法来保障进程间的安全通信。</p>
</li>
<li><p>进程通信</p>
<ol start='' >
<li><p>共享存储：操作系统在进程的私有空间之外，设立一个共享空间，而两个进程对共享空间的访问是互斥的。</p>
<ol start='' >
<li>基于数据结构的共享：如空间只能放一个10的数组，共享方式速度慢，限制多，是一种<strong>低级通信方式</strong>。</li>
<li>基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放位置都有进程控制而不是OS，相比之下速度更快，是一种<strong>高级通信方式</strong>。</li>

</ol>
</li>
<li><p>管道通信</p>
<ol start='' >
<li>“管道”就是用于连接写进程的一个共享文件（又名pipe文件），其实就是在内存中开辟一个大小固定的缓冲区。</li>
<li>管道只能“半双工通信”，某段时间内只能实现单向传输。如果要同时双向传输，需要两条管道。</li>
<li>各进程应该互斥的访问管道。</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用的调用将被阻塞，等待读进程将数据取走，当读进程被取走以后，管道变空，此时read()系统调用被阻塞。</li>
<li><strong>如果写满，就不能再写，如果读空，就不能再读，如果没有写满，就不允许读，如果没有读空，就不允许写</strong>。</li>
<li>数据一旦被读出，就从管道中抛弃，意味着读进程最多有一个（如果有多个读进程，那个另外的进程可能会错误的读别的进程的数据，而这些被错误读的数据就会被抛弃），否则可能会有读错数据的情况</li>

</ol>
</li>
<li><p>消息传递：进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p>
<ol start='' >
<li>消息头：发送进程ID、接受进程ID、消息类型、消息长度等格式化的消息。</li>
<li>直接通信方式：消息直接挂到接受进程的消息缓冲队列上。</li>
<li>间接通信方式：消息要先发送到中间实体（信箱）中，由接受进程自己在信箱中读取信息，因此也称“信箱通信方式”。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='5）线程'>（5）线程</h3>
<ol start='' >
<li><p>为什么要引入线程：在引入进程之前，系统中的程序只能串行，进程使得程序可以并行，但是进程是程序的一次执行，显然不是一次执行就可以完成的，有的进程可能需要“同时”做很多事情，而传统的进程都只能串行的执行一系列程序，为此引入线程来增加并发性。</p>
<p>线程就是在进程之下的程序的执行流的最小单位，是基本的CPU执行单元。</p>
<p>引入了线程以后，进一步提高系统的并发性，</p>
<p><strong>在线程以后，进程只作为除CPU之外的系统资源分配单元</strong>。</p>
<p><img src="./assets/OS_b_images//./截屏2022-09-15 上午9.42.25.png" alt="/./截屏2022-09-15 上午9.42.25.png" style="zoom:25%;" />
<strong><font color=red>引入线程以后，原本的进程成为了除CPU外资源分配的最小单元，因为不同进程之间的切换是需要改变运行环境的，所以同一个进程中间的线程切换时，就不需要更换运行环境</font></strong></p>
</li>

</ol>
<ol start='2' >
<li>线程的属性<img src="./assets/OS_b_images//./截屏2022-09-15 下午1.31.27.png" alt="/./截屏2022-09-15 下午1.31.27.png" style="zoom:25%;" /></li>

</ol>
<p><font color=blue>注意这里线程几乎不占有系统资源，这是区分线程和进程的重要区别。</font></p>
<ol start='3' >
<li><p>线程的实现方式</p>
<ol start='' >
<li><p>用户级线程</p>
<p><img src="./assets/OS_b_images//./截屏2022-09-15 下午2.19.06.png" alt="/./截屏2022-09-15 下午2.19.06.png" style="zoom:25%;" /></p>
<ol start='' >
<li>用户级线程由应用程序通过线程库实现，所有线程管理工作都由应用程序负责。</li>
<li>用户级线程在用户态下就可以切换，不需要OS去干预，因此<strong>用户级线程的切换OS是看不见的，即用户看来有多个线程，但是OS眼里并看不到线程的存在。</strong></li>

</ol>
</li>
<li><p>内核级线程：内核级线程的管理由操作系统内核完成，线程调度、切换等工作由内核完成，因此需要在内核态下进行切换。</p>
<p><img src="./assets/OS_b_images//./截屏2022-09-15 下午2.49.53.png" alt="/./截屏2022-09-15 下午2.49.53.png" style="zoom:25%;" /></p>
</li>

</ol>
</li>

</ol>
<ol start='3' >
<li><p>在同时支持用户级和内核级的系统中，采用二者结合的方式：将n个用户级线程映射到m个内核级线程上</p>
<p><img src="./assets/OS_b_images//./截屏2022-09-15 下午3.08.31.png" alt="/./截屏2022-09-15 下午3.08.31.png" style="zoom:25%;" />（n&gt;=m)</p>
</li>
<li><p><font color=blue>OS只能看见内核级线程，因此内核级线程才是处理机分配的单位</font></p>
</li>
<li><p>多线程模型：由几个用户级线程映射到几个内核级线程的问题，引出了“多线程模型”问题。</p>
</li>
<li><p>多对一模型：多个用户级线程映射到一个内核级线程。</p>
<ol start='' >
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。</li>
<li>缺点：当一个用户级线程被阻塞以后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行。</li>

</ol>
</li>

</ol>
<ol start='7' >
<li><p>一对一模型：一个对一个，就是变成了纯粹的内核级线程。</p>
<ol start='' >
<li>优点：当一个线程被阻塞以后，别的线程也可以继续执行，并发能力强，多线程可在多核处理机上执行。</li>
<li>缺点：一个用户级进程会占用多个内核级线程，线程切换操作由系统内核完成，需要切换到核心态，因此线程管理的成本高开销大。</li>

</ol>
</li>

</ol>
<ol start='8' >
<li><p>多对多模型：n对m</p>
<ol start='' >
<li>优点：克服了多对一模型并发度不高的缺点和一对一开销大的缺点。</li>

</ol>
</li>

</ol>
<ol start='9' >
<li><p>Jacketing技术：Jacketing的目标是把一个产生阻塞的系统调用转化成一个非阻塞的系统调用。例如,当进程中的一个线程调用IO中断前，先调用一个应用级的I/O jacket例程，而不是直接调用一个系统I/O。让这个jacket例程检查并确定I/O设备是否忙。如果忙，则jacketing将控制权交给该进程的线程调度程序，决定该线程进入阻塞状态并将控制权传送给另一个线程（若无就绪态线程咋可能执行进程切换）。</p>
</li>
<li><p>Solaris多线程技术：引入了轻量级线程，将轻量级线程和内核级线程映射，是混合式线程。<img src="./assets/OS_b_images//28.png" alt="28" style="zoom:25%;" /></p>
<ol start='' >
<li>Process 1：单进程单线程，内核级多线程；</li>
<li>Process 2：单进程双线程，进程映射到两个轻量级线程，相当于用户级多线程；</li>
<li>Process 3：两进程三线程，内核级多线程；</li>
<li>Process 4：两进程两线程，内核级多线程；</li>
<li>Process 5：三进程四线程，混合级线程，直接做指派意味着线程非常重要，需要单独指派。</li>

</ol>
</li>

</ol>
<h3 id='6）处理机调度'>（6）处理机调度</h3>
<ol start='' >
<li><p>基本概念</p>
<p>当有一堆的任务需要处理，但由于资源有限，需要按某种规则来决定处理的顺序，这就是调度要解决的。</p>
</li>
<li><p>高级调度（作业调度）</p>
<ol start='' >
<li>概念：按一定的原则从外存上处于后备队列的作业中选一个或多个作业，给他们分配内存等必要的资源，并建立相应的进程（建立PCB），以使其获得竞争处理机的机会。</li>
<li>高级调度事内外存之间的调度，每个作业只会调入调出一次，调入时创建PCB，调出时撤销PCB。</li>

</ol>
</li>
<li><p>中级调度（内存调度）</p>
<ol start='' >
<li>概念：中级调度就是要决定将那个处于挂起状态的进程重新调入内存。</li>
<li>一个进程可能会多次调入、调出内存，因此会有多次中级调度，中级调度的频率比高级调度高得多。</li>
<li>挂起态与七状态模型<img src="./assets/OS_b_images//./截屏2022-09-16 上午9.13.17.png" alt="/./截屏2022-09-16 上午9.13.17.png" style="zoom:25%;" /></li>

</ol>
</li>

</ol>
<ol start='4' >
<li><p>低级调度（进程调度）</p>
<ol start='' >
<li>概念：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给他。</li>
<li>低级调度是OS最基本的一种调度，一般的操作系统中都必须配置低级调度。</li>
<li>低级调度的频率很高，一般几十毫秒一次。</li>

</ol>
</li>
<li><p>三级调度的对比</p>
<p><img src="./assets/OS_b_images//./截屏2022-09-16 上午9.21.25.png" alt="/./截屏2022-09-16 上午9.21.25.png" style="zoom:25%;" /><img src="./assets/OS_b_images//22.png" alt="22" style="zoom:25%;" /></p>
</li>

</ol>
<h3 id='7）进程调度'>（7）进程调度</h3>
<ol start='' >
<li><p>进程调度的时机</p>
<ol start='' >
<li><p>需要进行进程调度与切换的情况</p>
<ol start='' >
<li>当前运行的进程主动放弃处理机。</li>
<li>当前运行的进程被动放弃处理机。</li>

</ol>
</li>
<li><p>不能进行进程调度与切换的情况</p>
<ol start='' >
<li>在处理中断的过程中。</li>
<li>进程在操作系统<strong>内核程序</strong>临界区中。<font color=red>（为什么在临界区不能切换）</font></li>
<li>在原子操作过程中（原语）。</li>

</ol>
</li>

</ol>
</li>
<li><p>进程调度的方式</p>
<ol start='' >
<li>非剥夺调度方式（非抢占方式）：只允许进程主动放弃处理机，在运行过程中即使有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
<li>剥夺调度方式（抢占方式）：当一个进程在处理机上执行时，如果有一个更重要的进程需要使用处理机，则立即暂停该进程，将处理机分配给更紧急的进程。</li>

</ol>
</li>
<li><p>进程的切换与过程<img src="./assets/OS_b_images//./截屏2022-09-16 上午10.37.37.png" alt="/./截屏2022-09-16 上午10.37.37.png" style="zoom:25%;" /></p>
</li>

</ol>
<h3 id='8）调度算法的评价指标'>（8）调度算法的评价指标</h3>
<ol start='' >
<li><p>CPU利用率：指CPU“忙碌”的时间占总时间的比例，<mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="17.005ex" height="3.447ex" role="img" focusable="false" viewBox="0 -1011.8 7516.2 1523.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.158ex;"><defs><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">利</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">率</text></g><g data-mml-node="mo" transform="translate(2913.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(3969.6,0)"><g data-mml-node="mrow" transform="translate(220,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">忙</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">碌</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(841.3,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="3306.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">利用率=\frac{忙碌的时间}{总时间}</script>。<strong>某些题目会要求计算某些其他设备的利用率</strong></p>
</li>
<li><p>系统吞吐量：单位时间内完成的作业的数量，<mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="23.792ex" height="3.447ex" role="img" focusable="false" viewBox="0 -1011.8 10516.3 1523.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.158ex;"><defs><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">系</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">统</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吞</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">吐</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="mo" transform="translate(4671.2,0)"><use data-c="3D" xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(5727,0)"><g data-mml-node="mrow" transform="translate(220,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><g data-mml-node="mrow" transform="translate(530.7,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">总</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">共</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">所</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="4549.3" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">系统吞吐量=\frac{总共完成作业数}{总共所需时间}</script>。</p>
</li>
<li><p>周转时间：指从作业被提交给系统开始到被完成的时间间隔。<strong>如果作业9:00被提交给系统，9:10获得进入多道程序等待队列，9:30开始执行，10:00结束，那么周转时间就是60分钟，是从作业被提交给程序开始算而不是进入等待队列或者开始执行算。</strong></p>
<p>周转时间包括四个部分：作业在外存后背队列等待调度时间、在就绪队列等待调度时间、CPU执行时间、等待I/O时间，其中后三项在一个作业中可能会发生多次。</p>
<p><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="37.59ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 16615 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-3-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-3-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(3792.5,0)"><use data-c="3D" xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="mtext" transform="translate(4848.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(5727,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(6605.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(7484.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(8363.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(9241.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(10342.7,0)"><use data-c="2212" xlink:href="#MJX-3-TEX-N-2212"></use></g><g data-mml-node="mtext" transform="translate(11342.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(12221.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(13100.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mtext" transform="translate(13978.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mtext" transform="translate(14857.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(15736.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g></g></svg></mjx-container><script type="math/tex">周转时间=作业完成时间-作业提交时间</script></p>
<p><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="28.592ex" height="3.447ex" role="img" focusable="false" viewBox="0 -1011.8 12637.6 1523.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.158ex;"><defs><path id="MJX-4-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(5549.9,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(6605.7,0)"><g data-mml-node="mrow" transform="translate(220,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mtext" transform="translate(6150.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mtext" transform="translate(7029.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(2084,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="5791.9" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">平均周转时间=\frac{各作业周转时间之和}{作业数}</script>，OS会更关心系统的整体表现，因此会更倾向于周转时间的平均值。</p>
<p><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="49.312ex" height="3.447ex" role="img" focusable="false" viewBox="0 -1011.8 21795.9 1523.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.158ex;"><defs><path id="MJX-5-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-5-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(5549.9,0)"><use data-c="3D" xlink:href="#MJX-5-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(6605.7,0)"><g data-mml-node="mrow" transform="translate(841.3,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(220,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(6150.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="5170.6" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(12294.1,0)"><use data-c="3D" xlink:href="#MJX-5-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(13349.8,0)"><g data-mml-node="mrow" transform="translate(220,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(5272.1,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"></use></g><g data-mml-node="mtext" transform="translate(6050.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(6928.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(7807.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">提</text></g><g data-mml-node="mtext" transform="translate(8686.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mtext" transform="translate(9564.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(10443.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(1737.7,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(6150.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="8206" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">带权周转时间=\frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间-作业提交时间}{作业实际运行时间}</script>，带权周转时间必定大于等于1。</p>
<p><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="35.379ex" height="3.447ex" role="img" focusable="false" viewBox="0 -1011.8 15637.6 1523.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.158ex;"><defs><path id="MJX-6-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">平</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">均</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(6150.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(7307.3,0)"><use data-c="3D" xlink:href="#MJX-6-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(8363.1,0)"><g data-mml-node="mrow" transform="translate(220,481.4) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">各</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">带</text></g><g data-mml-node="mtext" transform="translate(3514.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">权</text></g><g data-mml-node="mtext" transform="translate(4393.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(5272.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(6150.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(7029.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mtext" transform="translate(7908.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">之</text></g><g data-mml-node="mtext" transform="translate(8786.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">和</text></g></g><g data-mml-node="mrow" transform="translate(2705.3,-370.3) scale(0.707)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">作</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">业</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g></g><rect width="7034.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}</script></p>
</li>
<li><p>等待时间：指进程/作业处于等待处理机状态时间之和。对进程来说，等待时间就是进程被建立以后等待被服务的时间之和。对作业来说，不仅要考虑建立进程以后的等待时间，还要加上作业在后备队列中的等待时间。</p>
</li>
<li><p>响应时间：指从用户提交请求到首次产生响应的时间。</p>
</li>

</ol>
<h3 id='9）调度算法'>（9）调度算法</h3>
<p><img src="./assets/OS_b_images//./截屏2022-09-17 上午10.31.43.png" alt="/./截屏2022-09-17 上午10.31.43.png" style="zoom:25%;" /></p>
<ol start='' >
<li><p>先来先服务（FCFS）</p>
<ol start='' >
<li>弊端：（1）一个短进程可能不得不等待很长时间才能获得执行，导致吞吐率很难提高，加权中转时间会上升，最差的情况就是计算型死循环，导致完全无法调度。（2）偏袒计算为主的进程：I/O 多的进程不得不等待计算为主的进程做完，因为需要等待资源，离开后需要重新排队。</li>
<li>算法性能较差，不会被现在的系统使用。</li>

</ol>
</li>
<li><p>短作业优先（SPN，shortest process next）：</p>
<ol start='' >
<li><p>一种<strong>非抢占式</strong>调度，会选择处理时间最短的进程，短进程将会越过长进程，优先获得调度，又称为 SJF。</p>
</li>
<li><p>问题：</p>
<ol start='' >
<li>需要预知作业所需的 CPU 运行时间</li>
<li>忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。</li>
<li>分时、实时处理仍然不理想。</li>

</ol>
</li>

</ol>
</li>
<li><p>抢占式短作业优先（SRTN）：在SPF的基础上的并非将一个进程放入处理机就一直处理结束，当进入一个比当前进程更短的进程时，处理机就会切换进程。</p>
<ol start='' >
<li><img src="./assets/OS_b_images//./截屏2022-09-17 下午4.32.57.png" alt="截屏2022-09-17 下午4.32.57" style="zoom:25%;" /></li>
<li><img src="./assets/OS_b_images//./截屏2022-09-17 下午4.35.46.png" alt="/./截屏2022-09-17 下午4.35.46.png" style="zoom:25%;" /></li>

</ol>
</li>
<li><p>高响应比优先（HRRN）：非抢占式算法，性能比SPN略差，每次调度时计算一次当前所有算法响应比最高的。</p>
<ol start='' >
<li>出发点是兼顾公平：长作业在等待过程中响应比会越来越高，时间足够长时长作业也可以获得处理机，解决了饥饿问题。</li>
<li>对短作业有利：等待时间相同时短作业响应比较高。</li>
<li>服务时间相同时等待时间越长响应比越高，类似于FCFS。</li>
<li><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="28.646ex" height="11.249ex" role="img" focusable="false" viewBox="0 -2736 12661.6 4972" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -5.059ex;"><defs><path id="MJX-7-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-7-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-7-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtable"><g data-mml-node="mtr" transform="translate(0,1310)"><g data-mml-node="mtd"></g><g data-mml-node="mtd"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">响</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">应</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">比</text></g><g data-mml-node="mo" transform="translate(2913.8,0)"><use data-c="3D" xlink:href="#MJX-7-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(3969.6,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">等</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">待</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(3737,0)"><use data-c="2B" xlink:href="#MJX-7-TEX-N-2B"></use></g><g data-mml-node="mtext" transform="translate(4737.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">服</text></g><g data-mml-node="mtext" transform="translate(5615.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">务</text></g><g data-mml-node="mtext" transform="translate(6494.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(7373.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(2588.6,-710)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">服</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">务</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="8451.9" height="60" x="120" y="220"></rect></g></g></g><g data-mml-node="mtr" transform="translate(0,-1326)"><g data-mml-node="mtd"></g><g data-mml-node="mtd"><g data-mml-node="mstyle"><g data-mml-node="mspace"></g></g><g data-mml-node="mstyle" transform="translate(2000,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(4000,0)"><use data-c="3D" xlink:href="#MJX-7-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(5055.8,0)"><use data-c="31" xlink:href="#MJX-7-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(5778,0)"><use data-c="2B" xlink:href="#MJX-7-TEX-N-2B"></use></g><g data-mml-node="mfrac" transform="translate(6778.2,0)"><g data-mml-node="mrow" transform="translate(220,676)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">等</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">待</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><g data-mml-node="mrow" transform="translate(220,-710)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">服</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">务</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g></g><rect width="3714.8" height="60" x="120" y="220"></rect></g></g></g></g></g></g></svg></mjx-container><script type="math/tex">\begin{aligned} &响应比 = \frac{等待时间 + 服务时间}{服务时间}\\ &\qquad\qquad = 1 + \frac{等待时间}{服务时间} \\ \end{aligned}</script>.</li>

</ol>
</li>

</ol>
<figure><table>
<thead>
<tr><th>算法</th><th>算法思想</th><th>算法规则</th><th>用于作业/进程调度</th><th>是否可抢占</th><th style='text-align:center;' >优点</th><th>缺点</th><th>是否会导致饥饿</th></tr></thead>
<tbody><tr><td>FCFS</td><td>从“公平”的角度考虑</td><td>按照作业/进程到达的先后顺序服务</td><td>用于作业调度时，考虑哪个作业先到达后备队列；进程调度时，考虑那个进程先到达就绪队列</td><td>非抢占式算法</td><td style='text-align:center;' >公平，算法简单</td><td>在长进程/作业后面的短进程需要等待很长时间，带权周转时间大</td><td>不会</td></tr><tr><td>SPF</td><td>追求更少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</td><td>最短的进程优先服务</td><td>两者皆可</td><td>非抢占式算法，但最短剩余时间优先算法（SRTN）是抢占式的版本</td><td style='text-align:center;' >最短的平均等待时间、平均周转时间</td><td>不公平，对短作业有利长作业不利</td><td>会</td></tr><tr><td>HRRN</td><td>综合考虑等待时间和服务时间</td><td>每次调度时计算响应比，选择响应比最高的</td><td>皆可</td><td>非抢占式</td><td style='text-align:center;' >综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先 （SJF 的优点）要求服务时间相同时，等待时间长的优先 （FCFS 的优点）对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td><td>&nbsp;</td><td>不会</td></tr></tbody>
</table></figure>
<h3 id='10）复杂调度算法'>（10）复杂调度算法</h3>
<ol start='' >
<li><p>时间片轮转（RR）：主要用于分时操作系统。</p>
<ol start='' >
<li>若时间片太大，每个进程都在一个时间片内完成，则算法会退化为FCFS，且用户发出的指令如果在自己的进程的时间片外，则用户的进程需要等待较长的时间才会被响应，增大进程响应时间。</li>
<li>若时间片太小，则进程切换过于频繁，效率低。</li>
<li><font color=red>当采用时间片的方式调度进程时，我们不需要确切的知道进程究竟要执行多久。</font></li>
<li><strong>注意到RR算法在计算过程中，一定要记录好新进入的进程和时间便用完的进入等待队列的时间</strong></li>

</ol>
</li>
<li><p>优先级调度算法：优先级可以分为静态和动态。</p>
</li>
<li><p>优先级选择：系统进程&gt;用户进程，前台进程&gt;后台进程，操作系统会倾向于I/O进程。</p>
<ol start='2' >
<li>动态优先级：从追求公平、提高资源利用率的角度，如果某进程等待时间过久，可以提高优先级，某进程占有处理机过久，降低优先级，某进程频繁使用I/O操作，提高优先级。</li>

</ol>
</li>
<li><p>多级队列调度算法：系统中设置多个就绪队列，每个队列可以设置不同的调度算法，一个队列中的进程又可以分配不同的优先级，以达到综合多种调度策略的目的。</p>
</li>
<li><p><strong>多级反馈队列调度算法</strong>（MLFQ）：将时间片轮转和优先级调度综合。</p>
<ol start='' >
<li><p>思想：</p>
<ol start='' >
<li><p>设置多个就绪队列，并且每个队列设置不同的优先级，<strong>队列编号从0开始</strong>。</p>
</li>
<li><p>给每个队列的进程的时间片大小不同，一般优先级越高时间片越小。</p>
</li>
<li><p>每个队列采用FCFS算法，新进程进入程序后，先放在0级队列的末尾。</p>
</li>
<li><p>当一个进程用光时间片都没有结束时，将它放入原本队列的下一级队列末尾，如果已经在最后一级队列，则仍放在最后一级队列。</p>
</li>
<li><p>仅当第i级队列为空时，才调用i+1队列。</p>
</li>
<li><p>注意点</p>
<ol start='' >
<li>一个进程一旦获得处理机的时间片，只有当这个进程的时间片用光才会被抢占，他已经分配到的时间片是不会被抢占的。</li>
<li>一个进程只有在时间片执行完后中被抢占，即进程用光时间片后另一个进程抢夺了处理机，此时才会将进程放入下一个队列，否则进程继续待在原队列。</li>

</ol>
</li>

</ol>
</li>
<li><p>优势：短作业优先、周转时间短、不会饥饿。</p>
</li>
<li><p>分级原则：外设访问、交互性、时间紧迫程度、系统效率、用户立场。</p>
</li>

</ol>
</li>

</ol>
<figure><table>
<thead>
<tr><th>算法</th><th>算法思想</th><th style='text-align:center;' >算法规则</th><th>用于作业/进程调度</th><th>是否可抢占</th><th>优点</th><th>缺点</th><th>饥饿</th></tr></thead>
<tbody><tr><td>RR</td><td>公平的、轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td><td style='text-align:center;' >按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程为在一个时间片内执行完，则剥夺处理机，将进程重新放入就绪队列。</td><td>用于进程调度</td><td>属于抢占式</td><td>公平；响应快；适用于分时操作系统</td><td>高频率的进程切换有一定开销；不区分任务紧急程度</td><td>不会</td></tr><tr><td>优先级</td><td>根据任务的紧急程度决定处理顺序</td><td style='text-align:center;' >每个作业/进程有自己的优先级，调度时选优先级最高的</td><td>皆可（甚至可用于I/O调度）</td><td>抢占式（低优先级进程未执行完也更换高优先级进程）、非抢占式都有</td><td>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整偏好</td><td>可能会导致饥饿</td><td>会</td></tr><tr><td>多级</td><td>对其他调度算法的平衡</td><td style='text-align:center;' >1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大新进程到达时先进入第0级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时己经是在最下级的队列，则重新放回该队列队尾只有第k级队列为空时，才会为k+1级队头的进程分配时间片</td><td>进程调度</td><td>抢占式，高优先级队列进程抢占低优先级</td><td>对对各类型进程相对公平 （FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）：短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间 （避免用户作假）可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）</td><td>&nbsp;</td><td>会</td></tr></tbody>
</table></figure>
<h3 id='11）进程同步进程互斥'>（11）进程同步、进程互斥</h3>
<ol start='' >
<li><p>并发程序设计：</p>
<ol start='' >
<li><p>程序并发执行是指一组程序的执行在时间上是重叠的，所谓重叠的是指一个程序执行第一条指令是在另一个程序执行完最后一条指令之前开始的。</p>
<ol start='' >
<li>宏观上，并发性反应了一个时间段内有几个程序都处于运行但运行尚未结束的状态。</li>
<li>微观上，任一时刻都只有一个程序在运行。</li>

</ol>
</li>
<li><p>并发实质是处理器在几个程序之间的多路复用，对有限物力资源强制行使多用户共享，消除计算机部件之间的互等现象，提高资源利用率。</p>
</li>
<li><p>并发使得程序失去了封闭性、顺序性、确定性和可再现性。</p>
</li>
<li><p>并发程序设计指一个程序被设计成可以与其他程序并发执行。</p>
</li>

</ol>
</li>
<li><p>进程互斥</p>
<ol start='' >
<li>并发进程之间因相互争夺<strong>独占性资源</strong>而产生的竞争制约关系</li>
<li>一个进程的执行可能影响到同其<strong>竞争资源</strong>的其他进程，如果两个进程要访问同一资源，那么，一个进程通过操作系统分配得到该资源，另一个将不得不等待。</li>
<li>进程互斥是解决进程间<strong>竞争关系（间接制约关系）的手段</strong>。</li>
<li><strong>进程互斥</strong>指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li>

</ol>
</li>
<li><p>进程互斥的问题：</p>
<ol start='' >
<li><p><strong>死锁（Deadlock）问题</strong>： </p>
<ol start='' >
<li><p>一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</p>
</li>
<li><p>临界资源：互斥使用的资源</p>
</li>
<li><p>死锁： 一组进程因争夺资源陷入永远等待的状态</p>
</li>
<li><p>P0 和 P1 两个进程，均需要使用 S 和 Q 两类资源，每类资源数为 1</p>
<ol start='' >
<li>P0：申请（S）→ 申请（Q） → 释放（S）→ 释放（Q）</li>
<li>P1：申请（Q）→ 申请（S） → 释放（Q）→ 释放（S）</li>
<li>以上两个进程互相持有对方的资源的锁，导致无法继续进行。</li>

</ol>
</li>

</ol>
</li>
<li><p><strong>饥饿（Starvation）问题</strong>： 一个进程由于其他进程总是优先于它而被无限期拖延，可以使用 FCFS 来解决饥饿问题。</p>
</li>
<li><p>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题。</p>
</li>

</ol>
</li>
<li><p>进程同步（协作）</p>
<ol start='' >
<li><p>并发进程之间为完成共同任务基于<strong>某个条件</strong>来协调执行先后关系而产生的协作制约关系</p>
</li>
<li><p>某些进程为完成同一任务需要<strong>分工协作</strong>，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上<strong>协调</strong>各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应<strong>阻塞自己</strong>，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行</p>
</li>
<li><p>是解决进程间<strong>协作关系（直接制约关系）的手段</strong>。</p>
</li>
<li><p><strong>进程同步</strong>指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒</p>
</li>
<li><p>同步和异步</p>
<ol start='' >
<li>同步：<strong>等待/阻塞</strong></li>
<li>异步：<strong>不等/平行</strong></li>

</ol>
</li>
<li><p>进程互斥关系是一种特殊的<strong>进程同步</strong>关系，即<strong>逐次使用互斥</strong>共享资源，是对进程使用资源次序上的一种协调</p>
</li>

</ol>
</li>
<li><p>“忙式等待”解决调度问题</p>
<ol start='' >
<li><p>临界区管理的简单方法</p>
<ol start='' >
<li>关中断</li>
<li>测试并建立指令</li>
<li>对换指令</li>
<li>Peterson 算法</li>

</ol>
</li>
<li><p>存在问题</p>
<ol start='' >
<li>对不能进入临界区的进程，采用<strong>忙式等待</strong>测试法，<strong>浪费 CPU 时间</strong></li>
<li>将测试能否进入临界区的责任推给各个竞争的进程会<strong>削弱系统的可靠性</strong>，加重用户编程负担</li>

</ol>
</li>
<li><p>通用的解决方法：信号量与 PV 操作</p>
</li>

</ol>
</li>

</ol>
<h3 id='12）进程互斥的软件实现方法'>（12）进程互斥的软件实现方法</h3>
<ol start='' >
<li><p>临界区管理的三个要求</p>
<ol start='' >
<li>一次之多允许一个进程能够进入临界区执行，在某种情况下可能会突破。</li>
<li>如果已有进程在临界区，其他试图进入的进程应该等待，一个进程不能无限制的等待进入临界区。</li>
<li>一个进程不能无限制的停留在临界区。</li>

</ol>
</li>
<li><p>单标志法（Dekker算法）</p>
<ol start='' >
<li>算法思想：两个进程在访问完临界区以后会把临界区的权限交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予。</li>
<li>主要问题：违背了“空闲让进”的原则。</li>

</ol>
</li>
<li><p>双标志先检查</p>
<ol start='' >
<li>算法思想：设置数组flag，用各个元素表示每个进程想进入临界区的意愿，每个进程进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有则修改自身对应的flag后访问临界区。<strong>如果此时有两个进程同时检查数组并发现没有其他进程有访问意向，则这两个进程有可能会同时修改自身flag，同时访问临界区。</strong></li>
<li>主要问题：违背了“忙则等待”原则。</li>

</ol>
</li>
<li><p>双标志后检查</p>
<ol start='' >
<li>算法思想：基于双标志后检查法，使用先上锁后检查的方法。</li>
<li>主要问题：可能导致死锁，</li>

</ol>
</li>
<li><p>Peterson算法</p>
<ol start='' >
<li><p>算法思想：为每个进程设置一个标志，当标志为 false 时表示该进程要求进入临界区。另外再设置一个指示器turn以指示可以由哪个进程进入临界区，当 turn=i 时则可由进程 Pi 进入临界区。<strong>其中，任意一个进程进入临界区的条件都是其他进程即不在临界区也没有进入临界区的意向。</strong></p>
</li>
<li><p>代码</p>
<pre><code>bool flag[2];
int turn = 0;

Process1
flag[0] = true;
turn = 1;
//when the process1 wants to access the critical section,
//it will switch the turn into another process so that it can let another process to access the critical section first
while(flag[1] &amp;&amp; turn==1);	//process1 is waiting
access the critical section;
flag[0] = false;

Process2
flag[1] = true;
turn = 0;	
while(flag[0] &amp;&amp; turn==0);
access the critical section;
flag[1] = false;
</code></pre>
</li>

</ol>
</li>

</ol>
<h3 id='13）进程互斥的硬件实现方法'>（13）进程互斥的硬件实现方法</h3>
<ol start='' >
<li><p>中断屏蔽方法</p>
<ol start='' >
<li>思想：利用“开/关中断指令”，将临界区的访问原子化，即某进程开始访问临界区到结束访问为止都不允许被中断。</li>
<li>优点：简单、高效。</li>
<li>缺点：不适用于多处理机；只适用于OS内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态）。</li>

</ol>
</li>
<li><p>测试并建立指令（Test and Set，简称TS指令）</p>
<ol start='' >
<li>TS指令是使用硬件实现的，执行的过程不允许中断。</li>
<li>优点：实现简单，无需像软件那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</li>
<li>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会一直占用CPU，进入忙等状态。</li>

</ol>
</li>
<li><p>Swap指令</p>
<ol start='' >
<li>思想：使用硬件实现将两个变量调换数值。</li>
<li>优缺点：逻辑上与TSL相同。</li>

</ol>
</li>

</ol>
<h3 id='14）信号量机制'>（14）信号量机制</h3>
<ol start='' >
<li><p>信号量机制：信号量就是一个变量，可以是整数也可以更复杂的记录型变量，可以用一个信号量来表示系统中的某种资源的数量。</p>
</li>
<li><p>整形信号量</p>
<ol start='' >
<li><p>概念：就是用一个整数型的变量作为信号量来标识系统中的某种资源的数量。</p>
</li>
<li><p>比如，可以使用整数来标识某种资源的数量，然后每一个进程要占用一个资源，就调用wait原语，释放资源就是用signal原语。</p>
<pre><code>viod wait(s){
	while(s &lt;= 0);
	s = s-1;
}

void signal(s){
	s = s+1;
}
</code></pre>
</li>

</ol>
</li>
<li><ol start='3' >
<li>对信号量的操作只有初始化、P操作、V操作三种，同时wait原语检查和上锁同步完成，避免并发、异步。<strong>这里不满足让权等待，会不会出现忙等</strong></li>

</ol>
</li>
<li><p>记录型信号量<strong>（高频）</strong></p>
<ol start='' >
<li>概念：使用记录型数据结构表示信号量。</li>

</ol>
</li>

</ol>
<ol start='2' >
<li><p><img src="./assets/OS_b_images//./截屏2022-09-24 上午10.23.30.png" alt="/./截屏2022-09-24 上午10.23.30.png" style="zoom:25%;" /></p>
<p><strong>注意，这里的阻塞态指的是请求服务的进程，wakeup进程是从信号量的请求队列中唤醒一个排队请求的进程</strong></p>
</li>

</ol>
<ol start='2' >
<li><font color=red>wait(s)和signal(s)原语可以记为P(s)、V(s)，这一对原语用于实现系统资源的申请和释放，同时对信号量的一次P操作就意味着一个进程请求一个该类资源，当s.value&lt;0是表示该类资源已分配完毕，所以此时再申请的进程需要block进行自我阻塞，主动放弃处理机，该机制遵循了<strong>让权等待</strong>原则，避免忙等。</font></li>

</ol>
<h3 id='15）信号量实现进程互斥与同步'>（15）信号量实现进程互斥与同步</h3>
<ol start='' >
<li><p>实现互斥</p>
<ol start='' >
<li>分析并发进程的关键活动，划定临界区；</li>
<li>设置互斥信号量mutex，初值为1；</li>
<li>在临界区之前执行P，之后执行V。</li>
<li><strong>注意：不同的临界资源需要设置不同的互斥信号量。</strong></li>
<li>P、V操作必须成对出现，缺少P就不能保证临界资源的互斥访问。缺少V会导致资源永不被释放，等待进程就不会被唤醒。</li>

</ol>
</li>
<li><p>实现同步（让并发进程有序推进）</p>
<ol start='' >
<li><p>分析什么地方需要实现“同步关系”，既保证“一前一后”执行的两个操作。</p>
</li>
<li><p>设置同步信号量s，初始为0。</p>
</li>
<li><p>在“前操作”之后执行V，在“后操作”之前执行P。</p>
</li>
<li><p><font color=green>一定要注意这里s初始化为0，即表示开始情况下资源不可用，因此V操作可以在P之前执行，表示在进程请求资源之前资源就准备好了。</font></p>
<pre><code>//assuming that fun5 of P2 is based on the result of fun1 and fun2,
//so that we should execute P before fun5 to make sure it won&#39;t work before fun2,
//and execute V after fun2 to wakeup fun5
//if fun2 finishes before fun5,
//so V has made s to be 1 which is inited as 0,
//and when we execute P,
//s is 1 so that the P won&#39;t stop fun5
P1(){
	while(1){
    fun1();
    fun2();
    V(s);
    fun3;
	}
}
P2(){
	while(1){
    fun4();
    P(s);
    fun5();
    fun6();
   }
}
</code></pre>
</li>

</ol>
</li>

</ol>
<ol start='3' >
<li><p>前驱关系</p>
<ol start='' >
<li>实际的系统进程中，进程之间的前驱关系是类似于图的形式，因此我们需要在每一对前驱关系都设置信号量。<img src="./assets/OS_b_images//./截屏2022-09-24 下午3.37.45.png" alt="/./截屏2022-09-24 下午3.37.45.png" style="zoom:25%;" /></li>

</ol>
</li>

</ol>
<h3 id='16）生产者-消费者问题'>（16）生产者-消费者问题</h3>
<ol start='' >
<li>问题描述：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能放入产品，否则必须等待。只有缓冲区不空时，消费者才能取出产品，否则等待。<strong>缓冲区是临界资源，各进程必须互斥的访问</strong></li>
<li><img src="./assets/OS_b_images//./截屏2022-09-24 下午6.53.07.png" alt="/./截屏2022-09-24 下午6.53.07.png" style="zoom:25%;" /></li>

</ol>
<ol start='2' >
<li>示例代码</li>

</ol>
<pre><code>int mutex = 1;
int empty = n;
int full = 0;
producer(){
	while(1){
    produce();
    P(empty);
    P(mutex);
    put the production into the buffer;
    V(mutex);
    V(full);
	}
}

customer(){
	while(1){
    P(full);
    P(mutex);
    get the production from the buffer;
    V(mutex);
    V(empty);
	}
}

//so, can we switch the order of P/V(mutex) and P/V(empty/full) like the following?
producer(){
	while(1){
    produce();
    P(mutex);		//(1)
    P(empty);		//(2)
    put the production into the buffer;
    V(mutex);
    V(full);
	}
}

customer(){
	while(1){
    P(mutex);		//(3)
    P(full);		//(4)
    get the production from the buffer;
    V(mutex);
    V(empty);
	}
}
//ans: if the buffer is full of productions,
//as empty=0 and full=n.
//So the producer will execute (1) and make mutex to 0 and stop itself to wait the buffer be free,
//then switch to the customer.
//The customer will execute (3) but beacause mutex is 0 so that customer will stop to wait the producer to free the mutex.
</code></pre>
<ol start='3' >
<li><font color=orange>实现互斥的P操作一定要在实现同步的P之后，但是V操作不会导致进程阻塞，所以两个V操作顺序可以互换。</font></li>

</ol>
<h3 id='17）多生产者-多消费者问题考点）'>（17）多生产者-多消费者问题<em>（考点）</em></h3>
<ol start='' >
<li><p>描述：多生产/消费者不是指多个，而是多类，即在一个缓冲区中，有多类生产者在生产不同种类的产品，同时不同的消费者也需要不同种类的产品。</p>
</li>
<li><p>方法</p>
<ol start='' >
<li>关系分析：找出各个进程，并分析他们之间的同步、互斥关系。</li>
<li>整理思路：根据各进程的操作流程确定P、V操作的大致顺序。</li>
<li>设置信号量。设置需要的信号量，根据实际情况选定信号量初值（互斥信号量一般为1，同步信号量初始值一般看对应的资源是多少）。</li>

</ol>
</li>
<li><p>互斥信号量在缓冲区等于1的时候可以省略，但是当缓冲区大于1时，缺省互斥信号量可能会导致多生产者覆盖的现象。</p>
</li>
<li><p><img src="./assets/OS_b_images//48.png" referrerpolicy="no-referrer" alt="48"></p>
</li>

</ol>
<h3 id='18）抽烟者进程'>（18）抽烟者进程</h3>
<ol start='' >
<li><p>描述：假设一个系统有3个抽烟者进程和1个供应者进程，每个抽烟者都在不停的卷烟并抽掉，但是卷起一根香烟需要3种材料a、b、c，3个抽烟者每人拥有一种互不相同的材料。供应者无限的提供三种材料并每次将某两种材料放在肘子上，拥有剩下那种材料的抽烟者拿起材料并消耗掉，同时返回供应者一个完成信号，供应者会继续提供另外的两种材料（让三个抽烟者轮流抽烟）。</p>
</li>
<li><p><font color=red>值得注意的是，这里供应者并非是单独的提供材料，我们不该把供应者提供的材料组合看作两种材料，而是供应者在一次提供三种不同的材料组合，三位抽烟者分别需要不同的材料组合。</font></p>
</li>
<li><p>吸烟者问题是为多产品单生产者问题提供了一种解决思路。</p>
</li>
<li><p>如果一个生产者要生产多种产品，或者说会引发多种前驱事件，那么每个V操作应该放在各自对应的事件发生之后的位置。</p>
</li>
<li><p>代码：</p>
<pre><code>int random; //存储随机数
semaphore offer1 = 0; //定义信号量对应烟草和纸组合的资源
semaphore offer2 = 0; //定义信号量对应烟草和胶水组合的资源
semaphore offer3 = 0; //定义信号量对应纸和胶水组合的资源
semaphore finish = 0; //定义信号量表示抽烟是否完成

//供应者
while(1){
    random = 任意一个整数随机数;
    random = random % 3;
    if (random == 0){
        	提供烟草和纸
        	V(offerl); 
    }
    else if (random == 1){
    			提供烟草和胶水
        	V(offer2);
    }
    else{
    		提供纸和胶水;
        V(offer3);
    }
    // 任意两种材料放在桌子上，并等待抽烟者抽烟后将 finish 设置为 1
    P(finish);//抽烟者已经使用完材料，需要继续提供材料
}

//拥有烟草者
while(1){
    P (offer3);
    // 拿纸和胶水，卷成烟，抽掉;
    V(finish);
}

//拥有纸者
while(1){
    P(offer2);
    // 烟草和胶水,卷成烟，抽掉；
    V(finish);
}

//拥有胶水者
while(1){
    P(offer1);
    // 拿烟草和纸，卷成烟，抽掉;
    v(finish);
}


</code></pre>
<p>&nbsp;</p>
</li>

</ol>
<h3 id='19）读者-写者问题'>（19）读者-写者问题</h3>
<ol start='' >
<li><p>描述：有多个读者和写者进程在共享一个文件，当多个读者访问文件时不会产生副作用，但是写者在和其他进程共享文件时就会引发错误。因此要求：（1）允许多个读者同时读文件；（2）只允许一个写者向文件中写信息；（3）任意写者在完成写操作之前不允许其他人访问；（4）写者执行操作之前应该要求其他所有读写者退出。</p>
</li>
<li><p>两类进程：写进程、读进程
互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题。写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。如果所有读者进程在访问共享文件之前都执行 P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。</p>
</li>
<li><p><strong>Key：读者写者问题的核心思想——怎么处理该问题呢？</strong>
P（rw）和V（rw）其实就是对共享文件的“加锁”和“解锁”，既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”让最后一个访问完文件的读进程“解锁”，可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p>
</li>
<li><p>代码一</p>
<pre><code>int rw = 1;
int count = 0;	//recording how many readers are reading the file

writer(){
	while(1){
    P(rw);
    write into the file
    V(rw);
	}
}

reader(){
	while(1){
    if(count == 0)
      P(rw);
    count++;

    read the file

    count--;
    if(count == 0)
      V(rw);
   }
}
</code></pre>
<p><font color=red>问题：当两个读进程并发执行，可能存在两个进程先后执行P（rw）而导致后一个进程阻塞——通过设置互斥变量来保证对count的互斥访问解决。</font></p>
</li>
<li><p>代码二——读者优先</p>
<pre><code>int rw = 1;
int count = 0;	//recording how many readers are reading the file
int mutex = 1;
int z = 1;

writer(){
	while(1){
		P(z);
    P(rw);
    write into the file
    V(rw);
    V(z);
   }
}

reader(){
	while(1){
    P(mutex);
    if(count == 0)
      P(rw);
    count++;
    V(mutex);

    read the file

    P(mutex);
    count--;
    if(count == 0)
      V(rw);
    V(mutex);
	}
}
</code></pre>
<p><font color=green>问题：这种方法下读进程是优先的，因为只要有一个读进程在读，写进程都会被阻塞但是读进程可以执行，因此可能会存在有源源不断的读进程进来导致写进程饿死的情况——引入新的互斥变量让写进程可以封锁读进程。</font></p>
</li>
<li><p>代码三——读写公平</p>
<pre><code>int rw = 1;
int w = 1;
int count = 0;	//recording how many readers are reading the file
int mutex = 1;
int write = 1;

writer(){
	while(1){
    P(w);
    P(rw);
    write into the file
    V(rw);
    V(w);
	}
}

reader(){
	while(1){
    P(w);
    P(mutex);
    if(count == 0)
      P(rw);
    count++;
    V(mutex);
    V(w);

    read the file

    P(mutex);
    count--;
    if(count == 0)
      V(rw);
    V(mutex);
	}
}
</code></pre>
<p><font color=blue>这种方法下，写进程不算是写优点，更多的相似于先来先服务原则，因此又称为”读写公平法“。</font></p>
</li>
<li><p>代码四——写者优先</p>
<pre><code>int rw = 1;
int rcount = 0;	//recording how many readers are reading the file
int wcount = 0;	//recording how many writers want to write the file
int r = w = 1;
int mutex = 1;
int readwait = 1;

writer(){
	while(1){
    P(w);
    wcount++;
    if(wcount == 1)
    	P(rmutex);
    V(w);
    
    P(rw)
    write into the file
    V(rw);
    
    P(w);
    wcount--;
    if(wcount == 0)
    	V(rmutex);
    V(w);
	}
}

reader(){
	while(1){
    P(readwait);
    P(rmutex);
    P(r);
    if(rcount == 0)
      P(rw);
    rcount++;
    V(r);
    V(rmutex);
    V(readwait);
    //这里增加readwait的目的是让reader一次最多只能有一个在等待rmutex信号量
    //使得writer可以封闭多个reader在等待抢占下一个writer的情况。
    //同时当reader在读的时候，写操作之前最多有一个reader在等待
    //因为reader要么在并排读，要么多出来的reader在等待，这里防止多个reader都在等待。

    read the file

    P(r);
    rcount--;
    if(rcount == 0)
      V(rw);
    P(r);
	}
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>读者-写者问题核心思想</p>
<ol start='' >
<li>核心在于设置一个计数器count来记录读进程数量。</li>
<li>注意在对count访问的互斥性处理。</li>
<li>解决写进程饥饿的方法。</li>

</ol>
</li>

</ol>
<h3 id='20）哲学家问题'>（20）哲学家问题</h3>
<ol start='' >
<li><p>一张圆桌上有5位哲学家，桌子上每两位哲学家中间放置一根筷子，每位哲学//家饥饿时会试图拿起左右两根筷子（一根一根的依次拿起）。如果筷子在其他人手上，则需要等待。哲学家进餐完毕后就归还筷子进入思考状态。</p>
</li>
<li><p>分析</p>
<ol start='' >
<li>一共有5个进程，5个进程对其左右的资源访问是互斥的。</li>
<li>只存在互斥关系，但是与之前的问题不同，每个进程只有持有左右两个资源才能开始工作，所以我们需要避免死锁问题。</li>
<li>信号量设置：设置互斥信号量数组chopstick[5]={1,1,1,1,1}，哲学家进程编号为0～4，每个哲学家左边的筷子编号为i，右边的为(i+1)%5。</li>

</ol>
</li>
<li><p>代码一</p>
<pre><code>int chopstick[5] = {1, 1, 1, 1, 1};

Pi(){
	while(1){
    P(chopstick[i]);
    P(chopstick[(i+1)%5]);

    eat;

    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
	}
}
</code></pre>
<p><font color=red>这种方法下，如果每个哲学家都并发的执行，并全部都拿起了自己左手边的筷子，即每个哲学家都占用了一个资源，那么显然这种情况下每个哲学家都在等待自己右边的哲学家放弃筷子而进入死锁状态。</font></p>
<p>思考如何避免死锁的发生：（1）可以每次只允许最多4名哲学家持有筷子，那么这样就至少可以保证一个哲学家能够吃饭；（2）要求偶数号的哲学家先拿左边的筷子，然后再拿右边筷子，而奇数号的哲学家相反。</p>
</li>
<li><p>代码二</p>
<pre><code>int chopstick[5] = {1, 1, 1, 1, 1};
int mutex = 1;	//recording how many process have get a chopstick

Pi(){
	while(1){
		P(mutex);
    P(chopstick[i]);
    P(chopstick[(i+1)%5]);
    V(mutex);

    eat;

    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
	}
}
//In this form of code, one process can get all the chopsticks it need.
</code></pre>
<p>但是这种方法不能保证哲学家只有在两侧的筷子都可用时才会拿起筷子，即使只有一个筷子可用，哲学家也会有先拿起左侧的筷子。</p>
</li>
<li><p>思想：关键在于解决死锁的问题。</p>
</li>

</ol>
<h3 id='21）其他pv问题'>（21）其他PV问题</h3>
<ol start='' >
<li><p>理发师问题</p>
<ol start='' >
<li><p>理发店理有一位理发师、一把理发椅和 n 把供等候理发的顾客坐的椅子。如果没有顾客，理发师便在理发椅上睡觉。一个顾客到来时，它必须叫醒理发师。如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p>
</li>
<li><p>使用 PV 操作求解该问题代码</p>
<pre><code>int waiting=0;//等候理发顾客坐的椅子数
int chaircount=N;//为顾客准备的椅子数
semaphore customers,barbers,mutex;
customers=0;
// 如果没有顾客，理发师便在理发椅上睡觉需要叫醒
barbers=0;
mutex=1;

process barber(){
	while(true){
		理发师睡觉;
		P(customer);
		理发师醒来；
		P(mutex);
		waiting--;
		V(barber);
		V(mutex);
		理发；
	}
}

process customer_i(){
	P(mutex);
	if(waiting &lt; chaircount){
		waiting++;	//注意这里一定要有mutex，因为有多个进程会同时访问waiting参数，需要建立互斥来避免冲突。
		V(customer);
		V(mutex);
		P(barber);
		剪头发；
	}
	else{
		V(mutex);
	}
}
</code></pre>
<p>&nbsp;</p>
</li>

</ol>
</li>
<li><p>农夫猎人问题</p>
<ol start='' >
<li><p>有一个铁笼子，每次只能放入一个动物。猎手向笼中放入老虎，农夫向笼中放入羊；动物园等待取笼中的老虎，饭店等待取笼中的羊。请用 P、V 操作原语写出同步执行的程序。</p>
</li>
<li><p>和苹果-橘子问题没有本质区别。</p>
</li>
<li><p>代码实现：</p>
<pre><code>semaphore cage = 1;
semaphore tiger = 0;
semaphore sheep = 0;

process hunter(){
	while(true){
		P(cage);
		放入老虎;
		V(tiger);
	}
}
process farmer(){
	while(true){
		P(cage);
		放入羊;
		V(sheep);
	}
}
process zoom(){
	while(true){
		P(tiger);
		拿走老虎
		V(cape);
	}
}
process hotel(){
	while(true){
		P(sheep);
		拿走羊;
		V(cape);
	}
}
</code></pre>
</li>

</ol>
</li>
<li><p>银行业务问题</p>
<ol start='' >
<li><p>某大型银行办理人民币储蓄业务，由 n 个储蓄员负责。每个顾客进入银行后先至取号机取一个号，并且在等待区找到空沙发坐下等着叫号。取号机给出的号码依次递增，并假定有足够多的空沙发容纳顾客。当一个储蓄员空闲下来，就叫下一个号。请用信号量和 P，V 操作正确编写储蓄员进程和顾客进程的程序。</p>
</li>
<li><p>代码</p>
<pre><code>int customer = 0;
int server = 0;
semaphore mutex = 1;

process customer_i(){
	取号;
	P(mutex);
	找到沙发坐下；
	P(mutex);
	V(customer);
	处理业务;
	P(server);
}

process server_i(){
	while(true){
		P(customer);
		P(mutex);
		取号呼叫客人;
		V(mutex);
		处理业务;
		V(server);
	}
}
</code></pre>
<p>&nbsp;</p>
</li>

</ol>
</li>
<li><p>独木桥问题</p>
<ol start='' >
<li>东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。</li>
<li>以 3 辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。</li>
<li>重点在于实现交替通过——设计两个mutex=3，每个方向的汽车的通行mutex交给对面方向V，而自己通行的时候P自己的，所以只有对面已经通行过，自己才能V。</li>
<li>代码<img src="./assets/OS_b_images//65.png" alt="65" style="zoom:33%;" /></li>
<li>注意这里countu和countd的设计，分别表示现在桥上正在走几个车和该方向已经走了几辆车。额外设计countd的目的就是记录该方向是否已经走过三辆车，如果已经走过三辆车才V，否则就一直封锁桥直到后面过来的车满足三辆。</li>

</ol>
</li>
<li><p>独木桥问题2</p>
<ol start='' >
<li>东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。</li>
<li>要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。</li>
<li>如果没有条件2，那么这个问题就和多读者/多写者同时读写的代码一样，此时就需要设置新的信号量stop来封锁对面的车辆进入临界区去增加对面车辆的count，这样就可以避免对面后续到来的车辆上桥。</li>
<li>代码<img src="./assets/OS_b_images//66.png" alt="66" style="zoom:50%;" /></li>

</ol>
<p>&nbsp;</p>
</li>

</ol>
<h3 id='22）管程'>（22）管程</h3>
<ol start='' >
<li><p>为什要引入管程：在引入管程之前，人们实现进程互斥依赖于信号量机制，但是信号量机制编者程序困难、易出错。因此人们考虑通过管程来让程序员不需要关注复杂的PV操作。</p>
<p>管程试图<strong>抽象</strong>相关并发进程对<strong>共享变量</strong>访问，以提供一个友善的并发程序设计开发环境。</p>
</li>
<li><p>管程由若干公共（共享）变量及其说明和所有访问这些变量的过程所组成</p>
<ol start='' >
<li>管程的局部变量只能由该管程的过程读取</li>
<li>把分散在各进程中的临界区集中起来进行管理</li>

</ol>
</li>
<li><p>定义：管程是由局部于自己的若干公共（共享）变量及其说明和所有访问这些公共变量的过程所组成的软件模块，由以下部分组成：</p>
<ol start='' >
<li>局部于管程的共享数据结构说明；</li>
<li>对该数据结构进行操作的一组过程；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字。</li>

</ol>
<p>管程与class有部分相似</p>
</li>
<li><p>管程的属性：</p>
<ol start='' >
<li>共享性：管程中的移出过程可被所有调用管程的过程的进程所共享</li>
<li>安全性：管程的局部变量只能由此管程内部分访问，不允许进程或其他管程直接访问。</li>
<li>互斥性：任一时刻，共享资源的进程可以访问管程中的管理此资源的过程，但最多只有一个调用者能够真正进入管程，其他调用者必须等待直到管程可用。</li>

</ol>
</li>
<li><p>基本特征</p>
<ol start='' >
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的进程才能进入管程访问共享数据；</li>
<li>防止进程有意或无意的<strong>违法同步</strong>操作，进程只能互斥地调用管程中的过程。</li>
<li>便于用<strong>高级语言</strong>来书写程序</li>

</ol>
</li>
<li><p>管程的形式</p>
<pre><code>type 管程名=monitor{
   局部变量说明;
   条件变量说明;
   初始化语句;
   define 管程内定义的，管程外可调用的过程或函数名列表;
   use 管程外定义的，管程内将调用的过程或函数名列表;

   过程名/函数名(形式参数表) {
      &lt;过程/函数体&gt;;
   }

   过程名/函数名(形式参数表) {
      &lt;过程/函数体&gt;;
   }
}
</code></pre>
<p><a href='./assets/OS_b_images//https://eaglebear2002.github.io/2022Fall-计算机与操作系统/06-并发程序设计/67.png'><img src="./assets/OS_b_images//67.png" alt="img" style="zoom:25%;" /></a></p>
<p>&nbsp;</p>
</li>
<li><p>管程的条件变量</p>
<ol start='' >
<li><p>当资源不足导致进程阻塞时，同时开放管程，让挡在管程外的一个进程进入管程。</p>
</li>
<li><p>条件变量：是出现在管程内的一种数据结构，且只有在管程中才能被访问，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它，用于阻塞进程的信号量。</p>
<ol start='' >
<li><p>wait()：当一个管程过程发现无法继续时（如发现没有可用资源时），它在某些条件变量上执行 <code>wait</code>，这个动作引起调用进程阻塞，直到另一个进程在该条件变量上执行<code>signal</code>。</p>
</li>
<li><p>signal()：</p>
<ol start='' >
<li>如果存在其他进程由于对条件变量执行 <code>wait</code> 而被阻塞，便释放之。</li>
<li>如果没有进程在等待，那么信号不被保存，并不是立即退出管程等待队列，而是进入 next 信号量，以保证多个进程都可以正常退出。</li>

</ol>
</li>
<li><p>条件变量仅仅维护阻塞队列的作用，如果没有等待时发生 <code>signal</code> 操作，相当于空操作。</p>
</li>

</ol>
</li>
<li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内。解决方法：</p>
<ol start='' >
<li><strong>执行 <code>signal</code> 的进程等待，直到被释放进程退出管程或等待另一个条件</strong></li>
<li>被释放进程等待，直到执行 <code>signal</code> 的进程退出管程或等待另一个条件</li>

</ol>
</li>
<li><p>霍尔（Hoare, 1974）采用第一种办法</p>
</li>
<li><p>汉森（Hansen）选择两者的折衷，规定管程中的过程所执行的<code>signal</code> 操作是过程体的最后一个操作</p>
</li>

</ol>
</li>
<li><p>Hoare方法</p>
<ol start='' >
<li><p>霍尔方法使用 P 和 V 操作原语来实现对管程中过程的互斥调用，及实现对共享资源互斥使用的管理</p>
</li>
<li><p>不要求 <code>signal</code> 操作是过程体的最后一个操作，且 <code>wait</code> 和 <code>signal</code> 操作可被设计成可以中断的过程</p>
</li>
<li><p>使用 <code>signal</code> 释放一个等待进程时，霍尔管程让执行 <code>signal</code> 的进程等待，直到<strong>被释放进程退出管程或等待另一个条件</strong></p>
</li>
<li><p>霍尔管程基于 PV 操作原语实现：</p>
<ol start='' >
<li><code>wait</code> 和 <code>signal</code> 可以是程序过程</li>
<li>可以用语言机制实现霍尔管程</li>

</ol>
</li>

</ol>
</li>
<li><p>例子1：用管程解决生产者消费者问题<img src="./assets/OS_b_images//./截屏2022-09-27 下午3.30.01.png" alt="/./截屏2022-09-27 下午3.30.01.png" style="zoom:25%;" /></p>
</li>
<li><p>引入管程的目的就是为了更方便的实现进程互斥和同步：</p>
</li>
<li><p>需要在管程中定义共享数据；</p>
</li>
<li><p>需要在管程中定义访问这些共享数据的入口；</p>
</li>
<li><p>只能通过这些入口来访问共享数据；</p>
</li>
<li><p>管程中可能有多个入口，但是每次只能开放一个入口并且只能允许一个进程或线程进入；</p>
</li>
<li><p>可以在管程中设置条件变量及等待/唤醒操作以解决同步问题。</p>
</li>
<li><p>java与管程：Java中，关键字synchronized修饰的函数，同一时间段内只能被一个线程调用。</p>
</li>
<li><p>Hoare管程</p>
<ol start='' >
<li><p>霍尔方法使用 P 和 V 操作原语来实现对管程中过程的互斥调用，及实现对共享资源互斥使用的管理不要求 <code>signal</code> 操作是过程体的最后一个操作，且 <code>wait</code> 和 <code>signal</code> 操作可被设计成可以中断的过程。使用 <code>signal</code> 释放一个等待进程时，霍尔管程让执行 <code>signal</code> 的进程等待，直到被释放进程退出管程或等待另一个条件。</p>
</li>
<li><p>霍尔管程基于 PV 操作原语实现：</p>
<ol start='' >
<li><code>wait</code> 和 <code>signal</code> 可以是程序过程</li>
<li>可以用语言机制实现霍尔管程</li>

</ol>
</li>
<li><p>&nbsp;</p>
</li>

</ol>
</li>

</ol>
<h3 id='23）死锁'>（23）死锁</h3>
<ol start='' >
<li><p>概念：各进程互相等待对方手里的资源，导致各进程阻塞，无法向前推进的情况。</p>
</li>
<li><p>饥饿：若有源源不断的进程到来，使得某个长进程一直得不到处理机的情况，导致长进程饥饿。</p>
</li>
<li><p><img src="./assets/OS_b_images//./截屏2022-09-27 下午7.21.09.png" alt="/./截屏2022-09-27 下午7.21.09.png" style="zoom:25%;" /></p>
</li>
<li><p>死锁产生的必要条件：</p>
<ol start='' >
<li>互斥条件：只有对必须互斥使用的资源争抢才会导致死锁。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前不能有其他资源抢夺，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但是又提出了新的资源请求，而该资源又被其它进程占有，导致请求进程被阻塞，但是自己持有的资源又不会被释放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。<font color=yellow>循环等待链出现不代表会出现死锁，一个等待环上可能有其他支链，这些支链能使得这个环解锁</font></li>

</ol>
</li>
<li><p>什么时候会发生死锁——对不可剥夺资源的不合理分配</p>
<ol start='' >
<li>对系统资源的竞争</li>
<li>进程推进顺序非法</li>
<li>信号量使用不当</li>

</ol>
</li>
<li><p>死锁的处理策略</p>
<ol start='' >
<li>预防死锁：破坏死锁的四个必要条件。</li>
<li>避免死锁：是用某种方法阻止系统进入不安全状态。——银行家算法</li>
<li>死锁的检测和解除：允许死锁的发生，但是系统会检测死锁并采取某种方式接触死锁。</li>

</ol>
</li>

</ol>
<h3 id='24）预防死锁'>（24）预防死锁</h3>
<ol start='' >
<li><p>破坏互斥条件</p>
<ol start='' >
<li>如果把只能互斥使用的资源改为允许共享使用，则系统就不会进入死锁状态，比如SPOOLing技术。</li>
<li>缺点：并不是所有资源都可以被改造成可共享使用的资源。并且很多地方为了系统安全还需要保护这种互斥性，因此很多时候无法破坏互斥条件。</li>

</ol>
</li>
<li><p>破坏不剥夺条件</p>
<ol start='' >
<li><p>当一个进程请求新的资源得不到满足时，他就必须立即释放保持的所有资源。</p>
</li>
<li><p>当某个进程需要的资源被其它进程占有时，可以由OS协助强行剥夺。</p>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>实现复杂。</li>
<li>释放已获得的资源可能会导致前一阶段的工作失效，只适用于易保存和易恢复的进程。</li>
<li>反复的申请和释放会增加系统开销，降低系统吞吐量。</li>
<li>同时，方案一可能会导致某个进程一直在不停地放弃已获得的资源导致进程饥饿。</li>

</ol>
</li>

</ol>
</li>
<li><p>破坏请求和保持条件</p>
<ol start='' >
<li>使用静态分配方法，即在进程运行之前一次性申请所有的资源。</li>
<li>缺点：资源利用率极低，也可能会导致某些进程饥饿。</li>

</ol>
</li>
<li><p>破坏循环等待条件</p>
<ol start='' >
<li><p>采用顺序资源分配法，即对系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p>原理：一个进程只有已经占有小编号的资源才能申请大编号资源，而已占有大编号资源的进程不会逆向申请小编号资源从而不会产生循环等待的现象——&gt;必然会存在一个占有最大编号资源的进程可以成功申请资源。</p>
</li>
<li><p>缺点：不方便增加新的设备；进程实际使用顺序与深编号申请顺序不一致就会导致资源浪费；必须按照次序申请资源，用户编程麻烦。</p>
</li>

</ol>
</li>

</ol>
<h3 id='25）避免死锁'>（25）避免死锁</h3>
<ol start='' >
<li><p>安全序列：如果系统按照一个安全序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态（安全序列可能有多个）。</p>
<p><strong>系统处于安全状态，就一定不会发生死锁，但是处于不安全状态，未必会发生死锁。</strong></p>
</li>
<li><p>银行家算法</p>
<ol start='' >
<li><p>核心思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
</li>
<li><p>算法：假设系统中有n个进程m种资源，则每个进程在运行前先声明对各种资源的最大需求量。则可以用两个n*m的矩阵Max、Allocation分别表示进程对资源的最大需求量和目前已拥有需求量。则Max-Allocation=Need就可以表示个进程还需要多少资源。另外，用一个长度为m的向量Available表示当前系统中还有多少可用资源。某进程Pi请求资源就使用Request表示申请的资源量。</p>
<p>运行方式：</p>
<ol start='' >
<li>如果Request[ i ] [ j ] &lt;= Need[ i ] [ j ]则转向2，否则认为出错。</li>
<li>如果Request[ i ] [ j ] &lt;= Available[ i ] [ j ]则转向3.，否则认为无足够资源，Pi必须等待。</li>
<li>系统试探着把资源分配给Pi，并修改相应数据（并非真的分配，修改数值是为了做判断）。</li>

</ol>
</li>

</ol>
</li>
<li><p><img src="./assets/OS_b_images//./截屏2022-09-29 上午9.32.24.png" alt="/./截屏2022-09-29 上午9.32.24.png" style="zoom:25%;" /></p>
</li>

</ol>
<h3 id='26）死锁的检测和解除'>（26）死锁的检测和解除</h3>
<ol start='' >
<li><p>死锁的检测</p>
<ol start='' >
<li><p>使用某种数据结构来保存资源的请求和分配信息。</p>
</li>
<li><p>提供一种算法，利用上述信息来检测系统是否进入死锁状态。</p>
</li>
<li><p>数据结构：资源分配图<img src="./assets/OS_b_images//./截屏2022-09-29 上午9.35.45.png" alt="/./截屏2022-09-29 上午9.35.45.png" style="zoom:25%;" /></p>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程。如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）。如果最终不能消除所有边，那么此时就是发生了死锁。最终还连着边的那些进程就是处于死锁状态的进程。</p>
</li>
<li><p>检测死锁的算法</p>
<ol start='' >
<li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之成为孤立的结点。</li>
<li>进程pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。根据1中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
<li>要注意到，即使死锁发生，也不是所有的进程都是死锁进程，用检测算法简化资源分配图以后，还连着边的进程就是死锁进程。</li>

</ol>
</li>
<li><p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p>
</li>

</ol>
</li>
<li><p>解除死锁</p>
<ol start='' >
<li>资源剥夺法：挂起那些死锁进程，并抢占他的资源，将这些资源分配给其他的死锁进程。但是要防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销/终止进程法：强制撤销部分、甚至全部的死锁进程，并剥夺资源。这种方法的优点是简单，但是代价较大（有些进程可能运行时间较长，被终止就意味着放弃之前的任务）。</li>
<li>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步——要求系统记录进程历史信息，设置还原点。</li>
<li>如何决定操作哪个死锁进程：进程优先级；已执行时间；还需要的执行时间；进程已使用资源；进程是交互式还是批处理式（交互式进程大多于用户有关，倾向于解除批处理式）。</li>

</ol>
</li>

</ol>
</body>
</html>