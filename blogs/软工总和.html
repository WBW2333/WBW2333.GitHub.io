<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软工总和</title>
</head>
<body><h1 id='软工-第一部分-软件工程概论'>软工-第一部分-软件工程概论</h1>
<p><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="101.092ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 44682.7 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-1-TEX-N-21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">概</text></g><g data-mml-node="mtext" transform="translate(878.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">念</text></g><g data-mml-node="mtext" transform="translate(1757.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">基</text></g><g data-mml-node="mtext" transform="translate(2636.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">础</text></g><g data-mml-node="mo" transform="translate(3792.5,0)"><use data-c="21D2" xlink:href="#MJX-1-TEX-N-21D2"></use></g><g data-mml-node="mtext" transform="translate(5070.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mtext" transform="translate(5949,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">求</text></g><g data-mml-node="mtext" transform="translate(6827.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mtext" transform="translate(7706.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">析</text></g><g data-mml-node="mi" transform="translate(8585.1,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mtext" transform="translate(9463.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mtext" transform="translate(10342.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(11221.1,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(12377.6,0)"><use data-c="21D2" xlink:href="#MJX-1-TEX-N-21D2"></use></g><g data-mml-node="mtext" transform="translate(13655.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">体</text></g><g data-mml-node="mtext" transform="translate(14534,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">系</text></g><g data-mml-node="mtext" transform="translate(15412.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">结</text></g><g data-mml-node="mtext" transform="translate(16291.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">构</text></g><g data-mml-node="mi" transform="translate(17170.1,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mtext" transform="translate(18048.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mtext" transform="translate(18927.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(19806.2,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(20962.6,0)"><use data-c="21D2" xlink:href="#MJX-1-TEX-N-21D2"></use></g><g data-mml-node="mtext" transform="translate(22240.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">详</text></g><g data-mml-node="mtext" transform="translate(23119.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">细</text></g><g data-mml-node="mtext" transform="translate(23997.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">设</text></g><g data-mml-node="mtext" transform="translate(24876.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">计</text></g><g data-mml-node="mi" transform="translate(25755.2,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mtext" transform="translate(26633.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">超</text></g><g data-mml-node="mtext" transform="translate(27512.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">级</text></g><g data-mml-node="mtext" transform="translate(28391.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mtext" transform="translate(29269.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(30148.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(31305.1,0)"><use data-c="21D2" xlink:href="#MJX-1-TEX-N-21D2"></use></g><g data-mml-node="mtext" transform="translate(32582.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">构</text></g><g data-mml-node="mtext" transform="translate(33461.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">造</text></g><g data-mml-node="mtext" transform="translate(34340.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">测</text></g><g data-mml-node="mtext" transform="translate(35218.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">试</text></g><g data-mml-node="mi" transform="translate(36097.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mtext" transform="translate(36976.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">重</text></g><g data-mml-node="mtext" transform="translate(37855,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(38733.7,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(39890.1,0)"><use data-c="21D2" xlink:href="#MJX-1-TEX-N-21D2"></use></g><g data-mml-node="mtext" transform="translate(41167.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">交</text></g><g data-mml-node="mtext" transform="translate(42046.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">付</text></g><g data-mml-node="mtext" transform="translate(42925.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">演</text></g><g data-mml-node="mtext" transform="translate(43804,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">化</text></g></g></g></svg></mjx-container><script type="math/tex">概念基础\Rightarrow 需求分析（重点）\Rightarrow 体系结构（重点）\Rightarrow 详细设计（超级重点）\Rightarrow 构造测试（重点）\Rightarrow 交付演化</script></p>
<h2 id='一软件工程基础'>一、软件工程基础</h2>
<h3 id='1）软件'>（1）软件</h3>
<ol start='' >
<li><p>早期软件是作为计算机硬件的零件来开发的，20世纪50年代中后期开始加算计硬件开始进入商业，<strong>软件开始独立于硬件</strong>。软件的核心逻辑是将现实世界的复杂信息建模成（基于数学的）计算模型，利用计算机的超强计算能力和信息处理（主要是储存、传输和共享）能力，解决人无法完成的任务，应用软件表现为计算和信息处理的工具。</p>
</li>
<li><p>软件的核心是程序，通过程序的编写逻辑来完成计算和信息处理。程序的编写逻辑不同，完成的计算和信息处理也不同，所以程序是作为计算和信息处理工具的软件的核心。</p>
</li>
<li><p>软件由三个部分组成：</p>
<ol start='' >
<li>程序，机器指令的集合。</li>
<li>文档，描述程序操作与使用的文档。</li>
<li>数据，程序运行时需要使用的信息。</li>

</ol>
</li>

</ol>
<h3 id='2）软件工程'>（2）软件工程</h3>
<ol start='' >
<li><p><strong>软件工程的定义</strong>：</p>
<ol start='' >
<li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</li>
<li>对1中各种方法的研究。</li>

</ol>
</li>
<li><p>软件工程是一种工程活动，具有工程学科的特性：</p>
<ol start='' >
<li>具有解决实际问题的动机。</li>
<li>应用科学知识指导工程活动。</li>
<li>以成本效益比有效为基本条件。</li>
<li>构建机器或事物。</li>
<li>以服务人类为最终目的。</li>

</ol>
</li>
<li><p>软件工程要解决的实际问题通常是模糊不清的，需要在开发开始就得到澄清和明确。比如汽车设计师不需要考虑汽车是否有轮子或者发动机，但是软件工程师却不知道，软件开发的问题大多是模糊的，这要求工程师在构架软件之前就要澄清要解决的问题，明确项目的目标。如果想要忽略这个阶段，就可能会围绕错误的问题开展工作，导致徒劳无功。</p>
</li>
<li><p>工程学科的演化过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-19%20%E4%B8%8B%E5%8D%881.58.09.png" referrerpolicy="no-referrer" alt="截屏2023-07-19 下午1.58.09"></p>
</li>
<li><p>软件工程以成本效益比有效为生产的成功条件，成本是软件开发的耗费，效益是客户为了得到软件产品愿意付出的费用。同时实际生产中可能会有多个满足成本效益比的方案，这些方案都是有效的，<em>软件工程不追求最好只追求够好</em>。为了保证成本效益比，工程师一方面要在生产之前进行可行性分析，避免成本效益比失效，另一方面要估算和控制重要生产活动的成本，保持总生产成本低于总效益。</p>
</li>
<li><p>软件工程的最终目的不仅仅是为具体的用户服务，而是承担社会责任，促进整个社会的进步。</p>
</li>
<li><p>软件开发是软件工程的主要任务，包括需求开发、软件设计、软件构造、软件测试、软件交付与维护等具体活动。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-19%20%E4%B8%8B%E5%8D%882.16.31.png" referrerpolicy="no-referrer" alt="截屏2023-07-19 下午2.16.31"></p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二软件工程的发展'>二、软件工程的发展</h2>
<figure><table>
<thead>
<tr><th>&nbsp;</th><th>基础环境（虚拟计算机、主要的抽象软件实体）</th><th>主要现实问题</th><th>主要指导思想</th><th>软件开发方法与技术</th><th>软件开发过程</th><th>重要思想</th><th>特点总结</th></tr></thead>
<tbody><tr><td>50s</td><td>研究用大型机，基于BIOS或直接基于硬件编程<br>面向语句语言出现</td><td><em>以科学计算为中心</em><br>科学研究用机器为中心，解决科学计算的问题</td><td>最大化硬件性能</td><td>人们精力集中在硬件，没有针对软件的技术</td><td>软件被认为是硬件的零件，制造软件和制造硬件是一样的</td><td>重视产品质量，进行评审和测试</td><td>科学计算；以机器为中心编程；像生产硬件一样生产软件</td></tr><tr><td>60s</td><td>商业大型机得到大量使用<br>提供了函数机制、更好的类型系统和数据结构化</td><td><em>科学计算-&gt;业务应用</em><br>需要数据处理计算较多的业务应用，以应用为中心</td><td>保证程序的正确、清晰、质量和软件生产的成功</td><td>前期工艺式开发，后期修补有缺陷的代码，依赖程序员个人能力</td><td>“构件-修复”</td><td>软件不同于硬件（为什么不同于硬件？）<br>避免工艺式生产</td><td>业务应用（批量数据处理和事务计算）；软件不同于硬件；用软件工艺的方式生产软件</td></tr><tr><td>70s</td><td>商业微型机开始出现，开始需求购买软件，催生了DBMS系统<br>结构化程序设计理论</td><td><em>更可靠的生产力</em><br>软件产品的需求和复杂度都大大增加，认识到软件的重要地位</td><td>保证复杂软件系统开发的成功<br>解决复杂软件系统的复杂性</td><td>广泛使用结构化编程方法<br>控制系统复杂度，强调“低耦合高内聚”</td><td>简单规划接着编码<br>瀑布模型</td><td>越早发现和修复问题，代价越低</td><td>结构化方法；瀑布模型；强调规则和纪律（奠定了软工基础）</td></tr><tr><td>80s</td><td>PC开始普及，GUI出现<br>面向对象编程方法；信息隐藏</td><td><em>软件的需求和数量暴涨</em><br>更多的业务应用，复杂软件的成本增高</td><td>提高软件生产力<br>越来越倾向于维护来延长软件寿命</td><td>结构化方法<br>面向对象编程<br>软件复用</td><td>过程模型<br>过程评价<br>使用工具支持软件开发过程</td><td>“没有银弹”<br>重视人的作用</td><td>追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用</td></tr><tr><td>90s</td><td>Inernet的发展，网络软件<br>网络操作系统<br>中间件平台</td><td><em>业务应用的规模持续增大</em><br>大规模软件系统体量过大，软件产品需求爆炸性增长</td><td>Web技术发展，面向大众消费的产品——Web应用<br>继续向软件维护倾斜<br>特定领域软件工程方法</td><td>面向对象方法<br>软件体系结构<br>人机交互<br>需求工程<br>基于软件复用的大规模软件系统开发技术<br>Web开发技术</td><td>过程模型<br>过程改进<br>开源软件</td><td>重视最佳实践方法</td><td>企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；Web应用出现</td></tr><tr><td>00s</td><td>Internet持续发展，嵌入式设备和移动终端普及<br>规格化面向对象，发布UML2.0</td><td>基于Internet的Web应用成为主流<br>面向大众的软件产品需求暴增</td><td>&nbsp;</td><td>延续90s的技术<br>Web技术发展<br>领域特定的软件工程方法</td><td>敏捷方法<br>外包的开发方法</td><td>&nbsp;</td><td>大规模Web应用；追求快速开发；可变更性；用户价值以及创新</td></tr></tbody>
</table></figure>
<ol start='' >
<li><p>开源：将软件的源代码公开并置于人们可以访问的地方，允许任何人在不支付版权费的情况下复制和传播源代码。</p>
</li>
<li><p>习题（答案来自于chatGPT）</p>
<ol start='' >
<li><p>硬件的发展是如何影响软件工程发展的？</p>
<ol start='' >
<li>性能提升：随着硬件的发展，计算机的处理能力、存储容量和网络带宽等方面都得到了显著提升。这使得软件工程师能够设计和开发更加复杂、功能更强大的软件系统。</li>
<li>并行计算和分布式系统：硬件发展推动了并行计算和分布式系统的兴起。软件工程师需要学习并发编程和设计分布式系统，以充分利用多核处理器和分布式计算资源。</li>
<li>移动和嵌入式设备：硬件的发展使得移动设备和嵌入式系统的普及。软件工程师需要适应这些不同的平台和设备，开发相应的移动应用和嵌入式软件。</li>
<li>物联网（IoT）：随着硬件的发展，越来越多的设备连接到互联网，构成了物联网。软件工程师需要开发和管理与物联网相关的软件系统，涉及传感器、设备通信、数据分析等方面。</li>

</ol>
</li>
<li><p>系统软件的发展是如何影响软件工程发展的？</p>
<ol start='' >
<li>操作系统和编程语言：系统软件的发展推动了操作系统和编程语言的演进。更先进的操作系统提供了更好的资源管理和抽象层，而新的编程语言提供了更高级的抽象和编程模型，使得软件开发更高效和可靠。</li>
<li>开发工具和框架：系统软件的发展带来了更强大的开发工具和框架，如调试器、集成开发环境（IDE）、代码库和开发框架等。这些工具和框架提供了更好的开发效率和质量保证。</li>

</ol>
</li>
<li><p>计算机科学是如何影响软件工程发展的？</p>
<ol start='' >
<li>算法和数据结构：计算机科学的研究为软件工程带来了各种算法和数据结构，用于解决复杂的计算问题。软件工程师需要了解和应用这些算法和数据结构，以提高软件系统的性能和效率。</li>
<li>软件开发方法论：计算机科学研究提供了软件开发的方法论和最佳实践，如面向对象编程、结构化编程、测试驱动开发（TDD）、敏捷开发等。这些方法论帮助软件工程师更好地组织和管理软件项目。</li>

</ol>
</li>
<li><p>软件开发的方法与技术是如何演化的？</p>
<ol start='' >
<li>瀑布模型：早期的软件开发采用瀑布模型，按照线性顺序执行各个开发阶段，如需求分析、设计、编码、测试等。</li>
<li>迭代和增量开发：随后出现了迭代和增量开发方法，将开发过程分成多个阶段，并在每个阶段中进行反馈和迭代，逐步完善软件系统。</li>
<li>敏捷开发：近年来，敏捷开发方法兴起，强调快速响应需求变化、灵活合作和持续交付。敏捷方法提倡自组织团队、迭代开发和持续反馈。</li>

</ol>
</li>
<li><p>软件开发过程是如何演化的？</p>
<ol start='' >
<li>个人英雄主义：早期的软件开发过程往往依赖个人英雄主义，即依赖个别开发者的技术和经验。</li>
<li>团队合作：随着软件项目的复杂性增加，团队合作变得更为重要。团队成员之间的协作和沟通成为软件开发过程中的关键。</li>
<li>分布式开发：随着团队分布在不同地理位置的趋势，分布式开发变得普遍。远程协作工具和实践的发展帮助团队在全球范围内开展软件开发工作。</li>

</ol>
</li>
<li><p>软件工程对 “人”的看法是如何演化的？</p>
<ol start='' >
<li>早期视角：早期的软件工程更注重技术和工具，对人的角色和影响较少关注。</li>
<li>用户中心：随着用户体验和用户需求的重要性的认识提高，软件工程开始将用户置于核心位置，并注重人机交互和用户参与。</li>

</ol>
</li>
<li><p>不同时代的软件工程产品有哪些不同？</p>
<ol start='' >
<li>早期产品：早期的软件工程产品主要是基于桌面计算机的应用软件，如文本编辑器、数据库系统和操作系统等。</li>
<li>Web 应用：随着互联网的兴起，Web 应用成为主要的软件工程产品，包括网站、电子商务平台和社交媒体等。</li>
<li>移动应用：移动设备的普及带来了移动应用的繁荣，包括手机应用、平板电脑应用和物联网应用等。</li>

</ol>
</li>
<li><p>软件开发的主导思想是如何演化的？</p>
<ol start='' >
<li>面向过程：早期的软件开发主要以过程为中心，强调算法和代码的实现。</li>
<li>面向对象：面向对象编程思想的兴起将重点放在对象和类的设计、封装和继承上，提供了更好的抽象和模块化。</li>
<li>函数式编程：函数式编程思想强调纯函数和无状态，具有更好的可维护性和并发性。</li>

</ol>
</li>
<li><p>查询网络资料，试着猜想一下软件工程未来几年的发展会有哪些特点。</p>
<ol start='' >
<li>人工智能和机器学习的应用将得到更广泛的应用，以提高软件系统的自动化和智能化能力。</li>
<li>物联网的发展将促使软件工程师更多地参与物联网设备和系统的开发，涉及传感器、通信和数据处理等方面。</li>
<li>敏捷和DevOps方法将进一步演化和普及，以更好地满足快速变化的需求和快速交付的要求。</li>
<li>安全和隐私保护将成为更重要的关注点，软件工程师需要更加注重软件系统的安全性和用户数据的保护。</li>
<li>自动化测试和持续集成将继续发展，以提高软件质量和开发效率。</li>

</ol>
</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h1 id='软工-第二部分-项目启动'>软工-第二部分-项目启动</h1>
<h2 id='三示例项目描述'>三、示例项目描述</h2>
<p>自己看看书吧</p>
<p>&nbsp;</p>
<h2 id='四项目管理基础'>四、项目管理基础</h2>
<h3 id='1）团队组织与管理'>（1）团队组织与管理</h3>
<ol start='' >
<li><p>团队是一个为了一致的目的、绩效标准、方法而共承担责任并且技能互补的少数人。</p>
</li>
<li><p>团队的特点</p>
<ol start='' >
<li>具备共同的目标</li>
<li>成员共担责任</li>
<li>技能互补</li>
<li>小规模团队</li>
<li>团队内部有明确的结构</li>

</ol>
</li>
<li><p>团队结构</p>
<ol start='' >
<li><p>主程序员团队</p>
<ol start='' >
<li>有一名出色的成员被指定为主程序员，负责领导团队。主程序员完成总体构思和设计，然后分配任务给其他团队成员，并监督、验收和整合工作。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-19%20%E4%B8%8B%E5%8D%884.07.48.png" referrerpolicy="no-referrer" alt="截屏2023-07-19 下午4.07.48"></li>
<li>优点：如果项目规模较小或主程序员能力出众，则能有很高的工作效率，并且可以保证产品不同元素的一致性。</li>
<li>缺点：如果项目复杂或主程序员能力不足，则降低团队的工作积极性，其他成员无法发挥主观能动性。</li>
<li>如果对团队完成项目的把握大、时间紧迫，则可以使用主程序员团队。</li>

</ol>
</li>
<li><p>民主团队</p>
<ol start='' >
<li>没有集中的交流点，每个成员都发挥自己的主观能动性。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-19%20%E4%B8%8B%E5%8D%884.24.15.png" referrerpolicy="no-referrer" alt="截屏2023-07-19 下午4.24.15"></li>
<li>民主团队能取得更高的士气和工作成就感，但是过多的团队交流也是成本，工作效率不如主程序员团队。</li>
<li>民主团队中项目经理主要负责管理，没有明确的人作为技术领导，所有人都在自己的领域充当领导。</li>
<li>敏捷过程使用民主团队方式，很多有挑战性的项目也需要民主团队以充分发挥积极性。</li>

</ol>
</li>
<li><p>开放团队</p>
<ol start='' >
<li>开放团队是为了创新存在的，成员都是有创造性的开发者。</li>
<li>开放团队使用黑盒管理方式，管理者不可见团队内部交流，也不知道工作进展。同时管理者需要知道工作在进行，并在出现问题时负责清除问题。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-19%20%E4%B8%8B%E5%8D%884.25.56.png" referrerpolicy="no-referrer" alt="截屏2023-07-19 下午4.25.56"></li>
<li>民主团队成员可以按照自己的方式自我管理，能够极大地激励成员的主动性，最大化成员的创新能力。</li>
<li>开放团队的问题在于项目进展没有可视度。</li>

</ol>
</li>

</ol>
</li>
<li><p>团队建设</p>
<ol start='' >
<li><p>建立团队章程</p>
<ol start='' >
<li>团队目标</li>
<li>团队共同追求</li>
<li>团队结构和角色分工</li>
<li>团队任务、活动与绩效</li>
<li>团队规则与约束</li>

</ol>
</li>
<li><p>持续成功</p>
<ol start='' >
<li>在项目开始和空闲时开展活动，促进交流</li>
<li>在项目中设置小里程碑</li>

</ol>
</li>
<li><p>和谐沟通</p>
<ol start='' >
<li>会议是最有效的团队沟通手段之一，必要的书面交流、电子邮件、白板、公告栏也是常用的沟通手段。</li>

</ol>
</li>
<li><p>避免团队杀手</p>
<ol start='' >
<li>防范式管理</li>
<li>官僚主义</li>
<li>地理分散</li>
<li>时间分割</li>
<li>产品质量降低</li>
<li>虚假的DDL</li>
<li>小圈子控制</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='2）软件质量保障'>（2）软件质量保障</h3>
<ol start='' >
<li><p>成功的软件被要求满足显式以及隐式的各种要求，软件为了满足这些要求所需要具备的要素称为质量，对这些质量进行量化处理，建立的质量特征就称为质量属性。</p>
</li>
<li><p>质量属性</p>
<ol start='' >
<li>功能性：完备性、正确性、安全性、兼容性、互操作性</li>
<li>可靠性：无缺陷性、容错性、可用性</li>
<li>易用性：可理解性、易学习性、可操作性、通信性</li>
<li>效率：时间经济性、资源经济性</li>
<li>可维护性：可修正性、扩展性、可测试性</li>
<li>可移植性：硬件独立性、软件独立性、可安装性、可复用性</li>

</ol>
</li>
<li><p>质量保障安排</p>
<ol start='' >
<li>需求开发：需求评审、需求度量</li>
<li>体系结构：体系结构评审、集成测试（持续集成）</li>
<li>详细设计：详细设计评审、设计度量、集成测试（持续集成）</li>
<li>实现（构造）：代码评审、代码度量、测试（测试驱动、持续集成）</li>
<li>测试：测试、测试度量</li>

</ol>
</li>
<li><p>评审</p>
<ol start='' >
<li><p>评审又称为同级评审，是由作者之外的其他人来检查产品问题，是静态分析手段。</p>
</li>
<li><p>评审过程分为六个阶段：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-20%20%E4%B8%8A%E5%8D%889.04.03.png" referrerpolicy="no-referrer" alt="截屏2023-07-20 上午9.04.03"></p>
<ol start='' >
<li>规划阶段：制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与人员、审查内容等。</li>
<li>总体部署阶段：向所有参与审查会议的人员描述待审查材料的内容、审查的目标以及一些假设，并分发文档。</li>
<li>准备阶段：审查人员各自独立执行检查任务。在检查的过程中，他们可能会被要求使用检查清单、场景等检查方法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集人员。</li>
<li>审查会议阶段：通过会议讨论，识别、确认、分类发现的错误。</li>
<li>返工阶段：修改发现的缺陷。</li>
<li>跟踪阶段：要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</li>

</ol>
</li>

</ol>
</li>
<li><p>质量度量：度量就是软件产品在特定属性上的量化测度程度，是对软件质量事实的直接反映。</p>
</li>

</ol>
<h3 id='3）软件配置管理'>（3）软件配置管理</h3>
<ol start='' >
<li><p>IEEE配置管理定义：用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与需求规格的一致性。</p>
</li>
<li><p>需要进行配置管理的软件开发制品，包括最终制品和中间制品，都称为配置项。IEEE定义配置项为置于软件配置管理之下的软件配置的各种有关项目。</p>
</li>
<li><p>基线</p>
<ol start='' >
<li>工作协同是配置管理的出发点，所以制品只有进入工作协同中才算是配置项，因此经过评审和验证，可以作为后续开发工作基础而进入协同工作、需要纳入配置管理和执行变更控制的制品称为该配置项的基线。</li>
<li>也就是说极限的建立意味着产生基线制品活动的结束和后续协同工作的开始。</li>
<li>基线建立后的配置项被统一存到存储库中，在配置管理工具的帮助下进行配置管理。</li>

</ol>
</li>
<li><p><em>配置管理活动包括</em></p>
<ol start='' >
<li>标识配置项：确定哪些配置项需要被保存和管理。</li>
<li>版本管理：为配置项设置版本号，在变更时更新版本号，通常初始版本号为1.0，每次变更按1.1、1.2递增。</li>
<li>变更控制：依靠变更控制修改管理纳入配置管理的配置项。</li>
<li>配置审计：确定项目满足需求的程度，确保软件按照需求进行，验证配置项的完整性、正确性、一致性和可跟踪性。</li>
<li>状态报告：配置状态报告要标识、收集和维持演化中的配置状态信息，反映当前的配置状态。</li>
<li>软件发布管理：将软件配置项发布到开发活动之外，就是要创建和发布可用的产品，标识、保证和交付产品的元素，保证不同产品元素的质量和一致性。</li>

</ol>
</li>
<li><p>变更控制</p>
<ol start='' >
<li>以可控、一致的方式进行变更处理，不是限制或拒绝变化，而是以可控制的严格方式来执行变更。</li>
<li>变更控制的典型过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-20%20%E4%B8%8A%E5%8D%8810.49.58.png" referrerpolicy="no-referrer" alt="截屏2023-07-20 上午10.49.58"></li>

</ol>
</li>

</ol>
<h3 id='习题-1'>习题</h3>
<ol start='' >
<li><p>复杂软件系统的开发为什么需要进行项目管理？你认为简单程序的开发需耍项目管理吗？为什么？</p>
<ol start='' >
<li>复杂软件系统的开发需要进行项目管理是因为这样的项目通常包含大量的任务、资源和参与者，涉及多个阶段和交付物。</li>
<li>项目管理可以帮助规划、组织、指导和控制项目的各个方面，确保项目在预定的时间内、预算内、高质量地完成。复杂项目的规模和复杂性使得没有项目管理很容易导致进度延误、资源浪费、质量问题等。</li>

</ol>
</li>
<li><p>与简单的一群人相比，团队具有哪些特征？</p>
<ol start='' >
<li><p>与简单的一群人相比，团队具有以下特征：</p>
<ul>
<li>目标共识：团队成员都明确共享共同的目标和愿景，他们知道自己的工作如何为实现这些目标做出贡献。</li>
<li>角色明确：团队成员了解自己的角色和职责，互相配合以实现整体目标。</li>
<li>协作与信任：团队成员相互信任，愿意分享知识和经验，积极合作解决问题。</li>
<li>有效沟通：团队成员能够开放地沟通，倾听他人观点，避免信息障碍和误解。</li>
<li>互补技能：团队成员具备多样化的技能和背景，彼此之间能够互相补充和协同工作。</li>
<li>共享责任：团队成员共同对项目的成功负责，共享成果和风险。</li>

</ul>
</li>

</ol>
</li>
<li><p>你认为怎样才能建设一个高凝聚力的团队？</p>
<ol start='' >
<li><p>建设高凝聚力的团队可以通过以下措施：</p>
<ul>
<li>共同目标：确保团队成员对共同目标和愿景达成一致，让他们意识到大家的努力都为了实现共同目标。</li>
<li>激励和奖励：给予适当的激励和奖励，承认团队成员的贡献和努力，增强他们的归属感和认同感。</li>
<li>促进沟通：营造开放的沟通氛围，鼓励团队成员之间坦诚交流，解决潜在的冲突和误解。</li>
<li>团队建设活动：组织团队建设活动，增进团队成员之间的了解和信任，加强团队凝聚力。</li>
<li>共同经历：让团队成员一起面对挑战和困难，共同克服困难，增强彼此之间的团结。</li>

</ul>
</li>

</ol>
</li>
<li><p>有一个项目是开发已经被广泛使用的 ERP 软件的新版本，该项目已经规定了紧迫的最后期限并对外公布。假设你是项目经理，你会选择使用哪种团队结构？为什么？</p>
</li>
<li><p>公司 A计划开发一个非常有竞年力的家庭娱乐产品，它会融合很多新的虚拟图像研究成果。因为家庭娱乐市场竞争激烈，因此该项工作压力很大。假设你被指派为项目经理，你会选择使用哪种团队结构？为什么？</p>
</li>
<li><p>为了击败竞争对手，公司B要开发一个全新概念的产品，该产品是面向研究的，涉及的很乡技术细节都需要研究和探索。假设你被任命为项目经理，你会选择使用哪种团队结构？为什么？</p>
</li>
<li><p>你被任命为一个将要开始的项目的经理，马上要考虑的事情就是从很多候选者中挑选你的团队成员，你认为理想的团队成员应该具备哪些特征？</p>
<ol start='' >
<li><p>理想的团队成员应具备以下特征：</p>
<ul>
<li>技术专业能力：具备所需的技术技能和专业知识，能够胜任项目工作。</li>
<li>团队合作：具有良好的团队合作能力，愿意分享知识和经验，互相支持。</li>
<li>有效沟通：良好的沟通技巧，能够清晰表达和理解信息，避免误解。</li>
<li>承担责任：有责任心，对自己的工作负责，愿意承担项目目标。</li>
<li>创新思维：具备创新意识，能够寻找解决方案和改进工作流程。</li>
<li>适应能力：能够适应变化和挑战，灵活应对项目需求变化。</li>

</ul>
</li>

</ol>
</li>
<li><p>实践表明，使用公共白板能让所有团队成员实时了解项目状态，例行的每日站立会议能让团队成员及时了解重要技术决策，它们一起增强了团队的凝聚力，你认为原因是什么？</p>
<ol start='' >
<li><p>使用公共白板和例行的每日站立会议增强了团队的凝聚力的原因包括：</p>
<ul>
<li>即时性：公共白板和例行站立会议提供了实时了解项目状态和进展的机会，团队成员可以随时掌握项目动态，避免信息滞后。</li>
<li>透明性：公共白板展示了整个项目的进度和任务，使得团队成员对项目的情况有共同的认知，有助于避免信息不对称和误解。</li>
<li>互动性：白板和站立会议鼓励团队成员之间的互动和交流，有助于团队合作和问题解决。</li>
<li>集体责任：通过公共白板和例行会议，每个团队成员能够感受到整个团队的共同责任和目标，从而增强团队凝聚力。</li>

</ul>
</li>

</ol>
</li>
<li><p>你所领导的团队中有个非常敏感的程序员，他不愿与别人讨论白己的工作，也不愿意让别人看到自己写的程序。你认为他会是项目的问题吗？为什么？如果是，你打算如何解决？</p>
<ol start='' >
<li><p>敏感的程序员可能会对项目造成问题，因为他不愿意与别人交流和分享工作，这可能导致信息孤立和团队合作问题。团队合作和沟通对于项目的成功至关重要，如果有成员不愿意与其他人合作，可能会影响项目进度和质量。</p>
</li>
<li><p>解决这个问题可以采取以下措施：</p>
<ul>
<li>私下交流：与敏感的程序员进行私下交流，了解他的担忧和顾虑，帮助他解决可能导致隐私问题的顾虑。</li>
<li>建立信任：与敏感的程序员建立信任关系，让他明白团队是一个相互合作的集体，共同致力于项目的成功。</li>
<li>团队建设：组织团队建设活动，加强团队成员之间的了解和信任，帮助解决沟通问题。</li>

</ul>
</li>

</ol>
</li>
<li><p>你负责的项目出现了闲难局面，按照目前的工作方式已经赶不上原定交付时间了，但是晚于这个时间交付会给客广造成非常大的损失。如果增加人手可以加快进度赶上预定时间。但是项目费用己经到了极限，除非降薪，否则无法雇用新的人员；如果让现有人员无偿加班也可以加快进度赶上预定时间，但是你知道他们都要照顾家庭，时间安排也很紧张。面对这个困难局面，你打算怎么办？</p>
</li>
<li><p>如何确定某个软件产品是高质量的？</p>
<ol start='' >
<li><p>软件产品高质量的判断标准包括：</p>
<ul>
<li>功能完备性：软件能够满足用户需求并执行预期功能。</li>
<li>可靠性：软件在不同环境下能够稳定运行，没有频繁的故障和崩溃。</li>
<li>性能：软件具备高效的性能，运行速度快，响应时间短。</li>
<li>可用性：软件易于学习和使用，用户界面友好。</li>
<li>安全性：软件能够保护用户数据和系统安全，防范潜在威胁。</li>
<li>可维护性：软件易于维护和修改，代码结构清晰、模块化。</li>
<li>可扩展性：软件能够方便地进行功能扩展和升级。</li>
<li>合规性：软件符合相关法规和标准要求。</li>

</ul>
</li>

</ol>
</li>
<li><p>实践经验表明，评审是最有效的质量验证方法，试着解释一下原因。</p>
<ol start='' >
<li>多角度审查：通过多个人员的审查，可以发现不同的问题和潜在缺陷，提高发现问题的机会。</li>
<li>集体智慧：多人审查可以汇集各方的意见和建议，从而更全面地评估软件质量。</li>
<li>纠正早期缺陷：评审通常在软件开发早期进行，有助于及早发现和纠正问题，减少后期修复的成本。</li>
<li>提高团队意识：评审过程促进团队成员之间的交流和合作，增进团队对项目质量的共识和责任。</li>

</ol>
</li>
<li><p>尝试分析一下各种软件质量属性应该如何度量</p>
<ol start='' >
<li>功能完备性：统计软件已实现的功能点数和计划功能点数之比。</li>
<li>可靠性：平均无故障时间（MTBF）、平均修复时间（MTTR）等指标。</li>
<li>性能：响应时间、吞吐量、并发用户数等指标。</li>
<li>可用性：系统的可用时间百分比。</li>
<li>安全性：漏洞数量、安全事件发生率等指标。</li>
<li>可维护性：代码复杂度、重复代码行数等指标。</li>
<li>可扩展性：新增功能的工作量和影响范围。</li>
<li>合规性：符合性检查项的合格率。</li>

</ol>
</li>
<li><p>什么复杂项目开发需要进行配置管理？</p>
</li>
<li><p>什么是配置项？什么是基线？为什么要定义基线？</p>
</li>
<li><p>常见的配置管理活动是如何进行的？</p>
</li>
<li><p>变更为什么会发生？能不能在一个制品产生后就进行冻结？为什么？</p>
<ol start='' >
<li>变更发生的原因可能包括需求变更、技术改进、缺陷修复等。即使一个制品在某个时刻被冻结，变更仍然可能发生，因为项目的需求和环境都可能发生变化。</li>
<li>在制品完成后立即进行冻结是不现实的，因为软件开发是一个动态的过程，需求和技术可能需要不断优化和调整。冻结制品可能会导致项目无法适应变化，进而影响项目的成功和用户满意度。</li>

</ol>
</li>
<li><p>如果一个团队没有进行配置管理，你认为他们在工作中可能会发生哪些问题？</p>
<ol start='' >
<li>版本混乱：无法确定哪个版本是最新的，导致团队使用过时或错误的代码和文档。</li>
<li>重复工作：没有记录项目中的重复工作，可能导致资源浪费和效率低下。</li>
<li>无法回溯：在项目出现问题时，无法追踪导致问题的变更和版本。</li>
<li>缺乏稳定性：团队无法控制项目的稳定状态，项目变得不可预测和不稳定。</li>
<li>协作问题：没有清晰的配置项管理，可能导致团队成员之间的协作问题，影响项目进展。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h1 id='软工-第三部分-需求开发阶段'>软工-第三部分-需求开发阶段</h1>
<h2 id='五软件需求基础'>五、软件需求基础</h2>
<h3 id='1）需求工程基础'>（1）需求工程基础</h3>
<ol start='' >
<li><p>需求工程：所有需求处理活动的总和，收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。</p>
</li>
<li><p>需求工程的活动分为需求开发和需求管理两个方面：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-21%20%E4%B8%8A%E5%8D%888.51.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-21上午8.51.49"></p>
</li>
<li><p>需求获取</p>
<ol start='' >
<li><p>需求获取指的是从人、文档或环境中获取需求的过程。</p>
</li>
<li><p>目的是从空白开始建立最初的原始需求。</p>
</li>
<li><p>需求获取的重要任务有两方面</p>
<ol start='' >
<li>目标分析</li>
<li>用户需求获取：常见的需求获取方法有面谈、集体获取方法、头脑风暴、原型。</li>

</ol>
</li>

</ol>
</li>
<li><p>需求分析</p>
<ol start='' >
<li><p>需求分析主要任务是通过建模整合各种信息，使人们更好地理解问题，并为问题定义出一个需求集合。</p>
</li>
<li><p>目的是保证需求的完整性和一致性。</p>
</li>
<li><p>需求分析的重要任务有两方面</p>
<ol start='' >
<li>边界分析：通常使用系统用例图和上下问题定义系统的边界。</li>
<li>需求建模：需求建模的技术包括数据流图、实体关系图、状态转换图、类图。</li>

</ol>
</li>

</ol>
</li>
<li><p>需求规格说明</p>
<ol start='' >
<li><p>将获取的需求编写成文档，编写成文档的目的是在系统用户之间交流需求信息。</p>
</li>
<li><p>目的是将完整、一致的软件解决方案以文档的方式固定下来。</p>
</li>
<li><p>重要任务有两个方面</p>
<ol start='' >
<li>定制文档模版：参考[IEEE830-1998]的需求规格说明文档。</li>
<li>编写文档</li>

</ol>
</li>

</ol>
</li>
<li><p>需求验证</p>
<ol start='' >
<li>保证需求规格说明文档中定义的需求正确、准确地反映用户的意图。</li>

</ol>
</li>
<li><p>需求管理</p>
<ol start='' >
<li>需求的影响贯穿整个软件的生命周期，所以在需求开发之后还需要保证需求作用的持续、稳定和有效的发挥。</li>
<li>需求管理会进行变更控制，接受合理的变更，拒绝不合理的变更，控制变更的成本和影响范围。</li>

</ol>
</li>

</ol>
<h3 id='2）需求基础'>（2）需求基础</h3>
<ol start='' >
<li><p><em>需求的定义</em>：</p>
<ol start='' >
<li>用户为了解决问题或达到某些目标所需要的条件或能力。</li>
<li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力。</li>
<li>对1.或2.中的一个条件或一种能力的一种文档化表述。</li>

</ol>
</li>
<li><p>需求是用户的一种期望，软件系统通过满足用户的期望来解决用户问题，作为一种期望，需求通常被描述为“系统应该……”、“在……时，系统应该……”、“用户可以通过系统……”等。</p>
</li>
<li><p><strong>需求的层次性（必考）</strong></p>
<ol start='' >
<li><p>需求的抽象层次分为业务需求、用户需求和系统需求。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-21%20%E4%B8%8A%E5%8D%889.17.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-21上午9.17.00"></p>
</li>
<li><p>业务需求</p>
<ol start='' >
<li><p>抽象层次最高的需求就是业务需求，时系统建立的战略出发点，<strong>描述了组织为什么要开发系统</strong>。</p>
</li>
<li><p>业务需求<strong>描述系统高层次的解决方案，定义系统应该具备的特性</strong>，说明了系统为用户提供的功能，限定了系统的范围。</p>
</li>
<li><p>业务需求的例子</p>
<ol start='' >
<li>管理会员信息</li>
<li>提供会员服务，增加回头率</li>
<li>使用多样化的特价方案，吸引客户购买，增加销售额</li>

</ol>
</li>

</ol>
</li>
<li><p>用户需求</p>
<ol start='' >
<li><p>用户需求实质性实际工作的用户对系统所能完成的具体任务的期望，描述了系统能帮助用户做什么。</p>
</li>
<li><p>针对每个系统特性都可以建立一组用户需求，表达了用户对系统的期望，用户需求还需要充分的问题域知识作为背景补充。</p>
</li>
<li><p>用户需求的例子</p>
<ol start='' >
<li>系统应该允许客户经理添加、修改或删除会员的信息（问题域知识补充：会员的个人信息包括客户编号、姓名、性别、联系方式、积分）</li>
<li>系统应该记录会员的购买信息</li>
<li>系统应该允许经历查看所有会员的信息</li>

</ol>
</li>

</ol>
</li>
<li><p>系统级需求</p>
<ol start='' >
<li><p>系统级需求是用户对系统行为的期望，每个系统级需求反映了一次外界与系统的交互行为或系统的一个实现细节。</p>
</li>
<li><p>一系列系统级需求连在一起满足一个用户需求，进而满足业务需求。</p>
</li>
<li><p>系统级需求可以直接映射为系统行为，定义系统需要实现的功能，描述开发人员需要实现什么。</p>
</li>
<li><p>系统级需求的例子</p>
<ol start='' >
<li>在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。</li>
<li>在客户经理输人会员的客户编号时，系统要提供该会员的个人信息。</li>
<li>在客户经理选定一个会员并申请查看购买信息时，系统要提供该会员的历史购买记录。</li>

</ol>
</li>
<li><p>&lt;fontcolor=blue&gt;需求描述用户对系统的期望，是系统与外界的交互，所以需求不要设计系统内部的构造细节，即使是系统级需求。</font></p>
</li>

</ol>
</li>

</ol>
</li>
<li><p><strong>需求的分类（必考）</strong></p>
<ol start='' >
<li><p>需求分为三种</p>
<ol start='' >
<li><p>项目需求：针对项目的期望</p>
</li>
<li><p>过程需求：针对开发过程的期望</p>
</li>
<li><p>系统需求：针对系统工程的需求</p>
<ol start='' >
<li>软件需求：与软件相关的需求</li>
<li>硬件需求：与硬件相关的需求</li>
<li>其他需求：与人力资源相关的需求以及软件、硬件、人力之间协同的需求</li>

</ol>
</li>

</ol>
</li>
<li><p>&lt;fontcolor=blue&gt;要注意需求应该是对系统的要求，而不是对用户等人员的要求，如“收银员必须在2h内完成操作”的需求是不切实际的，因为需求不能约束收银员的行为，应该为“如果操作没有在2h内完成，系统要撤销该任务”。</font></p>
</li>
<li><p>软件需求的分类</p>
<ol start='' >
<li><p>功能需求</p>
<ol start='' >
<li>最主要最复杂的需求，是和系统主要工作相关的需求，即用户希望系统所能执行的活动。</li>
<li>如：系统应该允许客户退回已经购买的产品。</li>

</ol>
</li>
<li><p>数据需求</p>
<ol start='' >
<li>不是标准的软件需求，是对功能需求的补充。</li>
<li>是对数据结构的定义的描述，常用于数据库、文件等储存数据的描述。</li>

</ol>
</li>
<li><p>性能需求——非功能性需求</p>
<ol start='' >
<li><p>一个系统或者其组成部分在限定的约束下，完成其指定功能的程度，如速度、内存使用程度等。</p>
</li>
<li><p>性能需求规定了系统必须多好多快地完成专门的功能。</p>
</li>
<li><p>如：</p>
<ol start='' >
<li>（速度）98%的用户查询必须在1s内完成</li>
<li>（容量）系统应该能存储至少100w条信息</li>
<li>（负载）系统应该允许50台服务器同时运作</li>

</ol>
</li>
<li><p>性能需求可以给出一定的灵活性或多个不同层次的目标要求。</p>
</li>

</ol>
</li>
<li><p>质量属性——非功能性需求</p>
<ol start='' >
<li><p>隐式的需求，是用户对产品质量的期望。</p>
</li>
<li><p>质量属性有：</p>
<ol start='' >
<li>可靠性：在规格时间间隔内和规定条件下，系统或部件执行所要求功能的能力。</li>
<li>可用性：软件系统在投人使用时可操作和可访问的程度或能实现其指定系统功能的概率。</li>
<li>安全性：软件阻止对其程序和数据进行末授权访问的能力。</li>
<li>可维护性：为排除故障、改进质量或适应环境变化而修改软件系统或部件的容易程度，包括可修改性和可扩展性。</li>
<li>可移植性：系统或部件能从一种硬件或软件环境转换至另外一种环境的特性。</li>
<li>易用性：与用户使用软件所花费的努力及其对使用的评价相关的特性。</li>

</ol>
</li>

</ol>
</li>
<li><p>对外接口——非功能性需求</p>
<ol start='' >
<li>对外接口指的是系统和环境中其他系统之间需要建立的接口，包括用户界面、硬件接口、软件接口、网络接口等。</li>
<li>接口需要说明：接口用途、接口IO、数据格式、命令格式、异常处理要求。</li>

</ol>
</li>
<li><p>约束——非功能性需求</p>
<ol start='' >
<li>约束指进行系统构造是需要遵守的约定，不受软件影响只影响软件。</li>
<li>约束有：系统开发及运行的环境、问题域内的相关标准、商业规则。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-1'>（3）习题</h3>
<ol start='' >
<li><p>为什么要重视需求开发？</p>
<p>重视需求开发是因为在软件开发过程中，需求是决定项目成功与否的重要因素。需求开发是确保软件能够满足用户和利益相关者期望的过程。如果需求开发不充分或者需求不清晰，可能导致以下问题：</p>
<ul>
<li>项目范围蔓延：由于需求变更频繁或不明确，导致项目范围不断扩大，造成项目延期和超出预算。</li>
<li>功能不完备：缺乏对用户真正需求的理解，导致软件功能不够完备或不符合实际需求。</li>
<li>质量问题：需求不明确或不准确，可能导致软件质量问题和用户体验不佳。</li>
<li>用户不满意：软件交付后不符合用户期望，导致用户不满意或拒绝使用。</li>

</ul>
<p>因此，重视需求开发是确保软件项目成功的关键步骤，能够降低项目风险、提高软件质量和用户满意度。</p>
</li>
<li><p>软件需求工程包括哪些活动？请分别进行详细描述。</p>
<p>软件需求工程包括以下活动：</p>
<ul>
<li>需求获取：收集相关利益相关者的需求，包括业务需求和用户需求。</li>
<li>需求分析：对收集到的需求进行分析和整理，明确需求之间的关系和优先级。</li>
<li>需求规格说明：将需求转化为形式化的文档，包括功能规格、系统架构等。</li>
<li>需求验证：确保需求的正确性和一致性，以及与用户期望的符合程度。</li>
<li>需求管理：跟踪和控制需求的变更，确保项目稳定和可控。</li>

</ul>
</li>
<li><p>什么是需求？</p>
<p>需求是指对产品或服务的功能、性能、特性等方面的描述，以及用户和利益相关者对产品或服务的期望和要求。需求是软件开发过程中的基础，它涵盖了软件的功能、性能、非功能性特征和限制条件等方面。</p>
</li>
<li><p>业务需求、用户需求与系统级需求有什么区别和联系？</p>
<ul>
<li>业务需求：业务需求是指业务组织或组织的业务部门对软件产品或系统所提出的要求，通常从组织的战略目标和业务流程角度出发。它描述了软件系统应该解决的业务问题和满足的业务目标。</li>
<li>用户需求：用户需求是指最终用户对软件产品或系统的需求和期望，通常从用户使用软件的角度出发。它描述了用户对软件功能、用户界面和交互体验等方面的要求。</li>
<li>系统级需求：系统级需求是从整个软件系统角度来看的需求，它将业务需求和用户需求转化为形式化的规格说明，供开发团队进行开发和测试。</li>

</ul>
<p>这些需求之间的联系在于，业务需求和用户需求是系统级需求的基础，系统级需求是对业务需求和用户需求的详细描述和实现方案。</p>
</li>
<li><p>需求为什么要区分为不同的层次？</p>
<p>需求被区分为不同的层次是为了更好地管理和理解需求，以及确保需求的正确性和完整性。不同层次的需求包括：</p>
<ul>
<li>业务需求：高层次的业务目标和需求，与组织战略和业务流程相关。</li>
<li>用户需求：从最终用户角度描述软件功能和用户体验的需求，与用户期望和使用场景相关。</li>
<li>系统级需求：将业务需求和用户需求转化为形式化的规格说明，供开发团队实现和测试。</li>

</ul>
<p>将需求划分为不同的层次，有助于确保需求的一致性，帮助开发团队理解需求并准确实现。</p>
</li>
<li><p>问题、需求、问题域与规格说明有什么区别和联系？</p>
<p>问题、需求、问题域与规格说明之间的区别和联系如下：</p>
<ul>
<li>问题：问题是现实世界中需要解决的困难或挑战，它可能引发需求的产生。</li>
<li>需求：需求是对解决问题或满足特定目标的功能、性能、约束条件等方面的要求和描述。</li>
<li>问题域：问题域是指软件系统所涉及的业务领域或特定领域的描述和范围，它涉及到业务过程、业务规则等。</li>
<li>规格说明：规格说明是对需求进行形式化的描述，它包括详细的功能规格、系统架构等。</li>

</ul>
<p>这些概念之间的联系在于，问题可能引发需求的产生，需求描述了对问题的解决方案和期望的功能，问题域是需求所涉及的具体业务领域，而规格说明是对需求的形式化描述。</p>
</li>
<li><p>软件需求有哪些类别？为什么需要将需求区分为这些类别？</p>
<p>软件需求可以根据不同的属性和特征进行分类，常见的软件需求类别包括：</p>
<ul>
<li>功能需求：描述软件系统应该具备的功能和行为，例如用户界面、数据处理、业务流程等。</li>
<li>非功能性需求：描述软件系统的非功能特征，例如性能、安全、可用性、可维护性等。</li>
<li>约束性需求：描述软件系统的限制条件和约束，例如预算限制、技术限制等。</li>
<li>假设和约束：描述软件开发和运行过程中的假设和条件。</li>

</ul>
<p>将需求区分为不同的类别有助于更好地管理和评估需求，帮助开发团队理解需求的不同方面，并确保软件系统能够满足所有相关的需求。</p>
</li>
<li><p>为下列需求类别各举一例，注意书写规范：</p>
<ol start='' >
<li>项目需求：软件项目必须在2023年底之前交付。</li>
<li>过程需求：在开发过程中，每个代码提交必须经过代码审查流程。</li>
<li>不切实际的期望：软件必须在一周内完成，且不允许延期。</li>
<li>硬件需求：软件要求在操作系统为Windows10及以上版本的计算机上运行。</li>
<li>其他需求：软件必须支持中英文双语界面。</li>
<li>性能需求：系统响应时间应该在1秒内。</li>
<li>质量属性需求：软件必须具备高可靠性，最小的故障率不得低于99.9%。</li>
<li>对外接口需求：软件需要与第三方支付系统集成，支持在线支付功能。</li>
<li>约束：软件开发预算不得超过50,000美元。</li>
<li>数据需求：软件需要能够处理每天最多100,000个数据条目。</li>

</ol>
</li>
<li><p>下列描述中哪些是有效的功能性需求？请给出你选择的理由。</p>
<ol start='' >
<li>在销售商品之后，系统应该更新库存的商品数量，如果库存的数量低于最低限值，系统应该发出警示信号。</li>
<li>用户在使用喷嘴给汽车加过油之后，应该将其放回原处。</li>
<li>每一个收银员都应该有一个记录，记录的内容包括名字和ID号。记录应该被建立成链表的形式。</li>
<li>开发组应该创建完整、有效的需求规格说明文档、体系结构设计文档、详细设计文档和测试过程记录日志。</li>

</ol>
<p>以下是有效的功能性需求：</p>
<ol start='' >
<li><p>在销售商品之后，系统应该更新库存的商品数量，如果库存的数量低于最低限值，系统应该发出警示信号。</p>
<p>理由：该需求明确描述了系统应该具备的功能，即在销售商品后，更新库存数量，并在库存低于最低限值时触发警示信号。这是一个明确的行为描述，指导系统应该如何运作。</p>
</li>

</ol>
<p>以下不是有效的功能性需求：</p>
<ol start='' >
<li><p>用户在使用喷嘴给汽车加过油之后，应该将其放回原处。</p>
<p>理由：该描述涉及用户的操作行为，而不是系统的功能和行为。它描述的是用户应该如何操作，而不是系统的预期行为。</p>
</li>
<li><p>每一个收银员都应该有一个记录，记录的内容包括名字和ID号。记录应该被建立成链表的形式。</p>
<p>理由：该描述涉及数据结构的选择（链表），而不是系统的功能和行为。它描述了应该采用的数据结构，而不是系统应该具备的功能。</p>
</li>
<li><p>开发组应该创建完整、有效的需求规格说明文档、体系结构设计文档、详细设计文档和测试过程记录日志。</p>
<p>理由：该描述是项目管理或过程相关的要求，而不是系统的功能和行为。它描述了开发组应该执行的任务，而不是系统应该具备的功能。</p>
</li>

</ol>
</li>
<li><p>说明下列需求分别属于哪种类型：</p>
<ol start='' >
<li>开发团队需要给出SRS文档——过程</li>
<li>经过10天培训的收银员就能够熟练使用系统——质量</li>
<li>一个从没有使用过ATM的新顾客，也能够顺利使用系统完成自助取款——质量</li>
<li>系统开发的成本不超过10万元人民币——项目</li>
<li>顾客使用信用卡付款时，系统必须使用银联专用刷卡设备与银行交易——功能</li>
<li>使用银联专用刷卡设备，向银行传递的交易数据格式为…——对外接口</li>
<li>当订单数量大于现有数量时，系统必领通知操作员——功能</li>
<li>产品在发布1年之后，必须在出版的A、B、C三个产品评论刊物中被评为最可靠的产品——业务</li>
<li>系统每小时必须处理至少3000次呼叫——性能</li>
<li>每日报表中，标题的形式必须是“每日报告：dd-mm-yyyy”——数据</li>
<li>过期商品的每日报表必须列出其名称、制造商和批号——数据</li>
<li>商品的标识是由0～24位宇母、数字混合组成的字符串——数据</li>
<li>电梯的默认停运楼层必须是最低楼层到最高楼层范围内的某个整数——数据</li>
<li>付款单上，默认的信用卡类型是“银联”——数据</li>

</ol>
</li>
<li><p>在检查需求文档时，你发现有一条需求是现有资源条件下无法做到的，但是客户又认为该条需求非常重要，你该怎么办？</p>
<ol start='' >
<li>与客户沟通：首先，与客户进行充分的沟通，了解他们对该需求的具体期望和重要性。询问客户为什么认为该需求是重要的，以了解背后的考虑和需求背景。</li>
<li>解释限制：向客户详细说明现有资源条件下无法满足该需求的原因和限制。清楚地表达可能导致该需求难以实现的技术或资源障碍。</li>
<li>探讨替代方案：与客户一起探讨可能的替代方案，以满足他们的核心需求或目标。寻找其他能够在现有资源条件下实现的功能或解决方案。</li>
<li>风险评估：对于客户坚持的需求，进行风险评估和影响分析。说明实现该需求可能带来的潜在风险和对项目进度、质量等方面的影响。</li>
<li>寻求共识：努力达成共识，让客户理解现有资源条件下的局限性，并共同商讨最佳解决方案。寻找双方都能接受的折中办法。</li>
<li>文档更新：如果最终与客户达成共识，可以对需求文档进行更新，将经过讨论的需求和解决方案记录下来。</li>
<li>持续沟通：保持与客户的持续沟通，随时了解他们的需求变化和优先级，并根据情况调整项目计划和开发方向。</li>

</ol>
<p>重要的是，与客户保持开放和透明的沟通，共同寻找解决方案，确保最终交付的软件能够满足客户的核心需求，同时在现有资源条件下保持可实现性和合理性。</p>
</li>
<li><p>如何理解下面这句话：好的需求应该是描述软件系统与外界环境交互的，而不是描述现实世界的或者软件内部构造的。举例说明单纯描述现实世界或者软件内部的错误需求可能会是什么样子。</p>
<p>这句话的含义是，好的需求应该关注软件系统与外界环境的交互，即软件系统应该做什么，而不是关注具体如何实现这个功能或描述软件内部的构造细节。需求应该着重于用户的行为和期望，而不是软件系统内部的技术细节。</p>
<p>举例说明单纯描述现实世界或者软件内部的错误需求可能如下：</p>
<ol start='' >
<li>描述现实世界的错误需求： 需求：系统应该有一个复杂的算法，可以预测未来一周内的股市涨跌情况。 错误原因：这个需求过于具体地描述了系统应该使用的算法，而不是关注系统与外界环境的交互。这样的需求忽略了软件的实际用途和用户需求，而是直接描述了算法细节。</li>
<li>描述软件内部构造的错误需求： 需求：系统应该使用Java语言编写，采用三层架构，数据访问层使用Hibernate框架。 错误原因：这个需求关注的是软件的内部构造和技术实现，而不是关注用户的功能需求。需求应该描述系统应该具备的功能和行为，而不是关注具体的编程语言和框架。</li>

</ol>
<p>在上述例子中，这些错误需求过于关注技术细节或具体的实现方式，忽略了软件系统与外界环境的交互和用户的期望。一个好的需求应该关注软件系统的功能和行为，以及用户期望实现的具体目标，而不是陷入具体的技术细节或软件内部的构造。这样可以确保需求更加清晰、可理解，并有助于有效地开发满足用户期望的软件系统。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='六需求分析方法'>六、需求分析方法</h2>
<h3 id='1）需求分析基础'>（1）需求分析基础</h3>
<ol start='' >
<li>需求分析模型专门用来描述软件解决方案，因为软件解决方案介于用户描述与软件内部构造之间，所以需求分析模型也介于用户概念和软件内部实体之间。</li>
<li>需求分析模式一方面使用软件内部实体，以对象、类、函数、过程、属性等作为模型的基本元素，另一方面又使用问题域的概念来描述软件内部实体，使用问题域语言来表现语义。</li>
<li>需求分析模型<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-21%20%E4%B8%8B%E5%8D%884.58.47.png" referrerpolicy="no-referrer" alt="截屏2023-07-21 下午4.58.47"></li>

</ol>
<h3 id='2）结构化分析'>（2）结构化分析</h3>
<ol start='' >
<li><p>结构化分析把现实描述为数据在信息系统中的流动，其核心技术是数据流图。</p>
</li>
<li><p>结构化分析的过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-21%20%E4%B8%8B%E5%8D%885.02.15.png" referrerpolicy="no-referrer" alt="截屏2023-07-21 下午5.02.15"></p>
</li>
<li><p>数据流图</p>
<ol start='' >
<li><p>DFD是结构化分析方法的典型技术，将系统看作过程的集合，其中一些有人来执行，另一些由软件类执行，过程的执行就是对数据的处理。</p>
</li>
<li><p>基本模型元素<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%888.34.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午8.34.08"></p>
<ol start='' >
<li>外部实体：指处于该构建软件系统之外的人、组织、设备或者其他软件系统。</li>
<li>过程：施加于数据的动作或行为，使得数据发生变化，包括转换、储存或分布。</li>
<li>数据流：指数据的运动，是系统与环境之间或者系统内两个过程之间的通信形式。</li>
<li>数据储存：软件系统需要在内部收集、保存的数据集合。</li>

</ol>
</li>
<li><p>语法规则</p>
<ol start='' >
<li>过程是对数据的处理，必须有输入也有输出，并且输入输出应该有差异。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%888.40.07.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午8.40.07"></li>
<li>数据流必须和过程管理，要么是输入要么是输出。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%888.40.13.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午8.40.13"></li>
<li>DFD所有对象都有一个可以唯一标识自己的名称，过程使用动词，其他使用名词。</li>

</ol>
</li>
<li><p>分层结构</p>
<ol start='' >
<li><p>针对复杂的系统DFD可以依据过程的功能分解结构，建立层次的DFD。</p>
</li>
<li><p>DFD的层次类型有三种：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%888.44.44.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午8.44.44"></p>
<ol start='' >
<li><p>上下文图<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%888.49.26.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午8.49.26"></p>
<ol start='' >
<li>DFD最高层次的图，系统功能的最高抽象。</li>
<li>将整个系统看作一个过程，这个过程实现系统的所有功能，仅存在一个过程，表示整个系统，这个单一的过程编号为0。</li>
<li>上下文图将整个系统看作黑盒，描述与系统交互的外部实体和数据流，适合于描述系统的上下文环境和定义系统边界。</li>

</ol>
</li>
<li><p>0层图<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.04.27.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.04.27"></p>
<ol start='' >
<li>0层图是对上下文图中单一过程的细节描述和第一次功能分解，需要在一个图中概括系统的所有功能。</li>
<li>0层图是整个系统的功能概图，概述整个系统的功能，需要归纳系统的主要功能。</li>

</ol>
</li>
<li><p>N层图<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.07.06.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.07.06"></p>
<ol start='' >
<li>对0层图过程分解产生的子图称为1层图，N层图分解的子图就称为N+1层图。</li>
<li>低于0层图的子图上通常不显示外部实体，父图的IO数据流称为子图的接口流，从子图的空白域引出。</li>
<li>子图的过程编号需要以父进程的编号为前缀。</li>
<li><font color=blue>过程分解需要保证分解的平衡性，要求子图的IO流和父进程的IO流一致。</font></li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>实体关系图<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.12.30.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.12.30"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.18.03.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.18.03"></p>
<ol start='' >
<li>实体关系图用来描述数据的定义、结构、和关系等特性，弥补过程建模在数据说明方面的缺陷。</li>
<li>实体是需要在系统中收集和储存的现实事物的类别描述。</li>
<li>关系是存在于一个或多个实体之间的自然业务联系。</li>
<li>基数表示关系中实体能够参与的最大数量，“One”标识最大基数为1，“Many”表示最大基数超过1，“Optional”表示最小基数为0，“Mandatory”表示最小基数为1。</li>
<li>属性是对实体进行描述的特征。</li>
<li>可以使用实体的一个或多个属性来唯一确定和标识每个实例，这就是实体的标识符或键（key）。</li>

</ol>
</li>

</ol>
<h3 id='2）面向对象分析方法画图是重点）'>（2）面向对象分析方法（画图是重点）</h3>
<ol start='' >
<li><p>用例</p>
<ol start='' >
<li>用例是系统和外部对象的交互中执行的行为序列的描述，每个用例都是对相关场景的集合，是用户和系统之间的交互行为序列。</li>
<li>一个用例承载了所有与用户的某个目标相关的成功或失败的场景集合。</li>

</ol>
</li>
<li><p><strong>用例图（重点）</strong><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.34.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.34.08"></p>
<ol start='' >
<li><p>用例图是系统所有用例的集合。</p>
</li>
<li><p>用例图的基本元素</p>
<ol start='' >
<li>用例：用水平的椭圆表示。</li>
<li>参与者：发起或参与一个用例的外部用户及其他软件系统等角色，用一个小人+名称表示。<em>参与者不需要是一个真的人，也可以是其他组织、物体、系统等。</em></li>
<li>关系</li>
<li>系统边界：系统所包含的成分和外界事物的分界线，用一个矩形边框表示，显示系统的上下文环境。</li>

</ol>
</li>
<li><p>用例图的建立</p>
<ol start='' >
<li>进行目标分析确定解决方向</li>
<li>寻找参与者</li>
<li>寻找用例</li>
<li>细化用例</li>

</ol>
</li>

</ol>
</li>
<li><p>用例描述</p>
<ol start='' >
<li>用文本的方式将用例的参与者、目标、场景等信息描述出来。</li>
<li>模版<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.36.27.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.36.27"></li>
<li>示例<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.37.20.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.37.20"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.37.31.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.37.31"></li>
<li>用例描述一定要围绕“交互”进行场景描述，同时要保持“规格说明”级别，不要设计界面、按钮、方法等软件构造机制。</li>

</ol>
</li>
<li><p><strong>概念类图（领域模型）（重点）</strong></p>
<ol start='' >
<li><p>概念类图专注用户的业务领域，类型、方法等软件构造细节不会出现。</p>
</li>
<li><p>基本元素</p>
<ol start='' >
<li><p>对象：对具体问题域事物的抽象，对象有三个方面的内容：</p>
<ol start='' >
<li>标识符</li>
<li>状态：对象的特征描述，包括属性和属性取值</li>
<li>行为：对象在状态改变或接收到外部消息时的行动。</li>

</ol>
</li>
<li><p>类</p>
<ol start='' >
<li>类是对象的集合，对象是类的实例。</li>
<li>类有唯一标识自己的名称，也包含属性和行为方法。概念类图的类通常只是概念类，不显式说明行为，指包括属性。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.50.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.50.29"></li>

</ol>
</li>
<li><p>链接：</p>
<ol start='' >
<li>对象之间的协作关系，描述对象之间的物理或业务联系。</li>
<li>链接可以是单向或双向的。</li>

</ol>
</li>
<li><p>关联</p>
<ol start='' >
<li>指明类之间的语义联系，拥有一个能表达语义内涵的名称和多个包含角色和基数的终端。</li>
<li>类之间整体与部分的关系称作聚合，用空心菱形表示。</li>
<li>如果某部分属于一个整体，并不能脱离整体单独存在或归属其他整体，就称为组合，用实心菱形表示。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.55.10.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.55.10"></li>

</ol>
</li>
<li><p>继承：用三角形箭头的实线表示继承。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.55.47.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.55.47"></p>
</li>

</ol>
</li>
<li><p>建立概念类图</p>
<ol start='' >
<li><p>对每个用例文本描述建立局部的概念类图</p>
<ol start='' >
<li>识别候选类：从用例描述中划出名词和名词短语。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.59.27.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.59.27"></li>
<li>确定概念类：准则——依据系统需求，该类的对象实例的状态和行为是否全部必要。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.59.44.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.59.44"></li>
<li>识别关联：发现协作、分析关系、去除冗余、导出关联。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%889.59.58.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午9.59.58"></li>
<li>识别重要属性：添加协作时的必要信息。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.00.12.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.00.12"></li>

</ol>
</li>
<li><p>将局部概念类图合并成系统概念类图</p>
</li>

</ol>
</li>

</ol>
</li>
<li><p><strong>交互图（顺序图/系统顺序图）（重点）</strong></p>
<ol start='' >
<li><p>交互图就是描述对象协作的技术，描述在特定上下文环境中一组对象的交互行为，经常基于单个用例的典型场景。</p>
</li>
<li><p>顺序图</p>
<ol start='' >
<li>顺序图将交互表示成一个二维图标，纵向表示时间轴，时间沿纵轴向下延伸，横轴表示协作的对象。</li>
<li>图的内容以交互行为中的消息序列为主，消息以时间顺序在图中从上到下排列。</li>
<li>消息有同步消息（实线三角）、异步消息（实线鱼骨）和返回消息（虚线鱼骨）。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.25.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.25.29"></li>

</ol>
</li>
<li><p>系统顺序图<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.27.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.27.04"></p>
<ol start='' >
<li><p>将整个系统看作黑盒对象，强调外部参与者和系统的交互行为，重点展示系统级事件。</p>
</li>
<li><p>建立系统顺序图的步骤：</p>
<ol start='' >
<li>确定上下文环境</li>
<li>根据用例描述找到交互对象</li>
<li>按照流程顺序逐步添加信息</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p><strong>状态图（重点）</strong></p>
<ol start='' >
<li><p>状态图可以描述复杂的流转关系和对象和很多用例之间的交互。</p>
</li>
<li><p>状态图的基础是有限状态机，基本元素包括：状态、开始状态、结束状态、事件、监护条件、活动和转换。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.43.23.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.43.23"></p>
</li>
<li><p>建立状态图</p>
<ol start='' >
<li>确定上下文环境</li>
<li>识别状态<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.45.17.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.45.17"></li>
<li>建立状态转换<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.45.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.45.08"></li>
<li>补充详细信息，完善状态<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-22%20%E4%B8%8A%E5%8D%8810.45.27.png" referrerpolicy="no-referrer" alt="截屏2023-07-22 上午10.45.27"></li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-2'>（3）习题</h3>
<ol start='' >
<li><p>为什么要进行需求分析？</p>
<p>需求分析是软件开发过程中的重要阶段，其目的是深入了解用户需求、业务流程和系统功能，以确保在软件开发过程中准确地捕捉、理解和定义需求。需求分析有助于构建一个清晰、一致和完整的需求规格，为后续的设计、开发和测试提供准确的指导。</p>
</li>
<li><p>需求分析的主要目标是什么？</p>
<p>需求分析的主要目标是确定用户的需求和期望，对需求进行分析、整理和规范化，确保需求准确、无二义性，并与所有利益相关者达成共识。通过需求分析，可以确保软件开发团队和用户对系统功能、性能和约束等方面有共同的理解和期望。</p>
</li>
<li><p>为什么要建立需求分析模型？</p>
<p>建立需求分析模型的目的是用形式化的方式来表示和描述需求。需求分析模型是对需求进行抽象和概括，使得需求更加清晰、易于理解和传达。它可以帮助捕捉需求之间的关系和依赖，以及用户与系统交互的过程，从而帮助建立准确的需求规格。</p>
</li>
<li><p>结构化需求分析方法的思路是什么？</p>
<p>结构化需求分析方法的思路是将需求分解为更小、更易管理的部分，从整体到局部进行分析。它包括以下主要步骤：</p>
<ul>
<li>确定系统边界和范围。</li>
<li>识别和描述系统的功能需求。</li>
<li>分析功能需求之间的关系和依赖。</li>
<li>定义系统的非功能性需求和约束。</li>
<li>验证和确认需求的正确性和完整性。</li>

</ul>
</li>
<li><p>DFD 是怎样体现功能分解思想的？</p>
<p>数据流图（DFD）体现功能分解思想是通过将一个复杂的系统分解为多个功能模块，每个模块都处理特定的数据流。DFD图中的箭头表示数据流，方框表示功能模块。通过逐层细化，DFD图逐步展示了系统的功能层次结构，从整体到局部呈现了系统的功能分解。</p>
</li>
<li><p>ERD 描述的数据与软件功能有什么关系？</p>
<p>实体-关系图（ERD）描述的数据与软件功能有密切关系。ERD图用于描述系统中的数据实体、数据属性以及数据之间的关系。数据实体和属性与软件功能之间存在密切的关联，数据实体通常对应着软件系统中的业务对象，而数据之间的关系反映了业务流程和功能之间的交互和依赖关系。</p>
</li>
<li><p>面向对象需求分析方法的思路是什么？</p>
<p>面向对象需求分析方法的思路是从现实世界的对象出发，识别出系统的实体和行为，进而建立对象模型。它包括以下主要步骤：</p>
<ul>
<li>确定系统中的类和对象。</li>
<li>定义类之间的关系和行为。</li>
<li>识别系统的用例和功能需求。</li>
<li>建立用例图和类图来表示需求和系统结构。</li>

</ul>
</li>
<li><p>什么是用例？什么是用例图？什么是用例描述？它们有哪些区别与联系？</p>
<p>用例是描述系统功能和用户操作的一种方式。用例图是用于图形化表示用例和参与者之间的关系的图表。用例描述是对用例的文本描述，详细说明了用例的步骤和预期结果。它们之间的区别与联系如下：</p>
<ul>
<li>用例是一种功能性需求的表示方式，用例图是对用例和参与者的图形化描述。</li>
<li>用例描述是用例的详细文本描述，包括步骤和预期结果。</li>

</ul>
</li>
<li><p>如何为一个软件系统建立用例图？</p>
<p>要为一个软件系统建立用例图，可以通过以下步骤：</p>
<ul>
<li>确定系统的参与者和用例。</li>
<li>描述参与者和用例之间的关系，包括关联、包含和扩展关系。</li>
<li>绘制用例图，显示用例和参与者之间的关系。</li>

</ul>
</li>
<li><p>用例描述包含哪些重要内容？</p>
<p>用例描述通常包含以下重要内容：用例名称和标识符、参与者列表、前置条件和后置条件、主要流程和步骤、异常流程和异常情况处理。</p>
</li>
<li><p>需求分析方法是如何帮助细化和明确需求的？</p>
<p>需求分析方法帮助细化和明确需求的过程包括：确定需求的范围和边界、识别和整理需求，确保需求准确无误、分析需求之间的关系和依赖、验证和确认需求的正确性和完整性。</p>
</li>
<li><p>需求分析方法是如何帮助建立系统级需求的？</p>
<p>需求分析方法帮助建立系统级需求的过程包括：确定用户的需求和期望、建立用例图和类图，表示系统的功能和结构、绘制系统顺序图，描述系统和参与者之间的交互过程、绘制状态图，描述对象的状态和转换过程、通过建立不同模型来对需求进行抽象和概括，确保需求清晰、易于理解和传达。</p>
</li>
<li><p>为下列描述建立用例模型，要求明确给出建模过程：现在需要开发一个简化了的大学图书馆系统，它有几种类型的借书人，包括教职工借书人、研究生借书人和本科生借书人等。借书人的基本信息包括姓名、地址和电话号码等。对于教职工借书人，还要包括诸如办公室地址和电话等信息。对于研究生借书人，还要包括研究项目和导师信息等。对于本科生借书人，还要包括项目和所有学分信息等。图书馆系统要跟踪借出图书的信息。当一个借书人捧着一堆书去借书合办理借书手续时，借出这个事件就发生了。一个借书人可以多次从图书馆中借书，也可以一次借出多本图书。如果借书人想要的书已被借出，他可以预约。每个预约只针对一个借书人和一个书名。预约日期、优先权和完成日期等信息需要维护。当借书完成，系统会将这本书与借出联系起来。借书人根据图书馆的信息来检索书名，同时检索这本书是否可以被借出。如果一本书的所有副本都被借出了，那么借书人可以根据书名预订这本书。当借书人把书拿到借书台的时候，管理员可以为这些书办理归还手续。管理员要跟踪新书到达的情况。图书馆的管理者有属于自己的活动。他们要分类打出关于书名的表格，还要在线检查所有过期末还的书，标记出来。而且，图书馆系统还可以从另外一个大学的数据库中访问和下载借书人的信息。</p>
</li>
<li><p>下面是一段需求描述，请依据其建立 ATM 系统的概念类图。
A银行计划在B大学开设银行分部，计划使用 ATM 提供全部服务。ATM 系统将通过显示屏幕、输入键盘（有数宇键和特殊符号键）、银行卡读卡器、存款插槽、收据打印机等设备与客户交互。客户可以使用 ATM 进行存款、取款、余额查询等操作，它们对账户的更新将交由账户系统的一个接口来处理。安全系统将为每个客户分配一个PIN 码和安全级别。每次事务执行之前都需要验证该 PIN 码。在将来，银行还计划使用 ATM 支持些常规的操作，例如地址和电话号码修改。</p>
</li>
<li><p>有一条南北向的路和一条东西向的路形成了一个直行十字路口（不允许左转和右转）。南北向的路有一组交通信号灯，绿灯45秒，黄灯了秒，红灯30秒。东西向的路也有一组交通信号灯，绿灯27秒，黄灯3秒，红灯 48 秒。请用状态图描述该十字路口的交通信号灯的行为（要求给出建立状态图的过程）。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='七需求文档化与验证'>七、需求文档化与验证</h2>
<h3 id='1）文档化的原因'>（1）文档化的原因</h3>
<p><font color=red>为什么需要文档化/需要编写多种文档/需要需求规格说明：软件开发的子任务与人员之间存在错综复杂的关系，存在大量的沟通与交流，所以软件系统开发过程中需要编写以描述软件系统的解决方案。</font></p>
<h3 id='2）需求文档基础'>（2）需求文档基础</h3>
<ol start='' >
<li><p>需求文档的交流对象：</p>
<ol start='' >
<li>用户</li>
<li>项目管理者</li>
<li>设计人员和程序员</li>
<li>测试人员</li>
<li>文档编写人员</li>
<li>维护人员</li>

</ol>
</li>
<li><p>用例文档和软件需求规格说明文档是最常见的两种需求文档，用例文档从用户角度出发，以用例文本为主描述软件系统与外界的交互。软规文档则从软件产品的角度出发，以系统级需求列表的方式描述软件系统解决方案。</p>
</li>
<li><p>用例文档</p>
<ol start='' >
<li>以用例的文本描述为主组织需求的文档化，基本职责是把问题域信息和需求传达给软件系统解决方案的设计者。。</li>
<li>常见模版：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%889.04.55.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午9.04.55"></li>

</ol>
</li>
<li><p>软件需求规格说明文档</p>
<ol start='' >
<li>软规文档描述软件系统的解决方案。</li>
<li>常见模版：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%889.06.09.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午9.06.09"></li>

</ol>
</li>

</ol>
<h3 id='3）需求文档化要点'>（3）需求文档化要点</h3>
<ol start='' >
<li><p><em>技术文档写作要点</em></p>
<ol start='' >
<li><p>简洁：内容不能过于复杂，语法平铺直叙。</p>
</li>
<li><p>精确：不能使用模糊或歧义词汇。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%889.08.12.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午9.08.12"></p>
</li>
<li><p>易读（查询）：方便技术人员快速查阅</p>
<ol start='' >
<li>有效使用引言、目录、索引等</li>
<li>使用系统化的方式组织内容信息，提供文档内容的可读性</li>

</ol>
</li>
<li><p>易修改</p>
<ol start='' >
<li>引言、目录、索引等也能增强易修改性</li>
<li>引用代替重复，减少冗余重复信息</li>

</ol>
</li>

</ol>
</li>
<li><p>需求书写要点</p>
<ol start='' >
<li><p>使用用户术语：保证对用户易读，避免专业术语（如“函数”、“对象”等）。</p>
</li>
<li><p>可验证：</p>
<ol start='' >
<li>保证需求可验证，通过分析、检查、模拟或测试等手段判断需求是否被满足。</li>
<li>描述需求不能过于模糊或抽象。</li>

</ol>
</li>
<li><p>可行性：需求能够在系统及其环境的已知条件和约束下实现，包括技术可行性和成本、时间、人员的要求。</p>
</li>

</ol>
</li>
<li><p>软规文档书写要点</p>
<ol start='' >
<li><p>充分利用标准的文档模版，保持所有内容位置得当</p>
</li>
<li><p>保持文档内的需求集具有完备性和一致性</p>
<ol start='' >
<li>完备性要求不能遗漏重要的需求或者信息</li>
<li>一致性要求不同需求之间不能相互冲突</li>

</ol>
</li>
<li><p>为需求划分优先级：保证优先实现重要的需求，减少损失。</p>
</li>

</ol>
</li>

</ol>
<h3 id='4）评审软规文档'>（4）评审软规文档</h3>
<ol start='' >
<li><p>评审是进行需求验证与确认的主要方法，原则上每条需求都应该进行评审。</p>
</li>
<li><p>评审需求的注意事项</p>
<ol start='' >
<li><p>重视需求评审</p>
</li>
<li><p>需求评审的组织有要求</p>
<ol start='' >
<li>评审人员不能只有技术人员，需要包括客户和用户</li>
<li>在评审中使用线索</li>
<li>使用需求检查列表</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='5）以需求为基础开发系统测试用例'>（5）以需求为基础开发系统测试用例</h3>
<ol start='' >
<li><p>为需求开发测试用例是有效的需求验证方法，可以发现软规文档的缺陷和问题。</p>
</li>
<li><p>以需求为基础开发测试用例有两个步骤</p>
<ol start='' >
<li><p>以需求为线索，开发测试用例套件</p>
<ol start='' >
<li>测试用例套件是测试用例的集合，将相关的测试用例组织在一起，每个套件是目标明确的一项功能。</li>
<li>原则上除测试代价过高或过难的需求之外，所有需求都需要有测试用例套件覆盖。</li>
<li>通过用例描述的正常流程和异常流程为线索可以很好的建立套件。</li>

</ol>
</li>
<li><p>使用测试技术确定输入/输出数据，开发测试用例</p>
<ol start='' >
<li>对确定的测试用例套件，设计测试场景的输入与输出数据，建立测试用例。</li>
<li><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%8810.06.02.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午10.06.02"></li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='6）度量需求'>（6）度量需求</h3>
<p>重要度量数据</p>
<ol start='' >
<li>用例数量</li>
<li>平均每个用例的场景数量</li>
<li>平均用例行数</li>
<li>软件需求数量</li>
<li>非功能需求数量</li>
<li>功能点数量</li>

</ol>
<h3 id='7）习题-1'>（7）习题</h3>
<ol start='' >
<li><p>为什么需要将需求编写成文档？</p>
</li>
<li><p>收集资料，列举一下软件开发有哪些重要的文档。试着分析一下它们各自的交流目的是什么，交流对象有哪些。</p>
<ul>
<li>需求文档：明确系统的功能和性能要求，交流对象包括开发团队、测试团队、项目管理者和客户。</li>
<li>设计文档：描述系统的架构、模块设计和算法，交流对象包括开发团队和测试团队。</li>
<li>测试计划和测试用例文档：规划和描述测试的范围和方法，交流对象包括测试团队和开发团队。</li>
<li>用户手册：向最终用户提供使用系统的指导和说明，交流对象是最终用户。</li>
<li>API 文档：描述系统的应用程序接口，交流对象包括开发团队和集成团队。</li>
<li>项目计划文档：规划项目的进度和资源，交流对象包括项目管理者和相关利益相关者。</li>

</ul>
</li>
<li><p>技术文档写作有哪此要点？为什么？</p>
</li>
<li><p>软件需求规格说明文档有哪些读者？分析一下他们各自需要从文档中得到什么信息？</p>
<ul>
<li>项目管理者：了解项目的整体范围、进度和资源安排。</li>
<li>开发团队：理解系统的功能和性能要求，以便进行设计和编码。</li>
<li>测试团队：理解系统的功能需求，以编写测试用例和进行验证。</li>
<li>客户和最终用户：了解系统的功能和特性，确认是否符合需求。</li>

</ul>
</li>
<li><p>每一条独立需求的书写有哪此要点？请各给出一个不满足的例子。</p>
</li>
<li><p>软件需求规格说明文档的书写有哪些要点？</p>
</li>
<li><p>相较于软件开发中的其他制品评审，需求评审有哪些注意事项？</p>
<ul>
<li>确保需求的完整性和准确性。</li>
<li>澄清需求的不清楚或模糊之处。</li>
<li>检查需求是否具有一致性和可测试性。</li>
<li>确保需求的优先级和紧急性符合项目计划。</li>
<li>确保所有相关团队和利益相关者对需求有共识。</li>

</ul>
</li>
<li><p>什么是功能点？它有什么作用？</p>
<p>功能点是一种用于衡量软件系统规模和复杂性的指标，它表示软件中功能模块的数量和复杂程度。功能点用于评估软件开发工作的量和进度，以及进行软件项目的估算和计划。</p>
</li>
<li><p>如何计算功能点？</p>
<p>功能点计算通常使用以下两种方法：IFPUG（International Function Point Users Group）方法和 COSMIC（COnstructive Systems Engineering Cost Model）方法。这两种方法都是根据软件功能进行计算的，包括输入、输出、查询、文件和接口等功能。</p>
</li>

</ol>
<h1 id='软工-第四部分-软件设计'>软工-第四部分-软件设计</h1>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%8810.28.29.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午10.28.29"></p>
<h2 id='八软件设计基础'>八、软件设计基础</h2>
<h3 id='1）软件设计的核心思想'>（1）软件设计的核心思想</h3>
<ol start='' >
<li><p>软件设计的核心问题是控制系统复杂度，因此“分而治之”是解决复杂度问题的主要思路。</p>
</li>
<li><p>抽象和分解是软件设计的核心思想<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8A%E5%8D%8810.40.31.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 上午10.40.31"></p>
<ol start='' >
<li><p>分解</p>
<ol start='' >
<li>横向上将系统分割为几个相对简单的子系统以及各子系统之间的关系。</li>
<li>分解之后每次就只需要关注经过抽象的相对简单的子系统以及各子系统之间的关系，从而降低了复杂度。</li>

</ol>
</li>
<li><p>抽象</p>
<ol start='' >
<li>纵向上聚焦各子系统的接口。</li>
<li>抽象可以分离接口和实现，更好地关注系统本质，从而降低复杂度。</li>
<li>接口是各子系统之间交流的核心，使整个系统的关键所在。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='2）软件设计'>（2）软件设计</h3>
<ol start='' >
<li><p><em>软件设计：关于软件对象的设计，是一种设计活动，具有设计的普遍特性。</em>软件设计既指软件对象实现的规格说明，也指产生这个规格说明的过程。</p>
</li>
<li><p>从工程设计的角度看，软件设计要：</p>
<ol start='' >
<li>保持以用户为中心，为其建造有用的软件产品。</li>
<li>将设计知识科学化、系统化，并能够通过职业教育产生合格的软件设计师。</li>
<li>能够进行设计决策与折中，解决设计过程中出现的不确定性、信息不充分、要求冲突等复杂情况。</li>

</ol>
</li>
<li><p>从艺术设计的角度看：</p>
<ol start='' >
<li>软件要满足：效用、坚固、美感，还需要考虑软件产品的美感因素。</li>
<li>艺术处于中心地位，比工程性更重要，为此设计师需要发散思维和创新，与用户共情。</li>

</ol>
</li>
<li><p>理性主义和经验主义</p>
</li>
<li><p>软件设计的演化性</p>
</li>
<li><p>软件设计的决策性</p>
</li>
<li><p>软件设计的约束满足和多样性</p>
<ol start='' >
<li>多样性是的设计师解决同一个问题会产生不同的设计方案，需要进行权衡和折中。</li>
<li>约束帮助设计师暂时验证解空间多样设计方案的合理性，简化设计方案的选择决策。</li>

</ol>
</li>

</ol>
<h3 id='3）软件设计的分层'>（3）软件设计的分层</h3>
<ol start='' >
<li><p>软件设计有三个层次</p>
<ol start='' >
<li>高层设计（先进行）：基于反映软件高层抽象的构建层次，描述系统的高层结构、关注点和设计决策。</li>
<li>中层设计（之后进行）：关注组成构建的模块的划分、导入/导出、过程之间调用关系或者类之间的协作。</li>
<li>底层设计（最后进行）：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</li>

</ol>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8B%E5%8D%883.51.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 下午3.51.04"></p>
</li>
<li><p>通过设计分层可以减少需要同时关注的细节，降低设计师同一时间需要处理的复杂度。</p>
</li>

</ol>
<h3 id='4）软件设计的主要活动'>（4）软件设计的主要活动</h3>
<ol start='' >
<li><p>软件设计分为4个主要活动<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-23%20%E4%B8%8B%E5%8D%883.53.22.png" referrerpolicy="no-referrer" alt="截屏2023-07-23 下午3.53.22"></p>
<ol start='' >
<li>分析设计出发点：了解功能性需求、非功能性需求、项目环境和人员限制等，获取设计的出发点。</li>
<li>建立候选方案</li>
<li>生成最终方案</li>
<li>评价：检查设计是否满足需求和约束，尤其要关注是否有漏洞，有未满足的情况就需要进行重新软件设计。</li>

</ol>
</li>
<li><p>要注意到返工的现象在设计中很常见。</p>
</li>

</ol>
<h3 id='5）软件设计的方法和模型'>（5）软件设计的方法和模型</h3>
<ol start='' >
<li><p>软件设计的方法</p>
<ol start='' >
<li>结构化设计</li>
<li>面向对象设计</li>
<li>数据结构为中心设计</li>
<li>基于构件的设计</li>
<li>形式化方法设计</li>

</ol>
</li>
<li><p>软件设计的模型</p>
<ol start='' >
<li>静态模型：通过快照的方式描述系统，描述状态而不是行为。如实体关系图、类图、对象图、构件图、部署图等。</li>
<li>动态模型：描述系统行为和状态转移。如数据流图、结构图、交互图（顺序图和通信图）、状态图、活动图等。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='九软件体系结构基础'>九、软件体系结构基础</h2>
<h3 id='1）软件体系结构'>（1）软件体系结构</h3>
<ol start='' >
<li>软件体系结构的定义：软件体系结构={部件，连接件，配置}，一个软件系统的体系结构规定了系统的计算部件和部件之间的交互。</li>

</ol>
<h3 id='2）体系结构风格'>（2）体系结构风格</h3>
<ol start='' >
<li><p>主程序/子程序风格</p>
<ol start='' >
<li><p>主子风格将系统组织称层次结构，包括一个主程序和一系列子程序。主程序是系统的控制器，负责调度各子程序的执行。子程序又是一个局部的控制器，负责调度其子程序的执行。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.27.01.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.27.01"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>基于声明一使用（程序调用）关系建立连接件，以层次分解的方式建立系统部件，共同组成层次结构。</li>
<li>每一个上层部件可以“使用”下层部件，但下层部件不能“使用”上层部件，即不允许逆方向调用。</li>
<li>系统应该是单线程执行。主程序部件拥有最初的执行控制权，并在“使用”中将控制权转移给下层子程序。</li>
<li>子程序只能够通过上层转移来获得控制权，可以在执行中将控制权转交给下层的子子程序，并在自身执行完成之后将控制权交还给上层部件。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>流程清晰，易于理解。</li>
<li>强控制性。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>程序调用是一种强耦合的连接方式，难以修改和复用。</li>
<li>程序调用的连接方式限制了各部件之间的数据交互，产生不必要的公告耦合。</li>

</ol>
</li>
<li><p>应用：主要用于能够将系统功能依层次分解为多个顺序执行步骤的系统。</p>
</li>

</ol>
</li>
<li><p>面向对象式风格</p>
<ol start='' >
<li><p>面对风格将系统组织为多个独立的对象，每个对象封装其内部的数据，并基于数据对外提供服务，不同对象直接协作机制共同完成系统任务。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.31.24.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.31.24"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>依照对数据的使用情况，用信息内聚的标准为系统建立对象部件。每个对象部件基于内部数据提供对外服务接口．并隐藏内部数据的表示。</li>
<li>基于方法调用机制建立连接件，将对象部件连接起来。每个对象负责维护其自身数据的一致性与完整性，并以此为基础对外提供“正确”的服务。</li>
<li>每个对象都是一个自治单位，不同对象之间是平级的，没有主次、从属、层次、分解等关系。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>内部实现的可修改性。</li>
<li>易开发、易理解、易复用的组织结构。</li>

</ol>
</li>
<li><p>缺口：</p>
<ol start='' >
<li>接口的耦合性。</li>
<li>标识的耦合性。</li>
<li>副作用。</li>

</ol>
</li>
<li><p>应用：适用于能够基于数据信息分解和组织的软件系统，将数据信息和相关操作联系起来并封装。</p>
</li>

</ol>
</li>
<li><p>分层风格</p>
<ol start='' >
<li><p>根据不同的抽象层次，将系统组织为层次式结构。每个层次被建立为一个部件，不同部件之间通常用程序调用的方式进行连接，连接件被建立为程序调用机制。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.38.26.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.38.26"></p>
</li>
<li><p>重要设计决策与约束</p>
<ol start='' >
<li>从最底层到最高层，部件的抽象层次逐渐提升。每个下层为邻接上层提供服务，每个上层将邻接下层作为基础设施使用。也就是说，在程序调用机制中上层调用下层。</li>
<li>两个层次之间的连接要遵守特定的交互协议，该交互协议应该是成熟、稳定和标准化的。也就是说，只要遵守交互协议，不同部件实例之问是可以互相替换的。</li>
<li>跨层次的连接是禁止的。</li>
<li>逆向的连接是禁止的。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>设计机制清晰，易于理解。</li>
<li>支持并行开发。</li>
<li>更好地可复用性与内部可修改性。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>交互协议难以修改。</li>
<li>性能损失。</li>
<li>难以确定层次数量和粒度。</li>

</ol>
</li>
<li><p>应用：</p>
<ol start='' >
<li>主要功能是在不同抽象层次上进行任务分解的复杂处理。</li>
<li>能够建立不同抽象层次之间的稳定交互协议。</li>
<li>没有很高的实时性要求。</li>

</ol>
</li>

</ol>
</li>
<li><p>MVC风格</p>
<ol start='' >
<li><p>以程序调用为连接件，将系统功能组织为模型、视图和控制三个部件。模型封装了系统的数据和状态信息，实现业务逻辑，对外提供数据服务和执行业务逻辑。视图封装了用户交互，提供业务展现，接收用户行为。控制封装了系统的控制逻辑，根据用户行为调用需要执行的业务逻辑和数据更新，并且根据执行后的系统状态决定后续的业务展现。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.42.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.42.49"></p>
</li>
<li><p>重要设计决策与约束：</p>
<ol start='' >
<li>模型、视图、控制分别是关于业务逻辑、表现和控制的三种不同内容抽象。</li>
<li>如果视图需要持续地显示某个数据的状态，那么它首先需要在模型中注册对该数据的兴趣。如果该数据状态发生了变更，模型会主动通知视图，然后再由视图查询数据的更新情况。</li>
<li>视图只能使用模型的数据查询服务，只有控制部件可以调用可能修改模型状态的程序。</li>
<li>用户行为虽然由视图发起，但是必须转交给控制部件处理。对接收到的用户行为，控制部件可能会执行两种处理中的一种或两种：调用模型的服务，执行业务逻辑；提供下一个业务展现。</li>
<li>模型部件相对独立，既不依赖于视图，也不依赖于控制。虽然模型与视图之问存在一个“通知变更〞的连接，但该连接的交互协议是非常稳定的，可以认为是非常弱的依赖。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>易开发性。</li>
<li>视图和控制的可修改性。</li>
<li>适宜于网络系统开发的特征。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>复杂性。</li>
<li>模型修改困难。</li>

</ol>
</li>
<li><p>应用：主要用于网络系统的开发。</p>
</li>
<li><p>分层风格和MVC风格的比较：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-24%20%E4%B8%8A%E5%8D%889.45.25.png" referrerpolicy="no-referrer" alt="截屏2023-07-24 上午9.45.25"></p>
</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十软件体系结构设计与构建'>十、软件体系结构设计与构建</h2>
<h3 id='1）体系结构设计过程'>（1）体系结构设计过程</h3>
<ol start='' >
<li><p>分析关键需求和项目约束</p>
</li>
<li><p>选择体系结构风格</p>
</li>
<li><p>进行软件体系结构逻辑（抽象）设计</p>
<ol start='' >
<li><p>逻辑设计的目的是建立能够满足概要功能需求、质量需求与约束的软件体系结构抽象设计方案。</p>
</li>
<li><p>设计过程：</p>
<ol start='' >
<li>依据需求和体系风格建立初始设计</li>
<li>使用非功能性需求与约束评价并改进初始设计</li>

</ol>
</li>

</ol>
</li>
<li><p>依赖逻辑设计进行软件体系结构物理（实现）设计</p>
<ol start='' >
<li><p>将逻辑设计从开发（开发包、物理模块）、发布（进程）、部署（网络部署）三个角度进行实现，建立软件体系结构的物理设计。</p>
</li>
<li><p>设计过程</p>
<ol start='' >
<li>开发包（构件）设计</li>
<li>运行时进程</li>
<li>物理部署</li>

</ol>
</li>

</ol>
</li>
<li><p>完善软件体系结构设计</p>
</li>
<li><p>定义构件接口</p>
</li>
<li><p>迭代过程3～6</p>
</li>

</ol>
<h3 id='2）体系结构的原型创建'>（2）体系结构的原型创建</h3>
<ol start='' >
<li><p>包的创建</p>
<ol start='' >
<li>包是用于将系统组织成层次结构的机制，根据构件的设计来创建项目的包。</li>
<li>包的创建原则：逻辑设计中的每一个包对应一个开发包（开发包、依赖的其他包）。</li>

</ol>
</li>
<li><p>重要文件的创建</p>
</li>
<li><p>定义构件之间的接口</p>
<ol start='' >
<li>提供的服务（供接口）：语法、前置条件、后置条件</li>
<li>需要的服务（需接口）：服务名、服务</li>

</ol>
</li>
<li><p>关键需求的实现</p>
</li>

</ol>
<h3 id='3）体系结构集成与测试'>（3）体系结构集成与测试</h3>
<ol start='' >
<li><p>集成的策略：</p>
<ol start='' >
<li><p>大爆炸式</p>
<ol start='' >
<li>一次性将所有模块组合在一起。</li>
<li>优点：可以在短时间内迅速完成集成测试。</li>
<li>缺点：问题的定位和修改困难。</li>
<li>适合应用于一个维护性项目或被测试系统规模较小。</li>

</ol>
</li>
<li><p>自顶向下式——增量式</p>
<ol start='' >
<li><p>对分层次的架构，先集成和测试上层的模块，下层的模块使用伪装的桩，然后不断加入下层模块直到集成所有模块。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>按深度优先可以首先实现和验证一个完整的功能需求</li>
<li>只需最顶端一个驱动</li>
<li>利于故障定位</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>桩的开发量大</li>
<li>底层验证被推迟，且底层组建测试不充分</li>

</ol>
</li>
<li><p>适用于控制结构比较清晰和稳定、高层接口变化小、底层接口未定义或经常可能被修改、控制组件具有较大的技术风险的软件系统。</p>
</li>

</ol>
</li>
<li><p>自底向上式——增量式</p>
<ol start='' >
<li><p>从最底层的模块集成测试起，上层用伪装的接口替换。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>对底层组件验证较早</li>
<li>底层组件开发可以并行</li>
<li>桩的工作量小</li>
<li>利于故障定位</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>驱动开发量大</li>
<li>对高层的验证被推迟，设计上的高层错误不能被及时发现</li>

</ol>
</li>
<li><p>适用于底层接口比较稳定、高层接口变化频繁、底层接口较早被完成的系统。</p>
</li>

</ol>
</li>
<li><p>三明治式——增量式</p>
</li>
<li><p>持续集成——增量式</p>
<ol start='' >
<li><p>提倡尽早集成和频繁集成。</p>
</li>
<li><p>尽早集成就是不等待一个模块开发完再集成，而是在开发之初就利用stub集成起来。</p>
</li>
<li><p>提倡集成即开发者每次完成一些开发任务之后，就用开发结果替换stub中的相应组件，进行集成与测试。</p>
</li>
<li><p>优点/可以做到：</p>
<ol start='' >
<li>防止软件开发中出现无法集成与发布的情况</li>
<li>有利于检查和发现集成缺陷</li>

</ol>
</li>
<li><p>持续集成的频率很高，所以需要版本控制工具和持续集成工具。</p>
</li>

</ol>
</li>

</ol>
</li>
<li><p>桩（stub）</p>
<ol start='' >
<li>stub在软件测试中用来替换某些模块，一般和所替换的模块有相同接口，并且模拟了模块的行为。</li>
<li>stub模仿的是下层模块，用来测试上层。</li>

</ol>
</li>
<li><p>驱动（driver）</p>
<ol start='' >
<li>模仿上层模块，用来测试下层。</li>
<li>利用下层提供的接口，实现其模仿的模块的功能，用来替换上层的接口。</li>
<li>执行的是用于测试模块接口的集成测试用例。</li>

</ol>
</li>
<li><p>软件体系结构文档</p>
<ol start='' >
<li>描述软件整体结构，包括整个系统的逻辑和物理的组成、模块与模块之间的接口、模块与模块之间的交互、模块内部的结构、模块对外提供的接口、模块需要访问的外部接口、整体数据模型、运行时进程、系统的部署等。</li>

</ol>
</li>

</ol>
<h3 id='4）体系结构评审'>（4）体系结构评审</h3>
<ol start='' >
<li><p>评审重点是体系结构中的决策是否合理，理由是否合理，是否考虑了足够的风险等。</p>
</li>
<li><p>评审考察方面：</p>
<ol start='' >
<li>设计方案正确性、先进性、可行性；</li>
<li>系统组成、系统要求及接口协调的合理性；</li>
<li>对于功能模块的输人参数、输出参数的定义是否明确；</li>
<li>系统性能、可靠性、安全性要求是否合理；</li>
<li>文档的描述是否清晰、明确。</li>

</ol>
</li>

</ol>
<h3 id='5）习题-1'>（5）习题</h3>
<ol start='' >
<li><p>一般从哪几个视角来描述设计体系结构？</p>
<p>一般从以下几个视角来描述设计体系结构：</p>
<ul>
<li>组合视角：描述系统的组成部分及其之间的关系。</li>
<li>逻辑视角：关注系统功能、行为和数据的组织。</li>
<li>物理视角：描述系统的物理组成、部署和运行时环境。</li>
<li>进程视角：关注系统的并发性和交互。</li>

</ul>
</li>
<li><p>组合视角一般会利用 UML 的哪些图来描述？</p>
<p>组合视角一般会利用 UML 的以下图来描述：</p>
<ul>
<li>组件图：用于表示系统的组成部分及其之间的依赖关系。</li>
<li>部署图：用于描述系统的物理组成和部署结构。</li>

</ul>
</li>
<li><p>逻辑视角和物理视角的区别是什么？</p>
<p>逻辑视角和物理视角的区别：</p>
<ul>
<li>逻辑视角关注系统的功能和行为，强调系统的功能划分和模块化设计，通常使用类图、用例图等UML图来描述。</li>
<li>物理视角关注系统的物理组成和运行时环境，描述系统的部署结构和硬件配置，通常使用部署图等UML图来描述。</li>

</ul>
</li>
<li><p>如何挑选体系结构风格？</p>
<p>挑选体系结构风格的步骤：</p>
<ul>
<li>理解需求和目标：深入理解系统的需求、质量属性和约束条件。</li>
<li>考虑技术和环境：考虑开发团队的技术能力、开发环境和运行环境。</li>
<li>对比和评估：对不同的体系结构风格进行对比和评估，看哪种风格更适合满足需求和目标。</li>
<li>考虑复用和成本：考虑现有的体系结构模式和已有的组件资源，以及体系结构的开发和维护成本。</li>

</ul>
</li>
<li><p>如何描述一个接口？</p>
<p>描述一个接口一般包括以下内容：</p>
<ul>
<li>接口名称：标识接口的名称，以便于识别和引用。</li>
<li>输入和输出：明确接口的输入数据和输出结果。</li>
<li>方法和操作：描述接口的操作或方法，说明接口的功能和行为。</li>
<li>参数和返回值：定义接口的参数和返回值的数据类型和格式。</li>
<li>用例和应用场景：描述接口的使用场景和在系统中的应用情况。</li>
<li>约束和限制：定义接口的使用约束和限制条件，如安全性要求等。</li>

</ul>
</li>
<li><p>体系结构中信息视角如何描述？</p>
<p>体系结构中的信息视角描述系统中信息的组织、流动和处理。它主要关注数据和信息的结构、传递和处理过程。信息视角使用UML的类图、序列图等图形来表示，描述数据实体、数据之间的关系，以及数据在系统内部和与外部系统之间的流动和传递。</p>
</li>
<li><p>软件体系结构设计阶段有哪些其他的开发活动？</p>
<p>软件体系结构设计阶段的其他开发活动包括：</p>
<ul>
<li>需求分析：明确系统需求，包括功能需求、性能需求、非功能性需求等。</li>
<li>风险评估：评估体系结构设计的技术风险和项目风险，确保设计方案的可行性和稳定性。</li>
<li>技术选型：选择合适的技术、框架和工具，支持体系结构的实现和开发过程。</li>
<li>成本估算：估算体系结构设计和开发的成本，以确定项目的可行性和资源规划。</li>

</ul>
</li>
<li><p>如何选定关键需求？</p>
<p>选定关键需求的步骤：</p>
<ul>
<li>理解需求：深入理解用户需求和系统的关键功能。</li>
<li>识别优先级：根据系统的目标和重要性，确定哪些需求对系统的成功和核心功能至关重要。</li>
<li>客户参与：与客户或利益相关者一起评估和确认关键需求，确保设计方案满足其期望。</li>

</ul>
</li>
<li><p>为什么要实现体系架构原型？</p>
<p>实现体系结构原型的目的是验证和评估设计方案的可行性、有效性和有效性。通过实现一个简化的体系结构原型，可以及早发现设计中的问题和风险，并快速验证系统的关键功能和性能。</p>
</li>
<li><p>为什么要对关键需求进行端到端的实现？</p>
<p>对关键需求进行端到端的实现是为了确保系统在整个生命周期中满足这些需求，从需求到设计、开发、测试和部署都需要对关键需求进行全面的覆盖和验证，以确保系统最终交付的功能和性能符合预期。</p>
</li>
<li><p>什么时候撰写集成测试计划？什么时候实施集成测试？</p>
<p>集成测试计划撰写时间通常是在系统设计和开发阶段之后，确定系统的集成测试策略、范围、资源需求和进度安排。实施集成测试通常在软件开发阶段后期进行，当所有模块或组件已经开发完成并且准备集成时开始。</p>
</li>
<li><p>集成测试策略一般包含哪几种？</p>
<p>集成测试策略一般包括以下几种：</p>
<ul>
<li>自上而下集成：从上层模块开始逐步向下集成，逐步测试系统的完整性。</li>
<li>自下而上集成：从最底层的模块开始逐步向上集成，逐步测试系统的完整性。</li>
<li>大爆炸集成：同时集成多个模块或组件，测试整个系统的完整性和稳定性。</li>
<li>逐步集成：按照功能模块或模块组进行逐步集成，逐步测试系统的完整性。</li>

</ul>
</li>
<li><p>集成测试用例如何设计？</p>
<p>集成测试用例的设计要确保覆盖系统的所有功能和交互，以验证模块和组件之间的正确集成和交互。设计集成测试用例时，需要考虑不同模块之间的接口、数据流、错误处理等情况，并确保所有关键功能和关键路径都得到覆盖和测试。集成测试用例应该着重测试系统的整体功能和性能，以确保系统在集成后能正常运行和满足需求。</p>
</li>
<li><p>集成测试中的stub和driver如何设计？</p>
<ul>
<li>Stub：在测试过程中代替尚未开发或不可用的模块，用于模拟模块的功能，使得被测试模块能够独立运行。Stub通常返回预先定义好的数据，以便测试模块能够继续进行下去。</li>
<li>Driver：在测试过程中代替被测模块的上层或下层模块，用于驱动被测试模块的执行。Driver通常调用被测试模块的功能，并传递预先定义好的测试数据，以模拟上层或下层模块的行为。</li>

</ul>
</li>
<li><p>如何做持续集成？</p>
<ol start='' >
<li>版本控制：使用版本控制工具（如Git）管理项目代码。确保所有开发人员都将代码提交到共享的版本控制库中。</li>
<li>自动构建：配置自动化构建工具（如Jenkins、Travis CI、CircleCI等）来自动执行构建任务。构建任务包括获取最新代码、编译代码、生成可执行文件或部署包等。</li>
<li>自动化测试：编写并配置自动化测试用例，包括单元测试、集成测试和端到端测试。确保所有测试用例可以自动执行，并能够在构建过程中运行。</li>
<li>触发构建：设置触发构建的条件，例如代码提交到版本控制库后自动触发构建，或定时执行构建任务。</li>
<li>构建报告：生成构建报告，记录构建过程中的日志、测试结果和代码覆盖率等信息，便于开发团队查看构建状态和测试结果。</li>
<li>快速反馈：持续集成的目标是尽早发现问题，因此需要及时向开发人员提供构建和测试的结果。如果构建或测试失败，需要及时通知相关人员，并尽快解决问题。</li>
<li>集成环境：确保持续集成的集成环境是稳定和可靠的。集成环境应该与生产环境尽可能相似，以便及早发现可能在生产环境中出现的问题。</li>
<li>持续改进：定期评估持续集成的效果，包括构建时间、测试覆盖率、错误率等指标。根据评估结果，优化构建和测试过程，提高持续集成的效率和质量。</li>

</ol>
</li>
<li><p>体系结构设计评审的目标是什么？</p>
<p>体系结构设计评审的目标是确保体系结构设计满足系统需求，符合预期目标，并满足质量属性要求。评审的目标还包括发现潜在的问题、风险和冲突，以及提供改进和优化建议。</p>
</li>
<li><p>体系结构设计评审会邀请什么人来参加？</p>
<p>参加体系结构设计评审的人员包括：</p>
<ul>
<li>项目经理：了解项目的目标、约束和风险，确保设计符合项目管理和业务目标。</li>
<li>架构师：负责体系结构设计，解释设计决策并回答技术问题。</li>
<li>开发团队：参与讨论和提供实现建议。</li>
<li>质量保障团队：确保体系结构满足质量属性要求。</li>
<li>利益相关者：可能影响系统设计和决策的相关人员。</li>

</ul>
</li>
<li><p>体系结构评审时的关注点有哪些方面？</p>
<p>体系结构评审时的关注点包括：</p>
<ul>
<li>模块划分和组织：检查模块的职责和功能划分是否合理。</li>
<li>接口设计：验证模块之间的接口定义是否清晰和一致。</li>
<li>系统质量属性：确保设计满足性能、可靠性、安全性等质量属性的要求。</li>
<li>可扩展性：评估系统的可扩展性，以适应未来的需求变化。</li>
<li>技术选型：确认所选技术是否适合系统的需求和目标。</li>

</ul>
</li>
<li><p>体系结构设计文档一般有哪些重要组成部分？</p>
<p>体系结构设计文档一般包括以下重要组成部分：</p>
<ul>
<li>需求分析：对系统需求的描述和分析，包括功能需求和非功能性需求。</li>
<li>架构设计：对系统体系结构的整体描述，包括模块划分、组件关系、接口定义等。</li>
<li>技术选型：对所选技术、框架和工具的描述和理由。</li>
<li>质量属性：对系统质量属性（性能、安全性等）的要求和设计决策。</li>
<li>接口设计：对模块之间的接口定义和数据交换方式的描述。</li>
<li>安全设计：对系统安全机制和措施的描述。</li>
<li>扩展性和可维护性：对系统的扩展性和可维护性设计的说明。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十一人机交互设计'>十一、人机交互设计</h2>
<h3 id='1）人机交互设计的目标'>（1）人机交互设计的目标</h3>
<ol start='' >
<li><p>人机交互的目的是探索在人和机器之间沟通的有效方法，让用户利用机器顺利完成任务。好的人机交互应该是透明的，需要符合用户的习惯特点，适应用户的技能和经验。</p>
</li>
<li><p>“透明”是人机交互的目标，也就是“易用性”，易用性的维度包括：</p>
<ol start='' >
<li>易学性：新手用户容易学习，度量方法是完全没有经过培训的用户完成特定任务所需时间。</li>
<li>效率：熟练用户使用系统完成任务的速度，度量方法是经过培训的熟练用户完成特定任务所需时间。</li>
<li>易记性：以前使用过系统的用户能够有效记忆或快速重新学会使用系统，度量方法是以前使用过系统的用户完成特定任务的时间。</li>
<li>出错率：用户在使用系统时犯错的程度和能否恢复错误，度量方法是用户完成特定任务或一段时间内的出错数量。</li>
<li>主观满意度：非客观度量，通过问卷获得用户的主观评价。</li>

</ol>
</li>

</ol>
<h3 id='2）人机交互设计的人类因素'>（2）人机交互设计的人类因素</h3>
<ol start='' >
<li><p>精神模型：即用户进行人机交互时头脑中的任务模型，人机交互设计需要依据精神模型进行隐喻设计，又称视觉隐喻，让用户将视觉上的图形映射为业务事物。</p>
</li>
<li><p>差异性：针对不同用户群体的设计也要有差异性，用户群体可以分为：</p>
<ol start='' >
<li>新手用户</li>
<li>专家用户</li>
<li>熟练用户</li>

</ol>
</li>

</ol>
<h3 id='3）人机交互设计的计算机因素'>（3）人机交互设计的计算机因素</h3>
<ol start='' >
<li><p>可视化设计</p>
<ol start='' >
<li>要点是按照任务模型设计界面隐喻，同时避免暴露软件系统的内部构造机制。</li>
<li>同时要基于界面隐喻，尽可能将功能和任务细节表现出来。</li>

</ol>
</li>
<li><p>常见界面类型：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%889.12.16.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午9.12.16"></p>
</li>
<li><p>软件系统通常同时使用多种界面类型，以适应差异性的用户和任务。</p>
</li>

</ol>
<h3 id='4）人机交互设计的交互性'>（4）人机交互设计的交互性</h3>
<ol start='' >
<li><p>系统计算时间过长，15s～3min就需要提供动画以减少等待感，3min以上就需要进度条让用户感到系统在工作。</p>
</li>
<li><p>人机交互设计原则</p>
<ol start='' >
<li><p>简介设计：7+-2原则，不要展现太多复杂无关的信息。</p>
</li>
<li><p>一致性设计</p>
</li>
<li><p>低出错率设计</p>
<ol start='' >
<li>使用清晰的语音而非代码</li>
<li>语言应当精炼准确，而不是空泛、模糊</li>
<li>应当对用户解决问题提供建设性的帮助</li>
<li>出错信息应该友好，不要威胁或责备</li>
<li>提供错误恢复和故障解决手册</li>

</ol>
</li>
<li><p>易记性设计</p>
<ol start='' >
<li>减少短期记忆负担</li>
<li>逐层递进的方式展示信息</li>
<li>直观的快捷方式</li>
<li>有意义的默认值</li>

</ol>
</li>

</ol>
</li>
<li><p>导航：提供完成任务的入口。</p>
</li>
<li><p>反馈：视觉、声音上的反馈，让用户能够意识到行为的结果，提示用户交互行为的后果。</p>
</li>
<li><p>协作式设计：调整计算机因素以更好地适应并帮助用户的设计方法。人和计算机是人机交互的两方，其中人的因素是比较固定的，所以需要让计算机更多的适应人的因素，这也是为什么需要以用户为中心。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十二详细设计的基础'>十二、详细设计的基础</h2>
<h3 id='1）详细设计概述'>（1）详细设计概述</h3>
<ol start='' >
<li><p>详细设计的出发点：</p>
<ol start='' >
<li>需求开发的结果（需求规格说明和需求分析模型）</li>
<li>软件体系结构的结果（软件体系结构设计方案与原型）</li>

</ol>
</li>
<li><p>详细设计应该在软件体系结构设计之后进行。</p>
</li>

</ol>
<h3 id='2）结构化设计'>（2）结构化设计</h3>
<ol start='' >
<li>结构化设计按算法对系统进行分解。</li>
<li>结构化设计主要建模技术是结构图，按照自顶向下分解法，将系统分解为一个树状结构。通过结构图可以知道系统的复杂度、实现功能需要的模块或者方法、方法是否能够被管理或再分解。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.29.51.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.29.51"></li>

</ol>
<h3 id='3）面向对象设计'>（3）面向对象设计</h3>
<ol start='' >
<li><p>面向对象将系统抽象成具有一定职责的数据个体，个体之间互相协作完成任务。每个数据个体除有自己的独特的数据信息，还包含一些依赖这些数据所做的事。</p>
</li>
<li><p>再将系统分解为小的数据个体的时候，是按照数据个体的单一职责来分解的。</p>
</li>
<li><p>设计过程：</p>
<ol start='' >
<li><p>设计模型建立</p>
<ol start='' >
<li><p>职责分配：</p>
<ol start='' >
<li><p>抽象类的职责</p>
</li>
<li><p>抽象类之间的关系</p>
<ol start='' >
<li>关系表达了相应职责的划分和组合</li>
<li>依赖&lt;关联&lt;聚合&lt;组合&lt;继承</li>
<li><img src="https://wbw2333.github.io/assets/软工-第n部分/截屏2023-07-25 上午10.39.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.39.59"> <img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.40.18.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.40.18"></li>

</ol>
</li>
<li><p>添加辅助类</p>
</li>

</ol>
</li>
<li><p>通过协作建立动态设计模型</p>
<ol start='' >
<li><p>抽象对象之间协作</p>
</li>
<li><p>明确对象的创建<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.53.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.53.59"></p>
</li>
<li><p>选择合适的控制风格<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.54.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.54.38"></p>
<ol start='' >
<li>集中式：做决策的只有一个对象，这个对象决定怎么分配职责，怎么实现大职责。所有其他对象只和这个对象进行交互。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.11.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.11"></li>
<li>委托式：做出决策的对象不止一个，这些对象分别承担一定职责，做出一些决策，共同实现大职责。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.51.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.51"></li>
<li>分散式：无明确的控制对象，每个对象只承担一个小职责，完全靠各个对象自治实现大职责。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.19.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.19"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8810.59.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午10.59.39"></li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>设计模型重构</p>
<ol start='' >
<li>根据模块化的思想重构，目标为高内聚、低耦合</li>
<li>根据信息隐藏的思想重构，目标为隐藏职责与变更</li>
<li>利用设计模式重构</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）为类间协作开发集成测试用例'>（4）为类间协作开发集成测试用例</h3>
<ol start='' >
<li><p>每个类在被独立开发完成后，也需要类间协作的集成测试，需要以详细设计模型为基础为类间协作开发集成测试用例，类间协作通常以协作图为线索开发模块内部的集成测试用例。</p>
</li>
<li><p>类间协作集成分为：</p>
<ol start='' >
<li>自顶向下：从协作的发起端开始向协作终端集成，需要较少的驱动代码和较多的桩程序。</li>
<li>自底向上：从协作的终端开始向协作发起端集成，需要较多的驱动代码和较少的桩代码。</li>

</ol>
</li>
<li><p>类间协作的桩程序称为Mock Object，要求自身测试代码简单，可以不测试就保证正确性。</p>
</li>

</ol>
<h3 id='5）详细设计文档描述'>（5）详细设计文档描述</h3>
<p>软件详细设计文档强调模块内部的结构和行为，如类图、类接口定义、类协作、复杂数据结构定义、复杂算法逻辑等。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8811.05.01.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午11.05.01"></p>
<h3 id='6）详细设计评审'>（6）详细设计评审</h3>
<p>评审不仅要关注详细设计阶段的工作，还要综合看待整个设计。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-25%20%E4%B8%8A%E5%8D%8811.05.35.png" referrerpolicy="no-referrer" alt="截屏2023-07-25 上午11.05.35"></p>
<h3 id='7）习题-2'>（7）习题</h3>
<ol start='' >
<li><p>详细设计的关注点在哪里？</p>
<p>详细设计的关注点在于对系统的功能和模块进行具体的设计，包括数据结构、算法、接口、错误处理和性能优化等方面。</p>
</li>
<li><p>详细设计的过程是怎样的？</p>
<p>详细设计的过程一般包括以下步骤：</p>
<ul>
<li>理解需求：深入理解需求规格和体系结构设计，确定功能和模块划分。</li>
<li>设计数据结构：定义系统中数据的结构和类型，包括数据库表设计和数据交换格式。</li>
<li>设计算法和逻辑：设计实现各个功能和模块的具体算法和处理逻辑。</li>
<li>接口设计：定义模块之间的接口和数据交换方式。</li>
<li>错误处理：设计对异常情况和错误的处理机制，确保系统的容错性和稳定性。</li>
<li>性能优化：考虑代码的执行效率和性能，优化算法和代码结构，以提高系统的运行效率。</li>

</ul>
</li>
<li><p>什么是详细设计的上下文？</p>
<p>详细设计的上下文是指在系统体系结构设计的基础上，对具体的模块进行更为详细的设计。详细设计依赖于体系结构设计，将系统的整体设计细化为各个模块的具体实现。</p>
</li>
<li><p>存在完美的理性设计过程吗？</p>
<p>不存在完美的理性设计过程。设计是一个复杂的过程，需要考虑众多因素和权衡各种需求。即使进行了详尽的计划和分析，也难以完全预见所有情况和需求变化。因此，设计过程中难免会出现一些不完美或需要改进的地方。</p>
</li>
<li><p>真实的设计过程是如何的？</p>
<p>真实的设计过程是复杂和动态的。它通常涉及不断的反馈和迭代，从最初的草图和初步设计逐渐完善和优化。设计过程中可能会面临需求变更、技术限制、时间压力等挑战，需要不断调整和适应。</p>
</li>
<li><p>结构化详细设计的重点是什么？</p>
<p>结构化详细设计的重点在于合理划分模块和功能，确保模块之间的高内聚和低耦合。结构化设计强调模块的分解和功能的划分，使得系统的设计结构清晰、易于理解和维护。重点包括数据结构的设计、算法的设计、接口的定义和错误处理的设计。结构化设计追求模块的独立性和可重用性，以便在不同系统中进行复用和扩展。</p>
</li>
<li><p>如何将数据流图转换为结构图？</p>
<p>将数据流图转换为结构图的步骤：</p>
<ul>
<li>确定功能和模块：根据数据流图，识别各个功能和模块。</li>
<li>识别输入和输出：确定模块的输入和输出数据流。</li>
<li>划分模块：将数据流图中的功能和模块分解为更小的可处理单元。</li>
<li>确定数据存储：标识模块间的数据存储和传递方式。</li>
<li>构建结构图：使用合适的图形符号和连接线，绘制模块的结构图。</li>

</ul>
</li>
<li><p>面向对象详细设计的步骤和重点是什么？</p>
<p>步骤：</p>
<ol start='' >
<li>定义类和对象：根据需求分析和系统架构设计，确定系统中需要的类和对象，包括识别实体类、边界类和控制类。</li>
<li>确定类的属性和方法：为每个类确定合适的属性和方法，这些属性和方法应该与类的职责和功能相匹配。</li>
<li>确定类之间的关系：根据系统的业务逻辑和功能需求，确定类之间的关系，包括继承、关联、聚合、组合等。</li>
<li>设计类的接口：定义类的公共接口，即外部可以访问的方法，确保类的封装性和信息隐藏。</li>
<li>定义类的行为：描述每个类的具体行为，包括方法的算法和处理逻辑。</li>
<li>设计类的状态：如果类具有状态，需要定义类的状态和状态转换。</li>
<li>确定类的实例化：确定类在系统中如何被实例化和管理。</li>

</ol>
<p>重点：</p>
<ol start='' >
<li>类的职责和功能：确保每个类的职责清晰明确，遵循单一职责原则，一个类应该有一个明确的目标。</li>
<li>类的关系：确定类之间的关系，包括继承、关联、聚合、组合等，确保类之间的关系合理并满足系统需求。</li>
<li>类的接口：设计类的公共接口，确保接口的合理性和易用性，隐藏类的内部实现细节。</li>
<li>类的封装性：封装类的属性和方法，确保类的内部实现对外部的透明性，避免直接访问类的内部数据。</li>
<li>方法的算法和逻辑：设计方法的算法和处理逻辑，确保方法的功能正确且高效。</li>
<li>类的状态：如果类具有状态，需要设计类的状态和状态转换，确保状态的合理性和一致性。</li>
<li>可扩展性：考虑系统的可扩展性，确保类的设计可以方便地进行扩展和修改。</li>

</ol>
</li>
<li><p>类之间的关系有哪些？如何表示？</p>
<p>类之间的关系有以下几种：</p>
<ul>
<li>继承（Inheritance）：表示类之间的继承关系，子类继承父类的属性和方法。</li>
<li>关联（Association）：表示类之间的关联关系，表示一个类与另一个类之间的关系，双向关联为双向箭头，单向关联为单向箭头。</li>
<li>聚合（Aggregation）：表示整体与部分之间的关系，表示一个类包含多个其他类的对象。</li>
<li>组合（Composition）：表示整体与部分之间的关系，但是整体与部分的生命周期相互依赖。</li>
<li>依赖（Dependency）：表示一个类依赖于另一个类，即一个类使用到另一个类的方法或属性。</li>

</ul>
</li>
<li><p>同步消息与异先消息的区别是什么？</p>
<p>同步消息是发送方发送消息后立即等待接收方处理和返回结果，而异步消息是发送方发送消息后不等待接收方的即时响应，继续执行后续操作。同步消息保证了消息的顺序性和可靠性，但可能导致阻塞等待；异步消息提高了并发性和响应性，但需要另外的机制来处理结果和异常情况。选择同步消息还是异步消息取决于系统的需求和设计考虑。</p>
</li>
<li><p>对象创建有什么法则？</p>
<p>对象创建的法则：</p>
<ul>
<li>确定是否需要创建对象：只有当某个对象具有明确的角色和职责，并在系统中扮演重要的角色时，才需要创建对象。</li>
<li>确定对象的属性和方法：确定对象的属性和方法，确保对象的职责清晰明确。</li>
<li>考虑对象的生命周期：考虑对象的创建、使用和销毁，确保对象的生命周期符合系统需求。</li>

</ul>
</li>
<li><p>描述集中式、委托式和分散式控制风格的优缺点。</p>
<p>集中式、委托式和分散式控制风格的优缺点：</p>
<ul>
<li>集中式控制：优点是简单明了，易于管理和维护；缺点是扩展性较差，系统可能出现单点故障。</li>
<li>委托式控制：优点是可以灵活地委托不同的对象处理任务，便于分工和协作；缺点是可能导致过多的委托关系，增加了系统的复杂性。</li>
<li>分散式控制：优点是各个对象可以独立处理任务，系统灵活性较高；缺点是可能导致任务分散，难以维护和管理。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十三详细设计中的模块化与信息隐藏'>十三、详细设计中的模块化与信息隐藏</h2>
<h3 id='1）模块化与信息隐藏思想'>（1）模块化与信息隐藏思想</h3>
<ol start='' >
<li>模块化与信息隐藏思想的动机：实现重要的质量标准而提出的设计方法。</li>

</ol>
<h3 id='2）模块化'>（2）模块化</h3>
<ol start='' >
<li><p>模块：一个词汇上邻接的程序语句序列，由边界元素限制范围，有一个聚合标识符。</p>
</li>
<li><p>模块化最重要的原则：高内聚低耦合，每个模块内部有最大关联，而模块之间有最小关联。</p>
</li>
<li><p>耦合</p>
<ol start='' >
<li>耦合描述的是两个模块之间关系的复杂程度。</li>
<li>耦合性越高，模块的划分越差，越不利于软件的变更和复用。</li>
<li>耦合性的划分：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%889.16.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午9.16.00"></li>
<li>内容耦合、重复耦合、公共耦合是不能接受的，必须要消除，数据耦合是最好的，控制耦合、印记耦合可以接受。</li>

</ol>
</li>
<li><p>内聚</p>
<ol start='' >
<li>内聚表达的是一个模块内部的联系的紧密性。</li>
<li>内聚性越高越好，越低越不易实现变更和复用。</li>
<li>内聚性的划分：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%889.23.59.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午9.23.59"></li>
<li>偶然内聚和逻辑内聚不能接受，通信内聚、过程内聚、时间内聚是可以接受且不可避免的。</li>

</ol>
</li>

</ol>
<h3 id='3）信息隐藏'>（3）信息隐藏</h3>
<ol start='' >
<li><p>信息隐藏的核心思想：每个模块都隐藏一个重要的设计决策，抽象出类的关键细节（职责）。即抽象出接口，隐藏实现。</p>
</li>
<li><p>信息隐藏就是隐藏认为会改变的设计决策，把每个设计秘密指派给单独的模块，封装每个秘密，使得即使发生改变变化也不会对其他部分产生影响。</p>
</li>
<li><p>信息隐藏的决策：</p>
<ol start='' >
<li>需求分配的职责</li>
<li>内部实现机制</li>

</ol>
</li>
<li><p>模块说明（模块及设计决策文档化）主要记录两个方面的四个主题：</p>
<ol start='' >
<li><p>从内部角度说模块隐藏的秘密</p>
<ol start='' >
<li>来自于需求的主要秘密：描述模块所实现的用户需求。</li>
<li>根源于实现的次要秘密：描述模块实现职责设计的关键实现细节。</li>

</ol>
</li>
<li><p>从外部角度看模块承担的角色</p>
<ol start='' >
<li>模块承担的角色：描述独立的模块在整个系统中承担的角色、所起的作用、与哪些模块有关系。</li>
<li>模块提供的接口：模块提供给别的模块的接口。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题-1'>（4）习题</h3>
<ol start='' >
<li><p>描述常见的设计质量的考量。</p>
<p>常见的设计质量考量包括：</p>
<ul>
<li>可维护性：设计的代码易于理解、修改和维护，遵循良好的编码规范和设计原则。</li>
<li>可扩展性：设计的系统可以方便地进行功能扩展和模块添加，不会因为新增功能而影响原有功能的稳定性。</li>
<li>可重用性：设计的模块和组件可以在多个地方被重复使用，提高代码的复用性和开发效率。</li>
<li>可测试性：设计的代码易于进行单元测试和集成测试，确保代码质量和功能正确性。</li>
<li>高效性：设计的算法和数据结构要求在时间和空间上具有高效性，避免性能瓶颈。</li>
<li>可靠性：设计的代码要具有稳定性和健壮性，能够在各种条件下正常运行，避免系统崩溃和错误。</li>
<li>安全性：设计要考虑系统的安全性，防范恶意攻击和数据泄露。</li>
<li>灵活性：设计要考虑系统的适应性，可以适应需求变化和技术进步。</li>

</ul>
</li>
<li><p>描述模块化与信息隐藏的思想及其发展。</p>
<p>模块化与信息隐藏的思想及其发展：</p>
<p>模块化是将系统划分为独立的、具有清晰功能的模块，每个模块都有明确定义的接口和功能。模块化的思想早期来源于结构化编程，将程序分解为更小的、可重复使用的模块，提高了程序的可读性和可维护性。</p>
<p>信息隐藏是将模块的内部实现细节隐藏起来，只对外暴露必要的接口，通过接口与其他模块进行交互。这样可以降低模块之间的耦合度，使得模块可以独立开发、测试和维护，提高了系统的可扩展性和可维护性。</p>
<p>随着面向对象编程的兴起，模块化和信息隐藏的思想进一步发展为对象的封装和继承。对象是一个独立的、具有状态和行为的实体，通过封装将对象的属性和方法隐藏起来，只通过接口与其他对象进行交互。继承允许对象共享相同的属性和方法，并允许子类扩展或修改父类的行为。</p>
</li>
<li><p>如何写一个模块的模块说明？</p>
<p>编写模块的模块说明一般包括以下内容：</p>
<ul>
<li>模块名称：说明模块的名称和用途。</li>
<li>输入：列出模块的输入参数和数据。</li>
<li>输出：列出模块的输出参数和数据。</li>
<li>功能：描述模块的功能和目标。</li>
<li>算法和逻辑：说明模块的实现算法和处理逻辑。</li>
<li>接口：描述模块的接口，包括输入和输出的格式、协议等。</li>
<li>使用方法：说明如何使用该模块，并提供示例。</li>
<li>限制和注意事项：列出模块的限制条件和需要注意的事项。</li>
<li>作者和修改记录：记录模块的作者和修改历史。</li>
<li>引用和参考资料：列出相关的引用和参考资料。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十四详细设计中面向对象方法下的模块化'>十四、详细设计中面向对象方法下的模块化</h2>
<h3 id='1）面向对象中的模块'>（1）面向对象中的模块</h3>
<ol start='' >
<li><p>面向对象方法中，除了类之间调用关系外，类与类之间的关系还有：</p>
<ol start='' >
<li>关联</li>
<li>继承</li>

</ol>
</li>

</ol>
<h3 id='2）访问耦合'>（2）访问耦合</h3>
<ol start='' >
<li><p>如果类A拥有对类B的引用，则A可以访问B。</p>
</li>
<li><p>访问耦合程度：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.03.53.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.03.53"></p>
</li>
<li><p>类之间的耦合性还需要考虑具体的访问次数。</p>
</li>
<li><p>隐式访问需要避免，实现访问时可以接受且必要的，成员变了访问和参数变量访问是提倡的。</p>
</li>
<li><p>降低访问耦合的方法</p>
<ol start='' >
<li><p>针对接口编程（Programming to Interface）</p>
<ol start='' >
<li>要求在设计时明确类的契约，标明访问耦合和需接口。</li>
<li>原则：基于细化后的类契约进行设计工作。</li>

</ol>
</li>
<li><p>接口最小化/接口分离原则（Interface Segregation Principle，LSP）</p>
<ol start='' >
<li>讲一个统一的接口匹配为多个更独立的接口，避免不必要的耦合，实现接口最小化。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.21.44.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.21.44"><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.21.58.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.21.58"></li>

</ol>
</li>
<li><p>访问耦合的合理范围/迪米特法则（Demeter Law）</p>
<ol start='' >
<li><p>迪米特法则</p>
<ol start='' >
<li>每个单元对于其他单元只能拥有有限的知识，只是与当前单元紧密联系的单元。</li>
<li>每个单元只能和他的朋友交谈，不能和陌生单元交谈。</li>
<li>只和自己直接的朋友交谈。</li>

</ol>
</li>
<li><p>迪米特法则强调不要出现a.b.Method()，而是a.Method()，即应该是人命令狗去行走，而不是人命令狗的腿去行走。</p>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）继承耦合'>（3）继承耦合</h3>
<ol start='' >
<li><p>由于类与类之间有继承关系，父类与子类存在耦合。</p>
</li>
<li><p>继承耦合程度：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-26%20%E4%B8%8A%E5%8D%8810.36.30.png" referrerpolicy="no-referrer" alt="截屏2023-07-26 上午10.36.30"></p>
</li>
<li><p>修改规格、修改实现、精化规格是不可接受的，精化实现常被使用。</p>
</li>
<li><p>降低继承耦合的方法</p>
<ol start='' >
<li><p>Liskov替换原则</p>
<ol start='' >
<li>子类型必须能够替换掉基类型而起同样的作用。</li>
<li>为了满足LSP，需要保证：子类方法的前置条件必须与超类方法的前置条件相同或者更少；子类方法的后置条件必须比超类方法的后置套件相同或更少。</li>
<li>符合LSP的继承能够减少耦合，不符合LSP的继承反而会增加耦合。</li>

</ol>
</li>
<li><p>使用组合替代继承（Favor Composition Over Inheritance）</p>
<ol start='' >
<li>继承机制具有组织类型差异和复用两种性质，在只需要复用而不需要组织类型差异的情况下是不需要继承机制的，应该使用组合替代继承实现复用。</li>
<li>使用组合关系既能复用代码又能保持接口的灵活性。</li>
<li>希望复用代码又不能满足LSP时，应使用组合替代继承。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）内聚'>（4）内聚</h3>
<ol start='' >
<li><p>面向对象中的内聚有：</p>
<ol start='' >
<li>方法的内聚：提现方法实现语句之间的内聚性。</li>
<li>类的内聚：衡量类的成员变量和方法之间的内聚。</li>
<li>继承内聚：继承树中类之间的内聚，如果类之间有很好的概念上的联系，则类之间的继承内聚性高。</li>

</ol>
</li>
<li><p>提高内聚方法</p>
<ol start='' >
<li><p>集中信息与行为</p>
<ol start='' >
<li>类的信息应该和访问这些信息的行为放在一起，集中信息与行为，即信息内聚的。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.31.36.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.31.36"></li>

</ol>
</li>
<li><p>单一职责原则（Single Responsibility Principle，SRP）</p>
<ol start='' >
<li>信息与行为除了集中之外，还要联合起来表达一个内聚的概念。</li>
<li>如：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.38.40.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.38.40"></li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='5）耦合与内聚的度量'>（5）耦合与内聚的度量</h3>
<ol start='' >
<li><p>耦合的度量</p>
<ol start='' >
<li><p>方法调用耦合：CBO计算一个类与外界的耦合度，包括：</p>
<ol start='' >
<li>该类调用其他类的成员方法的数量。</li>
<li>其他类访问这个类的成员方法的数量。（其他类不包括存在继承关系的类）</li>

</ol>
</li>
<li><p>访问耦合：DAC统计一个类包含其他类的实例的数量，不包括继承关系的实例引用。</p>
</li>
<li><p>继承耦合：</p>
<ol start='' >
<li>NOC统计直接所属的子类的数目，当NOC越大复用越多，也意味着父类越抽象越脆弱。</li>
<li>DIT统计从继承树根节点到叶节点的长度，DIT越大意味着子类遵守的越数越多且越隐晦。</li>
<li>NOC和DIT超过3就需要检查继承机制，确保能够遵守LSP。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-28%20%E4%B8%8A%E5%8D%8810.45.08.png" referrerpolicy="no-referrer" alt="截屏2023-07-28 上午10.45.08"></li>

</ol>
</li>

</ol>
</li>
<li><p>内聚的度量：LCOM是比较容易实施的内聚度量。</p>
</li>

</ol>
<h3 id='6）习题'>（6）习题</h3>
<ol start='' >
<li><p>如何理解面向对象中的模块？</p>
<p>在面向对象中，模块指的是独立的、具有特定功能的代码单元或组件。模块是对系统进行分解的基本单位，它包含数据和方法的封装，通过接口与其他模块进行交互。模块化是一种设计思想，将系统划分为多个模块，每个模块负责完成特定的功能，模块之间通过接口进行通信和协作。模块化设计使得系统更易于维护、扩展和理解。</p>
</li>
<li><p>类和类之间的联系有哪些？</p>
<p>类和类之间的联系有以下几种：</p>
<ul>
<li>继承关系（Inheritance）：一个类可以继承另一个类的属性和方法，形成父类和子类之间的继承关系。子类继承了父类的特性，并可以扩展和重写父类的方法。</li>
<li>关联关系（Association）：表示类之间的关联关系，表示一个类与另一个类之间的连接，通常是某个类作为另一个类的属性或方法的参数或返回值。</li>
<li>聚合关系（Aggregation）：表示整体与部分之间的关系，表示一个类包含多个其他类的对象，是一种“整体-部分”的关系。</li>
<li>组合关系（Composition）：表示整体与部分之间的关系，但整体与部分的生命周期相互依赖，是一种比聚合更强的“整体-部分”的关系。</li>
<li>依赖关系（Dependency）：表示一个类依赖于另一个类，即一个类使用到另一个类的方法或属性。</li>

</ul>
</li>
<li><p>解释接口最小化原则。</p>
<p>接口最小化原则（Interface Segregation Principle，ISP）：该原则强调一个类不应该依赖于它不需要的接口。接口应该精简和单一，只包含必要的方法，而不是将所有方法都放在一个庞大的接口中。这样可以降低类之间的耦合度，使得类的设计更加灵活和可维护。</p>
</li>
<li><p>降低访问耦合的方法有哪些？</p>
<p>降低访问耦合的方法有以下几种：</p>
<ul>
<li>封装：将类的内部实现细节隐藏起来，只暴露必要的接口。这样可以降低类之间的直接访问，减少耦合。</li>
<li>接口隔离：遵循接口最小化原则，将接口设计精简和单一，避免一个类依赖于不需要的接口。</li>
<li>使用中介者模式：引入中介者类，将类之间的交互通过中介者进行，减少类之间的直接依赖。</li>
<li>使用观察者模式：将观察者和被观察者解耦，当被观察者发生变化时，通知观察者进行相应的操作，降低彼此之间的耦合度。</li>

</ul>
</li>
<li><p>解释迪米特法则。</p>
<p>强调一个对象应该尽可能少地了解其他对象，只与直接朋友（成员变量、方法参数、方法返回值）进行交互。迪米特法则希望减少对象之间的依赖关系，降低耦合度，使得系统更加灵活、易于维护和扩展。遵循迪米特法则有助于提高代码的可维护性和可读性。</p>
</li>
<li><p>降低继承耦合的方法有哪些？</p>
<p>降低继承耦合的方法有：</p>
<ul>
<li>使用接口（Interface）：通过接口来定义类的行为，而不是直接使用继承。接口定义了类应该实现的方法，使得不同的类可以实现相同的接口，降低了继承的耦合度。</li>
<li>组合代替继承：通过将一个类作为另一个类的成员变量，而不是继承另一个类，来实现功能的复用。这种方式降低了继承的复杂性和耦合度。</li>
<li>使用委托（Delegation）：将某个功能的实现委托给另一个类，而不是通过继承来实现。委托可以减少类之间的依赖，降低继承耦合。</li>

</ul>
</li>
<li><p>解释Liscov替换原则。</p>
<p>如果一个类型是其基类的子类型，那么它应该能够替换掉基类的对象，而不影响程序的正确性。换句话说，派生类对象可以在不影响程序正确性的情况下替代基类对象。</p>
</li>
<li><p>组合替代继承的好处有哪些？</p>
<p>组合替代继承的好处有：</p>
<ul>
<li>更灵活的代码结构：组合可以将功能拆分为更小的部分，灵活地组合和复用这些部分，而不受类的继承结构限制。</li>
<li>降低耦合度：组合关系相比继承关系更加松散，减少了类之间的耦合，使得代码更易于维护和扩展。</li>
<li>避免类的膨胀：继承可能导致类的层次结构复杂，而组合可以避免类的膨胀，使得代码更加简洁和清晰。</li>
<li>支持动态组合：组合关系允许在运行时动态地更改对象的组合方式，使得系统更加灵活和可配置。</li>

</ul>
</li>
<li><p>类之问稱合的度量有哪些指标？怎么计算？</p>
<ol start='' >
<li><p>类之间的耦合度可以通过一些指标来度量，常见的指标有：</p>
<ul>
<li>类的依赖数（Dependents）：表示其他类依赖于该类的数量。</li>
<li>类的被依赖数（Dependencies）：表示该类依赖于其他类的数量。</li>
<li>类的关联数（Associations）：表示该类与其他类之间的关联关系数量。</li>
<li>类的继承深度（Inheritance Depth）：表示该类在继承层次中的深度。</li>

</ul>
</li>

</ol>
</li>
<li><p>面向对象方法中，有哪些提高内聚的方法？</p>
<p>面向对象方法中，提高内聚的方法有：</p>
<ul>
<li>单一职责原则（Single Responsibility Principle，SRP）：每个类应该只有一个单一的责任，即一个类应该只负责完成一个功能。</li>
<li>封装：将类的属性和方法封装起来，只暴露必要的接口，隐藏内部实现细节，增强类的内聚性。</li>
<li>设计模式：采用设计模式，如工厂模式、策略模式等，可以将相关功能放在同一个类中，提高类的内聚性。</li>
<li>组合：将多个功能相近的类组合在一起，形成一个更大的类，提高类的内聚性和功能的复用性。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十五详细设计中面向对象方法下的信息隐藏'>十五、详细设计中面向对象方法下的信息隐藏</h2>
<h3 id='1）封装类的职责'>（1）封装类的职责</h3>
<ol start='' >
<li><p>职责指的是类或对象维护一定的状态信息，并基于状态履行行为只职能的能力。类与对象的职责来源于需求。</p>
</li>
<li><p>封装的含义为：</p>
<ol start='' >
<li>将数据和行为同时包含在类中</li>
<li>分离对外接口与内部实现</li>

</ol>
</li>
<li><p>接口通常描述以下内容：</p>
<ol start='' >
<li>对象之间交互的消息（方法名）</li>
<li>消息中的参数</li>
<li>消息返回结果的类型</li>
<li>与状态无关的不变量</li>
<li>需要处理的异常</li>

</ol>
</li>
<li><p>需要封装的细节</p>
<ol start='' >
<li>封装数据和行为</li>
<li>封装内部结构</li>
<li>封装其他对象的引用</li>
<li>封装类型信息：多种子类型因为具备一些共性而被视作用一种类型时，因隐藏其具体子类型的类别而只知道共性类别。</li>
<li>封装潜在变更</li>

</ol>
</li>

</ol>
<h3 id='2）为变更而设计'>（2）为变更而设计</h3>
<ol start='' >
<li><p>封装变更/开闭原则（Open Close Principle，OCP）</p>
<ol start='' >
<li><p>具体内容：好的设计应该对“扩展”开放对“修改”关闭。即在发生变更时，好的设计只需要添加新的代码而不需要修改原有代码就能实现变更。</p>
</li>
<li><p>选择开闭原则的原因：</p>
<ol start='' >
<li>新增加的需求到来时，增加新的代码而不是修改已有代码是实现新增需求变更更自然的手段。</li>
<li>修改原有代码会增强其复杂度、降低其质量并可能引入新的缺陷。</li>

</ol>
</li>

</ol>
</li>
<li><p>依赖倒转原则（Dependency Inversion Principle，DIP）</p>
<ol start='' >
<li><p>由于类之间的耦合是具有方向性的，因此需要依赖倒转原则控制耦合的方向性。</p>
</li>
<li><p>具体内容：</p>
<ol start='' >
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
<li>高层模块不应该依赖于低层模块。</li>

</ol>
</li>
<li><p>DIP会增加系统复杂度，因此如果某个行为不是明确不稳定的，不需要强行使用DIP。</p>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-3'>（3）习题</h3>
<ol start='' >
<li><p>有哪此概念类能够称为设计类的原型？</p>
<p>可以称为设计类的原型的概念类包括：</p>
<ul>
<li>领域模型中的实体类：用于表示业务领域中的实际对象，如Customer、Product等。</li>
<li>控制器类：用于处理请求和控制业务流程的类，如Controller、Manager等。</li>
<li>数据访问类：用于封装对数据库或其他数据源的访问操作，如DAO(Data Access Object)类。</li>

</ul>
</li>
<li><p>封装的含义有哪些？</p>
<p>封装的含义有以下几个方面：</p>
<ul>
<li>封装数据：将数据成员私有化，通过公共的方法（getters和setters）来访问和修改数据，隐藏数据的内部细节。</li>
<li>封装行为：将类的行为（方法）封装在类的内部，通过公共的接口提供给外部调用，隐藏类的实现细节。</li>
<li>信息隐藏：封装使得类的内部细节对外部不可见，只暴露必要的接口，提高类的安全性和可维护性。</li>

</ul>
</li>
<li><p>职责抽象的法则有哪些？</p>
<p>职责抽象的法则（Single Responsibility Principle，SRP）：该原则指出一个类应该只有一个单一的责任，即一个类应该只负责完成一个功能。类的职责应该是高度内聚的，只有相关的行为应该归属于同一个类。</p>
</li>
<li><p>解释依赖倒置原则。</p>
<p>依赖倒置原则（Dependency Inversion Principle，DIP）：该原则指出高层模块不应该依赖于低层模块，而是应该依赖于抽象。即依赖关系应该是通过接口或抽象类来建立，而不是直接依赖于具体的实现类。这样可以降低模块之间的耦合，提高代码的灵活性和可维护性。</p>
</li>
<li><p>如何实现实现的重用？</p>
<p>实现的重用可以通过继承和组合来实现。继承是通过继承现有类，创建一个新的子类，从而复用父类的属性和方法。组合是将一个类作为另一个类的成员变量，从而实现功能的复用，而不是通过继承来实现。</p>
</li>
<li><p>如何实现接口的重用？</p>
<p>接口的重用可以通过接口继承来实现。一个类可以实现多个接口，从而复用接口中定义的方法，实现多个功能。接口的重用增加了类的灵活性，使得一个类可以适应不同的需求。</p>
</li>
<li><p>解释开闭原则。</p>
<p>开闭原则（Open-Closed Principle，OCP）：该原则指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即一个实体应该通过扩展来增加新的功能，而不是修改原有的代码。这样可以保持现有的代码稳定性，降低修改代码引入错误的风险，并提高系统的可维护性和可扩展性。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十六详细设计的设计模式'>十六、详细设计的设计模式</h2>
<h3 id='1）可修改性'>（1）可修改性</h3>
<ol start='' >
<li><p>可修改性包含以下方面的质量：</p>
<ol start='' >
<li>可修改性（对已有实现的修改）</li>
<li>可扩展性（对新的实现的扩展）</li>
<li>灵活性（对实现的动态配置）</li>

</ol>
</li>
<li><p>实现可修改性的方法：将接口与实现分离</p>
<ol start='' >
<li>通过接口和实现该接口的类完成接口与实现的分离。</li>
<li>通过子类继承父类将父类的接口和子类的实现分离。</li>

</ol>
</li>

</ol>
<h3 id='2）设计模式'>（2）设计模式</h3>
<ol start='' >
<li><p>设计模式的定义：Design Pattern是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</li>
<li><p>基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：<strong>名称、问题、解决方案、效果</strong>。</p>
</li>
<li><p>设计模式的别名是什么，记住英文名</p>
</li>
<li><p>设计模式的分类：</p>
<ol start='' >
<li><p>根据模式的目的（模式用来干什么），可以分成：</p>
<ol start='' >
<li>创建性（Creational）：主要用于创建对象</li>
<li>结构型（Structural）：处理类或对象的组合</li>
<li>行为型（Behavioral）：描述对类或对象怎样交互和怎样分配职责</li>
<li>分类决定了设计模式能不能联合使用</li>

</ol>
</li>
<li><p>根据范围（模式用于处理类之间的关系还是处理对象之间的关系），分成：</p>
<ol start='' >
<li>类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被建立下来，属于<strong>静态</strong>的</li>
<li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具动态性</li>

</ol>
</li>
<li><figure><table>
<thead>
<tr><th style='text-align:left;' >范围/目的</th><th style='text-align:left;' >创建型模式</th><th style='text-align:left;' >结构型模式</th><th style='text-align:left;' >行为型模式</th></tr></thead>
<tbody><tr><td style='text-align:left;' >类模式</td><td style='text-align:left;' >工厂方法模式</td><td style='text-align:left;' >（类）适配器模式</td><td style='text-align:left;' >模版方法模式</td></tr><tr><td style='text-align:left;' >对象模式</td><td style='text-align:left;' >抽象工厂模式</td><td style='text-align:left;' >（对象）适配器模式<br>组合模式<br>装饰模式<br>外观模式<br>代理模式</td><td style='text-align:left;' >命令模式<br>中介者模式<br>观察者模式<br>状态模式<br>策略模式</td></tr></tbody>
</table></figure>
</li>

</ol>
</li>
<li><p>策略模式</p>
<ol start='' >
<li><h5 id='在策略模式中定义了一系列算法将每一个算法封装起来并让它们可以相互替换'>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。</h5>
</li>
<li><p>前提条件：可以对算法进行封装，将算法的责任和算法本身分割开，委派给不同的对象管理。</p>
</li>
<li><p>效果：策略模式让算法独立于使用它的客户而变化，也称为<strong>政策模式</strong>。</p>
</li>
<li><p>使用的设计原则：</p>
<ol start='' >
<li>减少耦合：减少策略的使用类和策略的实现类直接的耦合。</li>
<li>依赖倒置：策略的使用类依赖的是策略的接口而非策略的实现类。</li>

</ol>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</p>
</li>
<li><p>策略模式的三个角色：</p>
<ol start='' >
<li>上下文类：在解决某个问题时可以采用多种策略，在上下文类中维护一个对抽象策略类的引用实例，上下文类包涵策略类，和策略类是组合关系。</li>
<li>抽象策略类：为所支持的算法声明了抽象方法，是所有策略类的父类。</li>
<li>策略类：实现了在抽象策略类中定义的算法。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.35.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.35.49"></p>
</li>

</ol>
</li>
<li><p>优点：对“开闭原则”的完美支持，可以在不修改原本代码的情况下更换或添加算法，提高代码复用率，是一种替换继承。</p>
</li>
<li><p>缺点：客户端必须知道所有的策略类并理解其区别，一定程度上增加了系统中类的个数，可能会存在很多策略类。增加隔阂、方法调用，降低软件运行的效率。（<strong>这两个是大部分模式的通用缺点</strong>）</p>
</li>
<li><p>效果：生成子类化的替代方法和策略消除条件语句。</p>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>避免使用难以维护的多重条件选择语句。</li>
<li>希望在具体策略类中封装算法和与相关的数据结构。</li>

</ol>
</li>
<li><p>模式实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.36.42.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.36.42"></p>
</li>

</ol>
</li>
<li><p>工厂方法模式（Factory Pattern）——针对Simple Factory的改进</p>
<ol start='' >
<li><p>问题描述：简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这<strong>违背了“开闭原则”</strong>。这也导致工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重<strong>影响了系统的灵活性和扩展性</strong>。</p>
</li>
<li><p>前提条件：和简单工厂类似。</p>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>让工厂父类负责创建产品对象的公共接口，工厂子类负责生产具体的产品对象。</p>
</li>
<li><p>四个角色：</p>
<ol start='' >
<li>抽象产品：定义产品的接口。</li>
<li>具体产品：实现了抽象产品接口，某种具体类型的产品有专门的具体工厂建造，之间一一对应。</li>
<li>抽象工厂：声明了具体的工厂方法。</li>
<li>具体工厂：抽象工厂的子类，实现了抽象工厂中定义的工厂方法，有客户调用返回一个具体产品类的实例。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.38.23.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.38.23"></p>
</li>

</ol>
</li>
<li><p>效果：保持了简单工厂的优点，并克服了缺点，可以在允许系统不修改工厂角色情况下引进新产品。</p>
</li>
<li><p>优点：增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性，符合开闭原则。</p>
</li>
<li><p>缺点：为了实现可扩展性引入了抽象层，增加了系统的抽象性和理解难度。</p>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>一个类不知道它所需要的对象的类。</li>
<li>一个类通过其子类来指定创建哪个对象。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li>

</ol>
</li>

</ol>
</li>
<li><p>抽象工厂模式（Abstract Factory）——<strong>Kit模式</strong></p>
<ol start='' >
<li><p>问题描述：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>前提条件：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>使用的设计原则：</p>
<ol start='' >
<li>职责抽象：抽象对于对象创建的职责。</li>
<li>接口的重用：提供对于对象创建的接口。</li>

</ol>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>提供一个创建一系列相关或互相依赖对象的接口，而无需制定他们具体的类。</p>
</li>
<li><p>四个角色</p>
<ol start='' >
<li>抽象工厂：声明了生成抽象产品的方法。</li>
<li>具体工厂：实现抽象工厂声明的生成抽象产品的方法。</li>
<li>抽象产品：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。</li>
<li>具体产品：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.39.21.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.39.21"></p>
</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>隔离了具体类的生成，客户不需要知道什么被创建；</li>
<li>可以通过修改具体工厂类实现修改，增加和替换产品族方便，以实现高内聚低耦合的设计目的。</li>

</ol>
</li>
<li><p>缺点：难以增加新的产品等级结构，抽象工厂中定义了所有的抽象产品，增加产品需要修改抽象工厂和其子类。</p>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>希望系统不依赖于产品类实例如何被创建、组合和表达的细节。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.41.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.41.04"></p>
</li>

</ol>
</li>
<li><p>单件模式</p>
<ol start='' >
<li><p>问题描述：对于某个类，希望在内存中只有一个对象存在，每次想得到这个类的对象的引用时，都指向这个唯一的对象。无论创建多少次这个类的对象，都只创建了一个对象。</p>
</li>
<li><p>前提条件：让类的构造方法变为私有，只能通过静态的get Instance方法获得对象的引用。</p>
</li>
<li><p>使用的设计原则：</p>
<ol start='' >
<li>职责抽象：隐藏单件创建的实现</li>

</ol>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>让类的构造方法变为私有的，然后只能通过静态的getlnstance方法获得Singleton类型的对象的引用。这要求类的成员变量中拥有一个静态的Singleton类型的引用变量uniaueInstance。getinstance方法返回引用变量uniqueInstance，如果uniqueInstance等于null，则说明首次创建，通过关键字new创建Singleton对象，并且将该对象的引用变量赋值给uniqueInstance；否则说明不是首次创建，每次只需要返回己创建的对象的引用uniqueInstance即可。</p>
</li>
<li><p>两个角色：</p>
<ol start='' >
<li>单件：提供访问单件的接口，并实现单件。</li>
<li>客户：使用单件。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%889.49.49.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午9.49.49"></p>
</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>某个类只有一个实例，并作为客户公共的访问点。</li>
<li>当单一实现需要被继承，客户能用一个子类的实例，而不需要修改他的代码。</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>避免使用局部变量。</li>
<li>节约系统资源，提⾼高系统效率。</li>
<li>继承之后的类，可以在配置某个应用时使用。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>单例的职责过重，难以扩展。</li>
<li>从Singleton类派生出的类并不是Singleton。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.07.41.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.07.41"></p>
</li>

</ol>
</li>
<li><p>迭代器模式</p>
<ol start='' >
<li><p>问题描述：希望依次访问某个聚合结构，而不希望知道是什么聚合结构。</p>
</li>
<li><p>前提条件：提供一种⽅法顺序访问⼀个聚合对象中的各个元素，⽽不是暴露其内部的表示。</p>
</li>
<li><p>使用的设计原则：</p>
<ol start='' >
<li>减少耦合：减少遍历的使用类和遍历的实现类直接的耦合。</li>
<li>依赖倒置：遍历的使用类依赖的是策略的接口，而非遍历的实现类。</li>

</ol>
</li>
<li><p>解法</p>
<ol start='' >
<li><p>四个角色：</p>
<ol start='' >
<li>迭代器角色(Iterator)：定义遍历元素所需要的⽅法。</li>
<li>具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。</li>
<li>容器角色（Aggregate）：一般是⼀个接口，提供一个iterator()⽅法。</li>
<li>具体容器角色（ConcreteAggregate）：抽象容器的具体实现类。</li>

</ol>
</li>
<li><p>结构：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.13.18.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.13.18"></p>
</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>支持以不同的方式遍历一个聚合。</li>
<li>简化了了遍历⽅方式</li>
<li>简化了聚合的接口。</li>
<li>在同一个聚合上可以有多个遍历。</li>
<li>封装性好。</li>

</ol>
</li>
<li><p>缺点：对于⽐较简单的遍历(像数组或者有序列表)，使⽤迭代器方式遍历较为繁琐。</p>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>访问一个聚合对象而不需要保留它的内部实现。</li>
<li>支持对聚合对象的多种遍历。</li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>

</ol>
</li>
<li><p>实例：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-29%20%E4%B8%8A%E5%8D%8810.15.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-29 上午10.15.39"></p>
</li>

</ol>
</li>
<li><p>设计原则</p>
<ol start='' >
<li><p>设计原则的目的：支持可维护的复用，即在支持可维护性的同时，需要提高系统的可复用性。</p>
</li>
<li><p>目标：</p>
<ol start='' >
<li>开闭原则（Open Closed Principle）：要求一个软件实体应该对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li>

</ol>
</li>
<li><p>指导：</p>
<ol start='' >
<li>最小知识原则（The Least Knowledge Principle，又叫作迪米特法则（Law of Demeter）：一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话。英文简写为: LOD。</li>

</ol>
</li>
<li><p>基础：</p>
<ol start='' >
<li>单一职责原则（Single responsibility principle）：要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li>
<li>可变性封装原则：</li>

</ol>
</li>
<li><p>实现：</p>
<ol start='' >
<li>依赖倒转原则（Dependence Inversion Principle）：要求抽象不应该依赖于细节而细节应该依赖于抽象，要针对接口编程不是针对实现编程。</li>
<li>合成复用原则（Composite Reuse Principle）：要求复用时尽量使用对象组合，而不使用继承。</li>
<li>里氏代换原则（Liskov Substitution Principle）：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li>
<li>接口隔离原则（Interface Segregation Principle）：要求客户端不应该依赖于那些他不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li>

</ol>
</li>
<li><p>原则之间的关系（目的都是开闭原则）</p>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/00d94dd65745dd6ce1d9c79640e753aa.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>

</ol>
<h3 id='3）习题-4'>（3）习题</h3>
<ol start='' >
<li><p>什么是可修改性、可扩展性、灵活性？</p>
<ul>
<li>可修改性：指软件设计应该容易被修改，即当需要对系统进行修改或添加新功能时，应该能够在不影响原有代码稳定性的情况下进行修改。</li>
<li>可扩展性：指软件设计应该容易扩展，即当需要增加新的功能或模块时，应该能够通过扩展而不是修改来实现。</li>
<li>灵活性：指软件设计应该具有足够的灵活性，即能够适应未来的变化和需求，而不需要进行大规模的修改。</li>

</ul>
</li>
<li><p>如何实现可修改性、可扩展性、灵活性？</p>
<ul>
<li>遵循设计原则：如开闭原则、单一职责原则、依赖倒置原则等，这些原则可以指导设计，使得代码更容易修改和扩展。</li>
<li>使用设计模式：如策略模式、抽象工厂模式、单例模式等，这些设计模式可以提供灵活性和扩展性，使得系统可以适应不同的需求和变化。</li>

</ul>
</li>
<li><p>解释策略模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释抽象工厂模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释单件模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
</li>
<li><p>解释迭代器模式的典型应用场景、参与者和优缺点。</p>
<p>已有</p>
<p>&nbsp;</p>
</li>

</ol>
<h1 id='软工-第五部分-软件构造测试交付与维护'>软工-第五部分-软件构造、测试、交付与维护</h1>
<h2 id='十七软件构造'>十七、软件构造</h2>
<h3 id='1）软件构造'>（1）软件构造</h3>
<ol start='' >
<li><p>软件构造的定义：通过编码、验证、单元测试、集成测试和调试等工作的结合，生产可工作的、有意义的软件的详细创建过程。即以程序员为主完成的综合性任务。</p>
</li>
<li><p>软件构造包含的活动：</p>
<ol start='' >
<li>详细设计</li>
<li>编程</li>
<li>测试</li>
<li>调试</li>
<li>代码评审</li>
<li>集成与构建</li>
<li>构造管理</li>

</ol>
</li>

</ol>
<h3 id='2）软件构造活动'>（2）软件构造活动</h3>
<ol start='' >
<li><p>详细设计</p>
</li>
<li><p>编程</p>
<ol start='' >
<li><p>编程是软件构造的核心活动，目的是生产高质量的策划个女婿代码。</p>
</li>
<li><p>程序代码的典型质量：</p>
<ol start='' >
<li>易读性：编程最重要的目标，可以使得程序更容易开发、易与调试、容易维护、减少理解代码的难度和成本、更容易复用。</li>
<li>易维护性</li>
<li>可靠性：执行正确并妥善处理故障</li>
<li>性能：包括时间和空间性能。</li>
<li>安全性</li>

</ol>
</li>

</ol>
</li>
<li><p>测试</p>
<ol start='' >
<li>通过单元测试和集成测试验证设计的正确性。</li>
<li>通常每修改一次程序就需要最少一次单元测试，集成测试在单元测试之后，测试多个单元之间的接口是否正确。</li>

</ol>
</li>
<li><p>调试</p>
<ol start='' >
<li><p>测试发现问题之后通过调试找到缺陷并修复。</p>
</li>
<li><p>调试可分为：</p>
<ol start='' >
<li><p>重现问题：从控制输入、控制环境入手。</p>
</li>
<li><p>诊断缺陷：灵活使用编译器提示、检查刚修改的部分、持续缩小嫌疑代码范围、利用工具、内存或资源泄露、逻辑/编码/循环/条件/指针/分配释放/多线程/定时...错误、内存溢出</p>
</li>
<li><p>修复缺陷：</p>
<ol start='' >
<li>一次只修复一个缺陷</li>
<li>修复前保留旧版本备份</li>
<li>使用测试和评审验证修复的有效性</li>
<li>检查和修复类似的缺陷</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>代码评审</p>
<ol start='' >
<li>对代码的系统检查。</li>
<li>可分为正式评审、轻量级评审和结对编程三种。</li>

</ol>
</li>
<li><p>集成与构建</p>
<ol start='' >
<li>将分散单位集成和构建为构件、子系统和完整系统。</li>
<li>集成有大爆炸式集成和增量式集成，实践中增量式集成更好。</li>

</ol>
</li>
<li><p>构造管理</p>
<ol start='' >
<li>包括构造计划、度量和配置管理三个任务。</li>

</ol>
</li>

</ol>
<h3 id='3）软件构造的实践方法'>（3）软件构造的实践方法</h3>
<ol start='' >
<li><p>重构：</p>
<ol start='' >
<li><p>重构的原因：进行软件维护，由于时间变化导致软件不能满足修改要求或因为多次修改导致软件质量脆弱难以维持可修改性，就需要通过重构改进局部软件设计结构，提升其质量。</p>
</li>
<li><p>重构的定义：修改软件系统的严谨方法，在不改变代码的外观表现的情况下改进其内部结构。</p>
</li>
<li><p>重构的时机：</p>
<ol start='' >
<li>增加新功能时</li>
<li>发现缺陷进行修复时</li>
<li>进行代码评审时</li>

</ol>
</li>
<li><p>重构的注意事项：</p>
<ol start='' >
<li>重构是基于已有代码的改进，不是开发新代码。</li>
<li>重构要防止副作用。</li>
<li>重构的重点是改进详细设计结构。</li>

</ol>
</li>

</ol>
</li>
<li><p>测试驱动开发</p>
<ol start='' >
<li><p>定义：在编写完成一段代码之前，优先完成该代码的测试代码。测试代码由测试工具自动装在执行，也可以有程序员手动执行。</p>
</li>
<li><p>测试驱动开发的优点：</p>
<ol start='' >
<li>提高程序的正确性和可靠性。</li>
<li>提高设计质量。</li>
<li>提高生产力。</li>

</ol>
</li>
<li><p>测试驱动开发过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%888.24.45.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午8.24.45"></p>
</li>

</ol>
</li>
<li><p>结对编程</p>
<ol start='' >
<li><p>定义：两个程序员挨着坐在一起，共同协作进行软件构造活动。掌握键盘的人成为Driver，负责输入代码，另一位称为Observer，对Driver输入的代码进行评审等。两个程序员可以互换角色。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>提高程序质量</li>
<li>降低程序缺陷率</li>
<li>减少返工和维修成本</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题-2'>（4）习题</h3>
<ol start='' >
<li><p>软件构造与软件实现有什么不同？</p>
<p>软件构造与软件实现有以下不同：</p>
<ul>
<li>软件构造是软件开发过程中的一个阶段，涵盖了详细设计、编码、调试、测试等活动，是将软件设计转换为可执行代码的过程。</li>
<li>软件实现是软件构造的一个子阶段，专注于将详细设计转换为源代码，并进行编码、调试和测试的过程。</li>

</ul>
</li>
<li><p>为什么软件构造要执行详细设计、代码设计、单元测试、集成测试？</p>
<p>软件构造要执行详细设计、代码设计、单元测试、集成测试的原因是为了确保代码质量和功能正确性。详细设计和代码设计是为了确保代码结构合理、模块化，易于维护和扩展；单元测试是为了验证每个独立单元的功能是否正确；集成测试是为了验证各个单元之间的交互是否正确。</p>
</li>
<li><p>实践经验表明调试比较依赖于程序员的经验，分析一下为什么？</p>
<p>调试比较依赖于程序员的经验，因为调试涉及到定位和解决问题，需要程序员具有丰富的知识和经验来理解代码逻辑、推理错误原因，以及选择合适的修复方法。经验丰富的程序员可能会更加熟悉代码库，对常见问题和解决方法有更深的了解，因此在调试时更加得心应手。</p>
</li>
<li><p>重构是在已有代码的基础上进行详细设计，它与在软件设计阶段进行的事先设计有什么不同？各自的优缺点是什么？</p>
<p>重构是在已有代码的基础上进行代码修改，而在软件设计阶段进行的事先设计是在构建系统的结构和模块之前进行规划和设计。重构强调的是在保持功能不变的前提下，优化代码结构，提高代码质量和可维护性；而事先设计则是在系统构建之前，对系统的整体结构和组织进行设计。</p>
<ul>
<li>重构的优点：提高代码质量和可维护性，优化代码结构，降低技术债务，提高开发效率。</li>
<li>事先设计的优点：在构建系统之前进行全面的规划和设计，可以避免后期重构带来的风险和工作量，降低代码修改的频率。</li>

</ul>
</li>
<li><p>实践调查显示，相较于新手，结对编程更适用于熟练程序员，你认为原因是什么？</p>
<p>实践调查显示，相较于新手，结对编程更适用于熟练程序员的原因是熟练程序员通常对代码更熟悉，对问题的解决更有经验。在结对编程中，熟练程序员可以提供更多的指导和建议，帮助新手更好地理解问题和解决方案，从而提高工作效率和代码质量。</p>
</li>
<li><p>你认为应该如何提高程序的易读性、易维护性、可靠性、性能和安全性？</p>
<p>提高程序的易读性、易维护性、可靠性、性能和安全性可以通过以下方法：</p>
<ul>
<li>易读性：遵循良好的编码规范和命名约定，提供清晰的注释，采用模块化的设计，减少复杂嵌套和冗余代码。</li>
<li>易维护性：保持代码的模块化，遵循设计原则和设计模式，减少代码耦合，提供清晰的接口和文档，使用版本控制来管理代码修改。</li>
<li>可靠性：进行充分的单元测试和集成测试，处理异常情况和错误，采用防御性编程的思想，确保代码的正确性和稳定性。</li>
<li>性能：对代码进行性能优化，使用高效的算法和数据结构，避免不必要的资源浪费，减少系统的响应时间和资源占用。</li>
<li>安全性：采用安全编程的实践，对用户输入进行验证和过滤，防范常见的安全漏洞，保护系统免受攻击和恶意行为。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十八代码设计'>十八、代码设计</h2>
<h3 id='1）易读性'>（1）易读性</h3>
<ol start='' >
<li><p>无论是出于团队协作，还是维护的需要，易读性都应该是代码的兽药质量标准。</p>
</li>
<li><p>代码规范：</p>
<ol start='' >
<li><p>格式：代码布局能清晰体现程序的逻辑结构</p>
<ol start='' >
<li>使用缩进和对齐表达逻辑结构。</li>
<li>将相关逻辑组织在一起。</li>
<li>使用空行分割逻辑。</li>
<li>语句分行。</li>

</ol>
</li>
<li><p>命名：惯例和规则</p>
<ol start='' >
<li>有意义的名称命名。</li>
<li>存在惯例则遵守惯例</li>
<li>不要太长</li>
<li>不要使用易混淆字母、太长或无逻辑的字母缩写。</li>

</ol>
</li>
<li><p>注释：</p>
<ol start='' >
<li>文档注释：javadoc</li>
<li>内部注释</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='2）易维护性'>（2）易维护性</h3>
<ol start='' >
<li><p>易读是易维护的前提。</p>
</li>
<li><p>易维护性：</p>
<ol start='' >
<li><p>小型任务：控制代码复杂度，将完成一个功能的多个步骤、长代码的程序分解为多个高内聚、低耦合的小任务（小任务还能提高易读性）。</p>
</li>
<li><p>复杂决策：代码业务规则容易变化，需要修改决策（布尔表达式）</p>
<ol start='' >
<li>使用新布尔变量简化负责决策。</li>
<li>使用有意义的名称封装决策。</li>
<li>表驱动编程</li>

</ol>
</li>
<li><p>数据使用：</p>
<ol start='' >
<li>不要把变量用于与命名不符的目的。</li>
<li>不要将单个变量用于多个目的。</li>
<li>限制全局变量的使用。</li>
<li>不要使用突兀的数字与字符。</li>

</ol>
</li>
<li><p>明确依赖关系：类之间模糊的依赖关系容易导致未预期的连锁反应。</p>
</li>

</ol>
</li>

</ol>
<h3 id='3）可靠性'>（3）可靠性</h3>
<ol start='' >
<li><p>提高可靠性往往会降低易读性、性能和维护性，因此只有针对对可靠性要求高的代码才会专门去提高可靠性。</p>
</li>
<li><p>可靠性：</p>
<ol start='' >
<li><p>契约式设计</p>
<ol start='' >
<li><p>又称断言式设计，基本思想是：如果一个函数或方法，在前置条件满足的情况下开始执行，完成后能满足后置条件那么这个函数或方法就是正确、可靠的。</p>
</li>
<li><p>编程方式：</p>
<ol start='' >
<li>异常：在代码开始执行判断前置条件，结束执行后判断后置条件，不符合抛出异常（throw）</li>
<li>断言：代码开始执行检查前置条件，结束执行后检查后置条件，不符合抛出异常（assert）</li>
<li>比较：</li>

</ol>
</li>
<li><p>Java在Public方法中使用异常，Protected、Private方法中使用断言。</p>
</li>

</ol>
</li>
<li><p>防御式编程</p>
<ol start='' >
<li>基本思想：在一个方法与其他方法、OS、硬件等外界环境交互时，不能确保外界都是正确的，因此要在外界发生错误时，保护方法内部不受损害。</li>
<li>防御式编程会增加整体代码的复杂度、降低易读性和性能，但是能显著提高程序可靠性。</li>

</ol>
</li>
<li><p>使用模型辅助设计复杂代码</p>
<ol start='' >
<li><p>决策表</p>
<ol start='' >
<li>一种决策逻辑的表示方法，用于描述复杂决策逻辑。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%889.21.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午9.21.00"></li>
<li>决策表来描述复杂决策能保证决策分析的完备性，减少规则遗漏和考虑不周。还能方便表驱动编程，将复杂决策代码简单化。</li>

</ol>
</li>
<li><p>伪代码</p>
<ol start='' >
<li>结合编程语言和自然语言的特点。</li>
<li>不是编程语言因此不存在语法问题，不需要关心语言规范。</li>

</ol>
</li>
<li><p>程序流程图</p>
<ol start='' >
<li>圆角矩形表示开始和结束，倾斜矩形表示输入和输出，矩形表示顺序处理步骤，菱形表示控制结构的决策分支。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%889.23.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午9.23.38"></li>
<li>利用流程图可以清晰表现程序逻辑结构的特点。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）为代码开发单元测试用例'>（4）为代码开发单元测试用例</h3>
<ol start='' >
<li><p>在未按照测试驱动方法完成代码后，需要为代码开发单元测试用例，开发测试用例的线索有：</p>
<ol start='' >
<li>方法的规格</li>
<li>方法代码的逻辑结构</li>

</ol>
</li>
<li><p>使用Mock Object测试类方法。</p>
</li>
<li><p>为类开发测试用例：需要为复杂类的方法和不同类方法之间的影响开发测试用例</p>
</li>

</ol>
<h3 id='5）代码复杂度度量'>（5）代码复杂度度量</h3>
<ol start='' >
<li><p>McCabe的圈复杂度</p>
<ol start='' >
<li>程序的复杂度由控制流定义，即控制结构最大地影响了程序复杂度。</li>
<li>圈复杂度的基本思路是计算程序中独立路径的最大数量。</li>

</ol>
</li>

</ol>
<h3 id='6）考虑'>（6）考虑</h3>
<ol start='' >
<li>简洁性、可维护性</li>
<li>使用数据结构消减复杂判定</li>
<li>控制结构、变量使用、语句处理</li>
<li>How to write unmaintainable code</li>
<li>防御与错误处理</li>

</ol>
<h3 id='7）习题-3'>（7）习题</h3>
<ol start='' >
<li><p>为什么要重视代码的易读性？</p>
<p>重视代码的易读性是因为代码在软件开发中不仅是计算机能够理解的指令集，也是程序员之间的交流工具。易读性良好的代码可以使程序员更容易理解代码的逻辑和功能，减少阅读和理解代码所需的时间，提高代码的可维护性和可理解性。同时，易读性好的代码还可以减少错误和缺陷的产生，降低代码维护的难度和成本。</p>
</li>
<li><p>代码规范的作用是什么？如果一个程序员不了解编程规范，那么他写的程序可能会有哪些不好的表现？</p>
<p>代码规范的作用是为编程提供统一的标准和规范，使得团队成员能够在同一标准下进行开发，提高代码的一致性和可读性。如果一个程序员不了解编程规范，他写的程序可能会有以下不好的表现：</p>
<ul>
<li>代码风格混乱，不统一，影响代码的可读性。</li>
<li>变量和函数命名不规范，难以理解代码的含义。</li>
<li>缺少注释或注释不清晰，导致他人难以理解代码的逻辑和用途。</li>
<li>缺乏结构化和模块化的设计，代码难以维护和扩展。</li>

</ul>
</li>
<li><p>怎样布局能够清晰地体现代码的逻辑结构？</p>
<p>要清晰地体现代码的逻辑结构，可以采用以下布局方法：</p>
<ul>
<li>使用缩进：通过缩进来表示代码的层次结构，使代码块的逻辑结构清晰可见。</li>
<li>使用空行：在代码块之间使用空行分隔，使代码的布局更加清晰，方便阅读。</li>
<li>使用合适的命名：使用有意义的变量名和函数名，能够更好地体现代码的逻辑结构和功能。</li>
<li>使用注释：适当地添加注释，解释代码的逻辑和用途，有助于他人理解代码。</li>

</ul>
</li>
<li><p>文档注释与内部注释有什么不同？各自的重点、要点是什么？</p>
<p>文档注释与内部注释的不同在于：</p>
<ul>
<li>文档注释：是指对代码进行注释并生成文档的注释方式，通常使用特定的注释格式，例如Java中的Javadoc。文档注释用于生成API文档，对外部用户提供代码的接口和使用说明。</li>
<li>内部注释：是指在代码中添加的对代码逻辑和功能的注释，用于帮助程序员理解代码的实现细节和设计思路。</li>

</ul>
<p>文档注释的重点是对代码的接口和用途进行说明，强调代码的对外展现；内部注释的重点是对代码的实现和设计进行说明，强调代码的内部逻辑和实现细节。</p>
</li>
<li><p>为什么要重视代码的易维护性？</p>
<p>重视代码的易维护性是因为软件的生命周期中，维护阶段通常占据了大部分时间和资源。易维护的代码能够降低维护成本，增加代码的可靠性和稳定性。易维护的代码应该具有清晰的结构和模块化设计，注重代码的可读性和可理解性，使用规范的命名和注释，遵循设计原则和最佳实践。</p>
</li>
<li><p>小型任务为什么能够提高代码的可维护性？</p>
<p>小型任务能够提高代码的可维护性，因为将大型任务拆分为小型任务有以下优势：</p>
<ul>
<li>小型任务更易于管理和追踪，有利于项目进度的控制和管理。</li>
<li>小型任务更易于定位和解决问题，有助于减少维护和修复的时间和成本。</li>
<li>小型任务可以更好地实现模块化和结构化的设计，使得代码更易于维护和扩展。</li>

</ul>
</li>
<li><p>为什么要处理复杂决策？有哪些处理方法？</p>
<p>处理复杂决策的方法有：</p>
<ul>
<li>将复杂决策拆分为多个简单决策，然后再进行综合考虑。</li>
<li>使用决策表或决策树来清晰地表示复杂的条件和逻辑。</li>
<li>采用面向对象的设计方法，将复杂决策抽象成类和对象的关系，提高代码的可读性和可维护性。</li>
<li>使用设计模式，如策略模式、状态模式等，来处理复杂的条件和行为，使代码更加灵活和易维护。</li>

</ul>
</li>
<li><p>有哪些常见的数据使用不当会降低代码的可维护性？请举例说明。</p>
<p>常见的数据使用不当会降低代码的可维护性包括：</p>
<ul>
<li>变量命名不合适：使用含义不明确的变量名会使代码难以理解和维护。</li>
<li>长方法或函数：一个方法或函数包含过多的代码会使其难以理解和维护。</li>
<li>魔数和硬编码：使用未解释的常量值或硬编码的数字会降低代码的可读性和可维护性。</li>
<li>冗余数据：不必要的重复数据会增加维护的难度和风险。</li>
<li>数据耦合：过度依赖其他模块的数据会增加代码的耦合性，降低可维护性。</li>

</ul>
<p>举例：一个程序中使用了大量硬编码的数字作为数组的长度和索引，当需求发生变化时，需要修改多处硬编码的值，而没有使用常量或变量进行定义，导致代码的维护困难。</p>
</li>
<li><p>类之间存在哪些模糊的依赖关系？如何将它们变得明显、清晰？</p>
<p>类之间存在的模糊依赖关系包括：</p>
<ul>
<li>非直接依赖：类之间的依赖关系通过间接调用或中介类产生，不容易被发现和理解。</li>
<li>隐式依赖：类之间的依赖关系没有明确地在代码中表达出来，需要仔细阅读代码才能发现。</li>

</ul>
<p>要将模糊的依赖关系变得明显、清晰，可以：</p>
<ul>
<li>使用明确的类之间的调用关系，避免通过中介类产生不必要的依赖。</li>
<li>使用接口或抽象类来定义类之间的关系，增加代码的可读性和可维护性。</li>

</ul>
</li>
<li><p>哪些代码需要重视可靠性？试着举例说明。</p>
<p>需要重视可靠性的代码包括：</p>
<ul>
<li>安全性相关的代码：例如涉及用户身份验证、敏感数据处理等的代码，需要保证其可靠性，防止数据泄露和安全漏洞。</li>
<li>重要业务逻辑的代码：涉及重要业务逻辑的代码需要保证其正确性和可靠性，以确保业务运行的稳定性。</li>
<li>关键系统组件的代码：涉及关键系统组件的代码需要高度可靠，以确保系统的稳定运行。</li>

</ul>
</li>
<li><p>契约式设计与防御式编程有哪此异同？</p>
<p>契约式设计与防御式编程的异同：</p>
<ul>
<li>契约式设计：通过使用前置条件、后置条件和不变式等契约来明确方法的预期行为和结果。契约式设计强调类之间的合约关系，要求类在使用时必须遵守其定义的契约。</li>
<li>防御式编程：主要是为了增强代码的健壮性，通过在代码中添加额外的检查和处理来防止错误或异常的发生。防御式编程强调在代码中主动进行防御，处理可能的异常情况，以提高代码的容错能力。</li>

</ul>
</li>
<li><p>异常方式与断言方式各自的优缺点是什么？</p>
<p>异常方式与断言方式各自的优缺点：</p>
<ul>
<li>异常方式： 优点：可以在代码中捕获和处理异常，增加代码的健壮性和容错能力，保持代码的可读性。 缺点：过度使用异常可能导致代码的复杂性增加，不适合处理所有情况，对性能有一定影响。</li>
<li>断言方式： 优点：可以在开发和测试阶段帮助发现代码中的错误和问题，提高代码的质量和稳定性。 缺点：断言只在开发和测试阶段有效，不能在生产环境中捕获和处理异常。</li>

</ul>
</li>
<li><p>为什么需要使用模型方法辅助进行复杂代码的设计？有哪些常用的代码设计模型方法？</p>
<p>使用模型方法辅助进行复杂代码的设计有助于抽象和理清代码的逻辑结构，提高代码的可读性和可维护性。常用的代码设计模型方法包括：</p>
<ul>
<li>数据流图：用于描述数据的流动和处理过程，帮助理解代码的数据流动和处理逻辑。</li>
<li>状态图：用于描述对象的状态转换和行为，帮助理解代码的状态变化和行为过程。</li>
<li>类图：用于描述类和类之间的关系，帮助理解代码的类结构和模块之间的依赖关系。</li>
<li>时序图：用于描述对象之间的交互和消息传递，帮助理解代码的时序行为。</li>

</ul>
</li>
<li><p>为什么控制流最能体现代码的复杂度？分析一下，有哪些手段可以据此降低代码的复杂度？</p>
<p>控制流最能体现代码的复杂度，因为控制流决定了代码执行的顺序和路径。降低代码的复杂度可以采取以下手段：</p>
<ul>
<li>减少条件判断和嵌套：避免过多的条件判断和嵌套结构，使代码更加直观和简洁。</li>
<li>拆分长方法或函数：将长的方法拆分为多个短小的方法，减少方法的复杂性。</li>
<li>使用多态：通过多态性来消除大量的条件判断，使代码更加灵活和易扩展。</li>
<li>使用设计模式：采用设计模式来降低代码的复杂性，提高代码的可维护性和可扩展性。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='十九软件测试'>十九、软件测试</h2>
<h3 id='1）测试层次'>（1）测试层次</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%8810.01.48.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午10.01.48"></p>
<h3 id='2）测试技术'>（2）测试技术</h3>
<ol start='' >
<li><p>随机测试</p>
<ol start='' >
<li>一种基于工程师直觉和经验的技术，让工程师根据直觉从可能的输入值中选择输入子集，建立测试用例。</li>
<li>随机测试不是最优的，测试到缺陷的几率也很小，但是有时能发现一些其他技术发现不到的缺陷。</li>

</ol>
</li>
<li><p>黑盒测试——基于规格的技术</p>
<ol start='' >
<li><p>将测试对象看作一个黑盒，完全基于输入和输出数据判定测试对象的正确性。</p>
</li>
<li><p>测试方法</p>
<ol start='' >
<li><p>等价类划分</p>
<ol start='' >
<li><p>把所有可能的输入数据划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-30%20%E4%B8%8A%E5%8D%8810.14.46.png" referrerpolicy="no-referrer" alt="截屏2023-07-30 上午10.14.46"></p>
</li>
<li><p>等价类划分有两种不同的情况：</p>
<ol start='' >
<li>有效等价类：对于程序的规格说明来说是合理的、有意义的输入数据构成的集合，可以验证程序是否实现了规格说明中所规定的功能和性能。</li>
<li>无效等价类：相反。</li>

</ol>
</li>
<li><p>设计用例时需要考虑两种等价类，软件不仅要接受合理的数据也要接受意外的输入。</p>
</li>

</ol>
</li>
<li><p>边界值分析：错误最容易发生在各等价类的边界上，针对边界情况设计测试用例可以发现更多的缺陷。</p>
</li>
<li><p>决策表</p>
<ol start='' >
<li>为复杂逻辑判断设计测试用例的技术。</li>
<li>决策表是由条件声明、行动声明、规则选项和行动选项四个象限组成的表格。</li>

</ol>
</li>
<li><p>状态转换</p>
<ol start='' >
<li>针对复杂测试对象的技术，该对象对输入数据的反应是多样的，会根据自身的状态决定输出。</li>
<li>状态转换先为测试对象建立状态图，描述对象的状态集合、输入集合和输入导致的状态转换集合。</li>
<li>状态转换包括有效转换和无效转换，只需要为有效转换设计测试用例。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>
<li><p>白盒测试——基于代码的技术</p>
<ol start='' >
<li><p>白盒测试将测试对象看作透明的，不关心测试对象的规则，按照测试对象的内部程序结构来设计测试用例。</p>
</li>
<li><p>测试方法</p>
<ol start='' >
<li><p>语句覆盖</p>
<ol start='' >
<li>标准是确保被测试对象的每一行程序都至少被执行一次。</li>
<li>语句覆盖是一种比较弱的代码覆盖技术，不能覆盖所有执行路径。</li>

</ol>
</li>
<li><p>条件覆盖</p>
<ol start='' >
<li>标准是确保程序中每个判断的每个结果都至少满足一次。</li>
<li>条件覆盖的覆盖程度比语句覆盖强，但仍不敢保证覆盖所有执行路径。</li>

</ol>
</li>
<li><p>路径覆盖</p>
<ol start='' >
<li>标准是确保程序中每条独立的执行路径都至少执行一次。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='3）测试活动'>（3）测试活动</h3>
<ol start='' >
<li><p>测试计划</p>
<ol start='' >
<li>测试计划明确软件测试的工作范围、资源与成本、基本策略、进度安排等。</li>
<li>明确表明测试的对象、测试的级别、测试的顺序、每个测试对象所应用的测试策略以及测试环境。</li>
<li>测试计划开始于需求开发结束之后，部分开始于体系结构设计之后，另一部分开始于详细设计之后，单元测试计划开始于编程完成之后。</li>

</ol>
</li>
<li><p>测试设计：目标是进一步明确需要被测试的对象，综合考虑测试层次、被测对象特点和软件测试的目标，选择合适的测试技术，设计能够同时满足质量目标和项目约束的测试用例。</p>
</li>
<li><p>测试执行</p>
</li>
<li><p>测试评价：评价之后还要发布测试报告。</p>
</li>

</ol>
<h3 id='4）测试度量'>（4）测试度量</h3>
<ol start='' >
<li><p>缺陷度量：缺陷数据，分类汇总在测试中发现的缺陷。</p>
</li>
<li><p>测试覆盖率：</p>
<ol start='' >
<li>需求覆盖率：被测试的需求数/需求总数</li>
<li>模块覆盖率：被测试的模块数/模块总数</li>
<li>代码覆盖率：被测试的代码行/代码总行</li>

</ol>
</li>

</ol>
<h3 id='5）习题-2'>（5）习题</h3>
<ol start='' >
<li><p>为什么要进行验证与确认？</p>
<p>验证与确认的目的是确保软件开发满足用户需求和质量标准。验证是确认软件是否按照规格和需求正确地构建，确认是用户接受软件是否满足他们的期望和需求。</p>
</li>
<li><p>如何判断软件测试的成功？</p>
<p>软件测试的成功判断主要取决于以下几个方面：</p>
<ul>
<li>测试覆盖率：是否覆盖了软件的所有功能和边界条件。</li>
<li>缺陷率：是否发现和修复了大部分重要的缺陷。</li>
<li>可靠性：软件在测试过程中是否表现稳定，没有严重的崩溃或错误。</li>
<li>用户满意度：用户是否对软件的功能和性能感到满意。</li>

</ul>
</li>
<li><p>软件测试的代价有哪些？</p>
<p>软件测试的代价包括：</p>
<ul>
<li>人力成本：测试人员的工资和培训成本。</li>
<li>设备和工具成本：购买和维护测试所需的设备和工具。</li>
<li>时间成本：测试过程中的时间投入。</li>
<li>风险成本：如果软件中的缺陷没有被及时发现和修复，可能会导致更高的风险和损失。</li>

</ul>
</li>
<li><p>软件测试有哪些层次？请分别加以描述。</p>
<p>软件测试的层次包括：</p>
<ul>
<li>单元测试：测试软件的最小功能单元，通常是单个函数或方法。</li>
<li>集成测试：测试多个单元之间的集成，确保它们能够正确地协同工作。</li>
<li>系统测试：测试整个系统的功能和性能，确认系统是否满足用户需求。</li>
<li>验收测试：由用户或客户进行的测试，确认软件是否符合需求并满足他们的期望。</li>

</ul>
</li>
<li><p>随机测试技术有什么缺点？什么情景下可以使用？</p>
<p>随机测试技术的缺点包括：</p>
<ul>
<li>可能会漏掉一些特定情况或边界条件，导致测试覆盖率不够高。</li>
<li>难以重现问题：由于随机性，测试结果可能难以重现，使得问题难以跟踪和修复。</li>

</ul>
<p>在一些情况下可以使用随机测试技术，特别是在发现传统测试方法难以覆盖的复杂或随机性很强的场景中，随机测试可以提供一种有效的补充。</p>
</li>
<li><p>比较黑盒测试和白盒测试方法，说明各自的优缺点。</p>
<p>黑盒测试和白盒测试方法的比较：</p>
<ul>
<li><p>黑盒测试：</p>
<ul>
<li>优点：独立于代码实现，能够更好地关注用户需求，易于发现功能缺陷。</li>
<li>缺点：覆盖面有限，可能无法检测到所有的逻辑错误，需要依赖详细需求文档。</li>

</ul>
</li>
<li><p>白盒测试：</p>
<ul>
<li>优点：能够更全面地测试代码的逻辑和路径，发现代码缺陷和逻辑错误。</li>
<li>缺点：需要测试人员了解代码的实现细节，对测试人员的技术要求较高，容易忽略用户需求。</li>

</ul>
</li>

</ul>
</li>
<li><p>软件测试要执行哪些活动？请分别加以描述。</p>
<p>软件测试要执行的活动包括：</p>
<ul>
<li>测试计划编制：制定测试策略和计划，明确测试的目标和范围。</li>
<li>测试用例设计：根据需求和设计文档，编写测试用例。</li>
<li>执行测试用例：按照测试计划执行测试用例，记录测试结果和缺陷。</li>
<li>缺陷管理：记录和跟踪测试过程中发现的缺陷，并与开发团队协调修复。</li>
<li>验证和确认：确认修复后的缺陷，并验证软件是否符合用户需求和质量标准。</li>
<li>性能测试：对软件的性能进行测试，确保其能够满足性能要求。</li>
<li>安全测试：对软件的安全性进行测试，防止安全漏洞和风险。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十软件交付'>二十、软件交付</h2>
<h3 id='习题-2'>习题</h3>
<ol start='' >
<li><p>软件交付的目标是什么？包括哪此活动？ </p>
<p>软件交付的目标是将已开发完成的软件产品交给用户或客户，以满足他们的需求和期望。软件交付的活动包括：</p>
<ul>
<li>软件打包：将软件源代码、可执行文件和相关文档打包成可交付的软件包。</li>
<li>软件安装：将软件安装到用户或客户的计算机系统中。</li>
<li>软件部署：将软件部署到用户或客户的服务器或云平台上。</li>
<li>用户培训：为用户提供软件的培训，使其能够熟练使用软件。</li>
<li>文档支持：为用户提供详细的使用文档和帮助手册，方便用户使用软件。</li>

</ul>
</li>
<li><p>安装与部署有什么区别？什么情况下使用安装？什么情况下使用部署？ </p>
<p>安装与部署的区别：</p>
<ul>
<li>安装：通常指将软件安装到用户或客户的本地计算机上，用户可以在自己的计算机上使用软件。</li>
<li>部署：通常指将软件部署到服务器或云平台上，多个用户可以通过网络访问和使用该软件。</li>

</ul>
<p>使用安装的情况：适用于将软件安装在用户个人计算机上，例如桌面应用程序或个人工具。 使用部署的情况：适用于将软件部署在服务器上，并供多个用户通过网络访问和使用，例如网站或企业级应用。</p>
</li>
<li><p>培训与文档支持的作用相同吗？解释你的理由。</p>
<p>培训与文档支持的作用不完全相同。培训的主要目的是为用户提供实际操作软件的技能和知识，使其能够熟练使用软件。文档支持的主要目的是为用户提供参考和帮助，解答使用过程中的常见问题。虽然两者都是为了帮助用户更好地使用软件，但培训更注重实际操作和技能培养，而文档支持更注重提供信息和帮助。</p>
</li>
<li><p>为什么在开发结束时要进行项目评价？ </p>
<p>在开发结束时进行项目评价的目的是为了总结和评估项目的整体绩效，包括项目的成功度、质量、成本、进度等方面。通过项目评价，可以从项目管理和开发过程中吸取经验教训，为未来的项目提供改进和优化的方向。</p>
</li>
<li><p>项目评价要注意哪此事项？</p>
<p>项目评价要注意以下事项：</p>
<ul>
<li>项目目标：评价项目是否达到了既定的目标和交付标准。</li>
<li>项目绩效：评估项目的成本、进度、质量等绩效指标是否符合预期。</li>
<li>项目风险：回顾项目中的风险管理措施是否有效，是否有未被充分考虑的风险。</li>
<li>项目管理：分析项目管理过程中的问题和挑战，提出改进意见。</li>
<li>团队表现：评价团队的合作效率和协作能力，认可团队成员的贡献。</li>
<li>用户反馈：收集用户的反馈意见和建议，了解用户对软件的满意度和需求。</li>

</ul>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十一软件维护与演化'>二十一、软件维护与演化</h2>
<h3 id='1）软件维护'>（1）软件维护</h3>
<ol start='' >
<li><p>软件维护的定义：软件维护是在交付之后修改软件系统或其部件的活动过程，以修正缺陷、提高性能或其他属性、适应变化的环境。</p>
</li>
<li><p>软件维护是以变更为中心的，所以软件维护类型为：</p>
<ol start='' >
<li>完善性维护：为了满足用户新需求、增加软件功能而进行的软件修改活动。</li>
<li>适应性维护：为了使软件能适应新环境而进行的软件修改活动。</li>
<li>修正性维护：为了排除软件产品中遗留的缺陷而进行的软件修改活动。</li>
<li>预防性维护：为了让软件产品在将来可维护，提升可维护性而进行的软件修改活动。</li>

</ol>
</li>
<li><p>软件维护的高代价性：</p>
<ol start='' >
<li>变更的频繁性</li>
<li>维护的困难性</li>

</ol>
</li>
<li><p>软件维护过程：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.04.04.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.04.04"></p>
</li>

</ol>
<h3 id='2）软件演化'>（2）软件演化</h3>
<ol start='' >
<li><p>由于软件开发周期的演唱，开发人员开始采用分段交付的方法来完成产品，第一次开发时只完成最基本的需求集合，在后续以增量的方式逐次开发和渐进交付，同时在每次交付时还要根据用户反馈完成对之前内容的维护，这种过程的开发和维护难以分开，因此称为演化。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.07.20.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.07.20"></p>
</li>
<li><p>软件系统演化定律：</p>
<ol start='' >
<li>持续变化：一个大型软件系统要么不断变化，要么用处越来越少。</li>
<li>不断增加的复杂度：软件系统的复杂度会随着发展增加，除非进行工作来降低复杂度。</li>
<li>质量降低：系统的质量会不断下滑，除非采取工作来适应环境变化。</li>

</ol>
</li>
<li><p>软件演化生命周期模型<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.12.10.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.12.10"></p>
<ol start='' >
<li>初始开发：完成的第一个版本的软件产品。</li>
<li>演化：保持软件产品的持续增值。</li>
<li>服务：不再增加价值，只周期性地修正已有缺陷。</li>
<li>逐步淘汰：不再维护软件，对开发者来说软件生命周期已经结束，但是用户可能仍在使用。</li>
<li>停止</li>

</ol>
</li>

</ol>
<h3 id='3）软件维护与演化的技术'>（3）软件维护与演化的技术</h3>
<ol start='' >
<li><p>逆向工程</p>
<ol start='' >
<li>定义：分析目标系统，标识系统的部件及其交互关系，并使用其他形式或者更高层的抽象创建系统表现的过程。</li>
<li>基本原理：抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li>

</ol>
</li>
<li><p>再工程</p>
<ol start='' >
<li><p>逆向工程关心如何理解软件，不会修改软件，再工程主要关注如何修改软件，再工程的目的是对遗留软件系统进行分析和重新开发。</p>
</li>
<li><p>定义：检查和改造一个目标系统，用新的模式及实现复原目标系统。</p>
</li>
<li><p>再工程的活动：</p>
<ol start='' >
<li>改进人们对软件的理解</li>
<li>改进软件自身，通常是提高可维护性、可复用性和可演化性</li>

</ol>
</li>
<li><p>具体活动：</p>
<ol start='' >
<li>重新文档化</li>
<li>重组系统的结构</li>
<li>将系统转换为更新的编程语言</li>
<li>修改数据的结构组织</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3 id='4）习题-3'>（4）习题</h3>
<ol start='' >
<li><p>与其他工程学科的维护工作相比，软件维护有什么特点？</p>
<p>软件维护相比其他工程学科的维护工作具有以下特点：</p>
<ol start='' >
<li>软件的不断变化：软件是可修改的，不像实体工程中的硬件构造。软件的需求和环境经常发生变化，需要不断进行更新和适应。</li>
<li>隐藏性：软件的内部实现细节通常对用户隐藏，这使得维护人员在不了解具体实现的情况下进行维护工作。</li>
<li>复杂性：大型软件系统通常包含大量的代码和复杂的逻辑，导致维护工作的复杂性增加。</li>

</ol>
</li>
<li><p>软件维护有哪些类型，</p>
<p>软件维护的主要类型包括：</p>
<ol start='' >
<li>改正性维护：修复已发现的缺陷和错误。</li>
<li>适应性维护：根据环境和需求的变化进行调整和更新。</li>
<li>完善性维护：添加新的功能和特性。</li>
<li>预防性维护：为了预防未来可能出现的问题，进行系统优化和改进。</li>

</ol>
</li>
<li><p>为什么需要进行完善性维护？</p>
<p>需要进行完善性维护的原因是随着业务需求和技术发展的变化，软件需要不断增加新的功能和特性来适应新的需求。</p>
</li>
<li><p>为什么软件维护的代价较高？</p>
<p>软件维护的代价较高主要有以下原因：</p>
<ol start='' >
<li>隐藏性和复杂性：由于软件的隐藏性和复杂性，维护人员需要花费更多的时间和精力来理解代码和识别问题。</li>
<li>缺乏文档和注释：缺乏详细的文档和注释，使得维护人员难以理解代码的逻辑和功能。</li>
<li>不断变化的需求：随着需求的变化，软件需要不断进行更新和修改，增加了维护的工作量。</li>

</ol>
</li>
<li><p>分析一下，为什么在维护阶段理解程序非常困难？</p>
<p>在维护阶段理解程序非常困难的原因包括：</p>
<ol start='' >
<li>缺乏设计文档：在维护阶段，通常缺乏详细的设计文档，维护人员只能通过代码来理解系统的设计和实现。</li>
<li>复杂的逻辑和算法：大型软件系统通常包含复杂的逻辑和算法，维护人员需要花费大量时间来理解和分析这些复杂性。</li>
<li>原开发团队的离开：原开发团队可能已经离开项目或者公司，导致维护人员无法得到及时的指导和解答。</li>

</ol>
</li>
<li><p>开发阶段的哪些预备工作可以减轻维护阶段的工作？</p>
<p>开发阶段的预备工作可以减轻维护阶段的工作，包括：</p>
<ol start='' >
<li>编写详细的设计文档和注释，使得维护人员能够更轻松地理解代码的逻辑和功能。</li>
<li>使用清晰的命名和代码结构，使得代码更易于阅读和理解。</li>
<li>实施代码审查和测试，以确保代码的质量和稳定性。</li>

</ol>
</li>
<li><p>描述软件维护过程。</p>
<p>软件维护过程包括以下步骤：</p>
<ol start='' >
<li>问题识别：识别并记录软件中的问题和缺陷。</li>
<li>问题分析：分析问题的原因和影响。</li>
<li>问题修复：根据分析结果，对问题进行修复和改进。</li>
<li>测试和验证：对修复后的软件进行测试和验证，确保问题已经解决。</li>
<li>部署和发布：将修复后的软件部署和发布给用户或客户。</li>

</ol>
</li>
<li><p>描述软件演化生命周期模型。</p>
<p>软件演化生命周期模型是在软件维护阶段对软件进行不断改进和更新的过程。该模型包括以下阶段：</p>
<ol start='' >
<li>问题识别：识别软件中存在的问题和缺陷。</li>
<li>变更请求：根据用户或客户的需求，提出软件的变更请求。</li>
<li>变更分析：分析变更请求的影响和可行性。</li>
<li>变更设计：设计变更的具体实现方式和方案。</li>
<li>变更实现：根据设计，对软件进行修改和更新。</li>
<li>变更测试：对变更后的软件进行测试和验证，确保变更的正确性和稳定性。</li>
<li>部署和发布：将变更后的软件部署和发布给用户或客户。</li>

</ol>
</li>
<li><p>如何使用演化模型组织大规模系统的开发？</p>
<p>在大规模系统的开发中，可以使用演化模型来组织软件的持续开发和更新。演化模型允许在软件的不断变化中保持系统的稳定性和可维护性，同时适应不断变化的业务需求和技术发展。</p>
</li>

</ol>
<p>&nbsp;</p>
<h1 id='软工-第六部分-软件过程模型与职业基础'>软工-第六部分-软件过程模型与职业基础</h1>
<h2 id='二十二软件开发过程模型'>二十二、软件开发过程模型</h2>
<h3 id='1）软件开发的典型阶段'>（1）软件开发的典型阶段</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%889.41.28.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午9.41.28"></p>
<p>明确各个阶段的目标、关注点、任务（子活动）、方法等。</p>
<h3 id='2）软件生命周期模型'>（2）软件生命周期模型</h3>
<ol start='' >
<li>将软件从生产到报废的生命周期分割为不同阶段，每个阶段有明确的典型输入/输出、主要活动和执行人，各个阶段形成明确、连续的顺序过程，这些阶段划分称为软件生命周期模型。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.04.13.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.04.13"></li>
<li>软件生命周期模型描述了新的软件系统应该如何开发，知道软件开发活动应该按照什么顺序组织和执行。</li>

</ol>
<h3 id='3）软件过程模型'>（3）软件过程模型</h3>
<p><img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.07.22.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.07.22"></p>
<h3 id='4）构建-修复模型build-fix-model）'>（4）构建-修复模型（Build-Fix model）</h3>
<ol start='' >
<li><p>BF模型是最自然的软件开发模型，但是并不是一个软件过程模型，因为对软件开发活动没有规划和组织，是完全依靠开发人员个人能力的开发方式。</p>
</li>
<li><p>BF模型中，开发人员在开始生产软件时，依靠个人分析和理解直接构建软件的第一个版本，并提交给用户使用。经常在提交后会发现缺陷，开发人员就修复缺陷。把发现的缺陷都修复之后，进入维护阶段。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.10.11.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.10.11"></p>
</li>
<li><p>特点：没有考虑最基本的生命周期，没有对需求真实性、设计结构质量，代码组织质量、质量保障等软件开发的复杂因素进行关注点分解处理。</p>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>没有对开发工作进行规范和组织。</li>
<li>没有分析需求的真实性。</li>
<li>没有考虑软件结构的质量。</li>
<li>没有考虑测试和程序的可维护性，也没有文档，维护困难。</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>软件规模很小。</li>
<li>软件对质量要求不高。</li>
<li>只关注开发活动，对后期维护要求不高。</li>

</ol>
</li>

</ol>
<h3 id='5）瀑布模型'>（5）瀑布模型</h3>
<ol start='' >
<li><p>瀑布模型按照软件生命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付和软件维护等基本活动，并规定了自上而下、相互衔接的次序，按照“从一个阶段到另一个阶段的有序转换序列”的方式组织开发活动。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.14.00.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.14.00"></p>
</li>
<li><p><em>瀑布模型是允许活动出现反复和迭代的，严格线性顺序不是瀑布模型的主要特点。</em></p>
</li>
<li><p>瀑布模型的重点是要求每个活动的结果必须进行验证，只有进行验证之后才能作为后续开发活动的基础。这要求瀑布模型特别重视模型与文档，因此瀑布模型被看作是“文档驱动”，即按照文档的划分、产生和验证来规划、组织和控制开发活动。</p>
</li>
<li><p>优势（相比BF模型）：为软件开发活动定义了清晰的阶段划分，让开发者能够专注于单独的活动。</p>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>对文档的过高期望</li>
<li>对开发活动的线性顺序假设</li>
<li>客户、用户参与不够</li>
<li>里程碑粒度过粗</li>

</ol>
</li>
<li><p>适用场景：</p>
<ol start='' >
<li>需求非常成熟、稳定</li>
<li>所需技术成熟、可靠</li>
<li>复杂度适中</li>

</ol>
</li>

</ol>
<h3 id='6）增量迭代模型'>（6）增量迭代模型</h3>
<ol start='' >
<li><p>随着周期过长、渐进交付、时间压力和并行开发的挑战，促使了增量迭代模型的产生和普及。</p>
</li>
<li><p>增迭模型在项目开始时，通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，然后再将后续开发活动组织为多个迭代、并行的瀑布式开发活动。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.20.38.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.20.38"></p>
</li>
<li><p>增迭模型在项目早起就确定项目的目标和范围，因此需要项目的需求比较成熟和稳定。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>更符合软件开发的实践情况，有更好的实适用性</li>
<li>并行开发可以帮助缩短软件产品的开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>加入构架不能破坏已构造的部分</li>
<li>需要完备、清晰的项目前景和范围</li>

</ol>
</li>
<li><p>适用范围：在实践中都有广泛的应用，尤其是相对成熟稳定的领域。</p>
</li>

</ol>
<h3 id='7）演化模型'>（7）演化模型</h3>
<ol start='' >
<li><p>演化模型相比增迭模型更适合需求变更频繁或不确定性较多的领域。</p>
</li>
<li><p>演化模型将软件开发活动组织为多个迭代、并行的瀑布式开发活动。在初始迭代中需要澄清和明确核心需求，建立和交付核心系统。之后用户在使用中发现和变更需求、澄清不确定需求，并反馈给开发者进行后续迭代，精化和增强系统。每次迭代的需求不是独立的，设计和实现都是在前代的基础上修改和扩展。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.28.56.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.28.56"></p>
</li>
<li><p>演化模型也是“需求驱动”的。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>使用了迭代式开发，具有更好的适用性</li>
<li>并行开发可以缩短开发时间</li>
<li>渐进交付可以加强用户反馈，降低开发风险</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>无法在项目早期确定项目范围</li>
<li>后续迭代容易变成BF模式</li>

</ol>
</li>

</ol>
<h3 id='8）原型模型'>（8）原型模型</h3>
<ol start='' >
<li><p>演化式原型：原型产生于真正产品构建之前，被扩展后成为真正的产品。</p>
</li>
<li><p>抛弃式原型：模拟真正产品但不会出现在真正产品中，在真正产品中出现的是比原型质量更好的改进和替代。</p>
</li>
<li><p>原型模型注重使用抛弃式模型，因此适合不确定性较多的软件开发，充分利用抛弃式原型解决新颖领域的需求不确定问题，在抛弃式原型的帮助下解决不确定性，再按照瀑布模型安排后续开发活动。可以通过多次原型开发迭代得到所有清晰需求，也可以安排整体迭代。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.36.39.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.36.39"></p>
</li>
<li><p>原型模型可以是需求驱动也可以是风险驱动的。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>演化模型的优点</li>
<li>强化了与客户、用户的交流，产品有更好的满意度</li>
<li>适用于新颖的领域</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>演化模型的缺点</li>
<li>原型能够解决风险，但是自身也会带来风险，如原型成本过高等</li>
<li>实践中很多人不舍得抛弃原型，使得质量较差的代码进入了产品导致产品的低质量。</li>

</ol>
</li>

</ol>
<h3 id='9）螺旋模型'>（9）螺旋模型</h3>
<ol start='' >
<li><p>螺旋模型的基本思想是尽早解决比较高的风险，是风险驱动的，完全按照风险解决的方式组织软件开发。<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8A%E5%8D%8810.52.15.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 上午10.52.15"></p>
</li>
<li><p>螺旋模型使用原型解决项目开发中的风险，有四次由内而外的风险解决迭代，分别解决软件开发中风险较高的几个阶段：</p>
<ol start='' >
<li>解决系统需求开发的风险</li>
<li>解决软件需求开发的风险</li>
<li>解决软件体系结构设计中的技术风险</li>
<li>解决详细设计和实现中的关键技术风险</li>

</ol>
</li>
<li><p>螺旋模型的4次迭代和第4次迭代右下象限的活动一起构成了瀑布模型，因此螺旋模型是风险解决迭代和瀑布模型的综合。</p>
</li>
<li><p>优点：降低风险，减少项目因风险造成的损失。</p>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>风险解决需要原型，原型自身也有风险</li>
<li>模型过于复杂，不利于管理者组织软件开发活动</li>

</ol>
</li>
<li><p>适用场景：高风险的大规模软件系统开发。</p>
</li>

</ol>
<h3 id='10）rational统一过程'>（10）Rational统一过程</h3>
<ol start='' >
<li><p>Rational公司提出统一过程（Rational Unified Process，RUP），RUP总结和借鉴传统的各种经验，建立最佳实践方法的集合，并提供有效的过程定制手段。</p>
</li>
<li><p>RUP用二维坐标来描述：<img src="https://wbw2333.github.io/assets/软工-第n部分/%E6%88%AA%E5%B1%8F2023-07-31%20%E4%B8%8B%E5%8D%881.48.25.png" referrerpolicy="no-referrer" alt="截屏2023-07-31 下午1.48.25"></p>
<ol start='' >
<li>纵轴以内容来组织，是自然的逻辑活动，体现开发过程的静态结构。</li>
<li>横轴以时间来组织，是过程展开的生命周期特征，体现开发过程的动态结构。</li>

</ol>
</li>
<li><p>RUP将生命周期定义为四个阶段，在每个生命周期都可以安排多次迭代：</p>
<ol start='' >
<li>初始阶段：定义项目前景、范围和业务用例。</li>
<li>细化阶段：设计软件体系结构、构建核心体系结构原型。</li>
<li>构造阶段：完成软件系统的详细设计和实现。</li>
<li>交付阶段：将软件产品交付给用户。</li>

</ol>
</li>
<li><p>RUP6个核心实践方法：</p>
<ol start='' >
<li>迭代式开发</li>
<li>管理需求</li>
<li>基于组件的体系结构</li>
<li>可视化建模</li>
<li>验证软件质量</li>
<li>控制软件变更</li>

</ol>
</li>
<li><p>RUP是一个通用模版，因此要对RUP按以下步骤进行裁剪和配置：</p>
<ol start='' >
<li>确定本项目需要哪些工作流</li>
<li>确定每个工作流需要哪些制品</li>
<li>确定4个阶段之间如何演进</li>
<li>确定每个阶段内的迭代计划</li>
<li>规划工作流的组织</li>

</ol>
</li>
<li><p>优点：</p>
<ol start='' >
<li>吸收和借鉴了传统的最佳实践方法</li>
<li>RUP根据定制机制的不同可以适合小型项目和大型项目，适用面广泛。</li>
<li>RUP有一套软件工程工具的支持，帮助RUP有效实施。</li>

</ol>
</li>
<li><p>缺点：</p>
<ol start='' >
<li>没有考虑交付之后的软件维护问题</li>
<li>裁剪和配置工作难度大，不能保证每个项目都能有效定制。</li>

</ol>
</li>
<li><p>适用场景：大型项目和小型项目皆可。</p>
</li>

</ol>
<h3 id='11）敏捷过程'>（11）敏捷过程</h3>
<ol start='' >
<li><p>敏捷方法是为了针对用户价值不在首位、项目开发不够灵活的问题提出的轻量级方法。</p>
</li>
<li><p>敏捷思想：</p>
<ol start='' >
<li>个体和互动高于流程和工具</li>
<li>工作的软件高于详尽的文档</li>
<li>客户合作高于合同谈判</li>
<li>相应变化高于遵循计划</li>

</ol>
</li>
<li><p>适用场景：快速变化或时间压力大的项目。</p>
</li>

</ol>
<h3 id='12）习题'>（12）习题</h3>
<ol start='' >
<li><p>如何理解软件生命周期模型？为什么在开发一个大型软件产品时遵循一个生命周期模型很重要？</p>
<p>软件生命周期模型是描述软件从开始开发直到终止使用的整个过程，包括需求分析、设计、编码、测试、部署、维护等阶段。</p>
<p>遵循一个生命周期模型对于开发大型软件产品很重要，因为它提供了一种有组织的、系统化的方法来管理和控制软件开发过程，帮助项目团队更好地规划和实施各个阶段的活动，降低项目失败的风险，提高软件开发的效率和质量。</p>
</li>
<li><p>软件生命周期模型与软件开发过程模型有哪些区别与联系？</p>
<p>软件生命周期模型和软件开发过程模型是相关但不同的概念。软件生命周期模型描述了软件从开始到结束的整个演化过程，包括各个阶段的活动和交付物；而软件开发过程模型是对软件开发过程的组织和管理方式的抽象描述，它是实现软件生命周期的具体方法。软件开发过程模型包括瀑布模型、增量模型、原型模型、螺旋模型、迭代模型等，它们是具体的开发方法，用来实现软件生命周期模型中的各个阶段。</p>
</li>
<li><p>如果一个项目在开发时没有遵循任何系统的过程，可能会发生哪些问题？</p>
<p>如果一个项目在开发时没有遵循任何系统的过程，可能会发生诸如以下问题：</p>
<ul>
<li>缺乏组织性和规划，项目进度不可控，容易出现延期和超出预算的情况。</li>
<li>难以明确需求和目标，导致软件功能不符合用户期望，造成客户满意度低下。</li>
<li>缺乏测试和验证过程，软件质量无法保障，容易出现严重的Bug和错误。</li>
<li>缺乏文档和记录，对项目的维护和后续发展带来困难。</li>

</ul>
</li>
<li><p>为什么抛弃式原型必须被拋弃？</p>
<p>抛弃式原型必须被抛弃是因为它通常是为了快速验证或演示概念而构建的，而不是为了成为最终产品。抛弃式原型是为了帮助开发人员和用户更好地理解需求和功能，它通常不具备高质量、高可靠性和高性能。一旦验证或演示的目的达到，抛弃式原型应该被废弃，然后基于这些验证结果，进行正式的软件开发。</p>
</li>
<li><p>螺旋模型使用风险驱动的方式有哪些好处？</p>
<p>螺旋模型使用风险驱动的方式有以下好处：</p>
<ul>
<li>可以在每个迭代周期中评估和处理项目的风险，及时调整开发计划和控制措施，降低项目失败的风险。</li>
<li>随着项目的不断演化，风险评估可以帮助确定项目的重点和优先级，确保项目资源的有效分配。</li>
<li>风险驱动的方式促使项目团队更加关注风险因素，提高了项目团队的风险意识和应对能力。</li>

</ul>
</li>
<li><p>RUP 过程同时提供动态结构和静态结构的优点是什么？</p>
<p>RUP同时提供动态结构和静态结构的优点在于可以全面覆盖软件开发的各个方面。动态结构指的是关注软件开发过程中的活动、任务、阶段等动态变化的部分，如需求分析、设计、编码、测试等；静态结构指的是关注软件开发中的文档、模型、工件等静态的产物，如需求规格说明、UML图、代码等。通过同时提供动态结构和静态结构，RUP过程可以帮助团队全面理解和管理软件开发的各个方面，提高项目的可控性和质量。</p>
</li>
<li><p>你认为什么情况下不应该使用敏捷过程方法？</p>
<p>敏捷过程方法在以下情况下可能不适用：</p>
<ul>
<li>项目需求明确且稳定，不需要频繁的需求变更和灵活的迭代开发。</li>
<li>开发团队规模较大且分散，沟通和协作困难。</li>
<li>项目要求强调详细的文档和规范，敏捷方法强调简洁和实际。</li>

</ul>
</li>
<li><p>哪些模型可以适用于需求变化频繁项目的开发？为什么？</p>
<p>适用于需求变化频繁项目的开发模型包括增量模型、迭代模型和螺旋模型。因为这些模型都支持分阶段的开发过程，可以在每个阶段进行需求变更和逐步完善。</p>
</li>
<li><p>哪些模型不适用于大型软件系统的开发？为什么？</p>
<p>不适用于大型软件系统的开发的模型包括原型模型和瀑布模型。原型模型适用于需求不明确或需要快速验证的小规模项目，瀑布模型对于大型复杂项目的需求变化和迭代开发不够灵活。</p>
</li>
<li><p>哪些模型的用户参与度会更高一些？为什么？</p>
<p>模型的用户参与度会更高的有敏捷模型和原型模型。敏捷模型强调与客户的持续交互和反馈，原型模型要求用户参与原型的设计和验证过程。</p>
</li>
<li><p>为下列系统提出合适的软件过程模型，并解释你的理由：</p>
<ol start='' >
<li>充分了解的数据处理应用程序；</li>
<li>卫星通信软件，假设之首没有卫星通信软件的开发经验：</li>
<li>超大型的软件，基于卫星通信、监控移动电话通信；</li>
<li>一个新的文本编辑器；</li>
<li>大学记账系统，准备替换一个已有的系统；</li>
<li>大型软件产品的图形用户界面。</li>

</ol>
<p>解答：</p>
<ol start='' >
<li>充分了解的数据处理应用程序：适用于瀑布模型，因为需求较为稳定且清晰，适合一次性完整开发。</li>
<li>卫星通信软件，假设之首没有卫星通信软件的开发经验：适用于增量模型，可以分阶段开发，每个阶段逐步完善功能和解决问题。</li>
<li>超大型的软件，基于卫星通信、监控移动电话通信：适用于螺旋模型，风险较高，需要不断评估和调整开发计划。</li>
<li>一个新的文本编辑器：适用于原型模型，因为需要快速验证功能和界面，用户参与度较高。</li>
<li>大学记账系统，准备替换一个已有的系统：适用于增量模型，可以逐步替换旧系统的功能，降低风险。</li>
<li>大型软件产品的图形用户界面：适用于迭代模型，界面需要不断迭代优化和改进，可以在每个迭代周期中完善界面。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='二十三软件工程职业基础'>二十三、软件工程职业基础</h2>
<h3 id='1）软件工程师'>（1）软件工程师</h3>
<p>软件工程师的职业素质要求：</p>
<ol start='' >
<li>团队工作能力</li>
<li>交流沟通能力</li>
<li>遵守职业的道德标准和操行规范</li>
<li>积极参与行业协会活动，遵守行业标准，推进行业发展</li>
<li>了解软件工程对社会、经济、法律等相关领域的影响、问题和观点</li>

</ol>
<h3 id='2）软件工程职业概况'>（2）软件工程职业概况</h3>
<ol start='' >
<li><p>软件工程10个知识域：</p>
<ol start='' >
<li>软件需求</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件维护</li>
<li>软件配置管理</li>
<li>软件工程管理</li>
<li>软件工程过程</li>
<li>软件工程工具和方法</li>
<li>软件质量</li>

</ol>
</li>
<li><p>新增的5个知识域：</p>
<ol start='' >
<li>软件工程职业实践</li>
<li>工程经济学基础</li>
<li>计算基础</li>
<li>数学基础</li>
<li>工程基础</li>

</ol>
</li>

</ol>
<h3 id='3）习题-5'>（3）习题</h3>
<ol start='' >
<li><p>除了软件开发技能之外，软件工程师还需要具备哪些职业素质？</p>
<p>除了软件开发技能，软件工程师还需要具备以下职业素质：</p>
<ol start='' >
<li>分析与解决问题能力：能够快速分析和解决复杂问题，找到合理的解决方案。</li>
<li>沟通与协作能力：能够与团队成员、用户和其他相关方进行有效沟通，良好的协作能力有助于项目的顺利进行。</li>
<li>学习与创新能力：软件行业不断发展变化，软件工程师需要不断学习新技术和方法，并具备创新精神。</li>
<li>时间管理与自我管理能力：能够合理安排工作时间，高效地完成任务。</li>
<li>责任心与团队合作精神：对项目负责，能够承担责任，愿意与团队共同合作达成共同目标。</li>

</ol>
</li>
<li><p>判断一个职业出现有哪此方面的条件？软件工程目前表现如何？</p>
<p>判断一个职业是否具备一定的方面条件，通常可以从以下几个方面来考虑：</p>
<ol start='' >
<li>行业需求：是否存在足够的就业机会和发展空间。</li>
<li>薪酬水平：行业内的薪酬待遇是否具有吸引力。</li>
<li>工作环境：职业是否提供相对稳定和舒适的工作环境。</li>
<li>技能需求：是否需要具备一定的专业技能和知识。</li>
<li>发展前景：职业的发展前景是否乐观。</li>

</ol>
<p>目前，软件工程行业在大多数地区表现良好，因为数字化转型和互联网的快速发展使得软件需求持续增长，软件工程师的需求也在增加。</p>
</li>
<li><p>为什么软件工程师要注重专业道德？</p>
<p>软件工程师要注重专业道德，因为软件工程涉及到的是人们生活中的重要信息和数据，如果不遵循专业道德准则，可能导致数据泄露、隐私侵犯等问题，对用户造成损失和影响信任。</p>
</li>
<li><p>为什么软件工程师要进行认证？</p>
<p>软件工程师进行认证是为了证明其具备一定的专业知识和技能，可以胜任相应的工作岗位。认证能够增加软件工程师的竞争力，有助于找到更好的工作机会和提升薪酬水平。同时，认证还可以帮助软件工程师不断学习和提高自己的技能，保持在行业内的竞争优势。</p>
</li>

</ol>
<p>&nbsp;</p>
<h1 id='软工归纳总结'>软工归纳总结</h1>
<h2 id='名词解释'>名词解释:</h2>
<p><strong>软件工程</strong>：</p>
<ol>
<li>应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件</li>
<li>对1中各种方法的研究。</li>

</ol>
<p><strong>软件质量</strong>：软件系统满足显式的以及隐式的要求而需要具备的要素称为质量。（“显式的”是指用户在软件系统创建之前就可以清晰地想开发者表达的要求，“隐式的”是指用户在软件按系统创建之前无法清晰表达却可以在其投入使用之后要求补充的条件）</p>
<p><strong>质量属性</strong>：人们通常会选用系统的某些质量要素进行量化处理，建立质量特征，这些特征被称为质量属性</p>
<p><strong>质量模型</strong>：为了根据质量属性描述和评价系统的整体质量，人们从很多质量属性的定义中选择了一些能互相配合、互相联系的特诊集，他们被称为质量属性。</p>
<p><strong>配置管理</strong>：用技术和管理的指导和监督方法，来表示和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理以及其实现状态，并验证与需求规格的一致性。</p>
<p><strong>配置项</strong>：置于软件配置管理之下的软件配置的各种有关项⽬，包括各类管理⽂档、评审记录与⽂档、软件⽂档、源码及其可执⾏码、运⾏所需的系统软件和⽀持软件以及有关数据等（需要进行配置管理的软件开发制品，包括最终制品和中间制品，都称为配置项）</p>
<p><strong>基线</strong>：已经经过证实评审的规格说明或制品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能变更。</p>
<p><strong>需求</strong>：(1)⽤户为了解决问题或达到某些⽬标所需要的条件或能⼒；</p>
<p>(2)系统或系统部件为了满⾜合同、标准、规范或其他正式⽂档所规定的要求⽽需要具备的条件或能⼒；</p>
<p>(3)对(1)或(2)中的⼀个条件或⼀种能⼒的⼀种⽂档化表述。</p>
<p><strong>需求工程</strong>：需求工程活动包括需求开发和需求管理两个方便，需求开发包括需求获取、需求分析、需求规格说明和需求验证四个具体活动</p>
<p><strong>软件设计</strong>：软件设计是关于软件对象的设计，既指软件对象实现的规格说明(包含软件设计描述和软件原型)，也指产生规格说明的过程。</p>
<p>					设计工程师以对象的目标和用户的需求为指引，在一定客观约束条件下(物理环境，限制条件)完成设计</p>
<p><strong>易用性</strong>：易⽤性不仅关注⼈使⽤系统的过程，同时还关注系统对使⽤它的⼈所产⽣的作⽤，易⽤性不是⼀个单⼀的质量维度，⽽是多维度的质量属性。从易于度量的⾓度讲，易⽤性的常⽤维度包括：易学性、易记性、有效率、低出错率和主观满意度。</p>
<ul>
<li><p>易学性</p>
<ul>
<li>新手用户容易学习，能够很快使用系统</li>
<li>度量：计算完全没有经过培训的用户完成特定任务所需的时间</li>

</ul>
</li>
<li><p>易记性</p>
<ul>
<li>以前使用过软件系统的用户，能够有效记忆或者快速地重新学会使用该系统</li>
<li>度量：计算以前使用过软件系统的用户完成特定任务所需的时间</li>

</ul>
</li>
<li><p>效率</p>
<ul>
<li>熟练用户使用系统完成任务的速度</li>
<li>度量：计算经过培训的熟练用户完成特定任务所需的时间</li>

</ul>
</li>
<li><p>出错率</p>
<ul>
<li>用户在使用系统时，会犯多少错，错误有多严重，以及是否能从错误中很容易地恢复</li>
<li>度量：计算用户在完成特定任务过程中出现的错误数量，或者用户一定时间段内出现的错误数量</li>

</ul>
</li>
<li><p>主观满意度</p>
<ul>
<li>让用户有良好的体验</li>
<li>主观满意度不是客观度量的，而是通过调查问卷的方式获得用户的主观评价</li>

</ul>
</li>

</ul>
<p><strong>精神模型</strong>：精神模型就是用户进行人机交互时头脑中的任务模型。</p>
<p>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并据此设计界面隐喻。</p>
<p>&nbsp;</p>
<p>（重要）<strong>耦合</strong>：描述的是两个模块之间的关系的复杂程度。</p>
<p>耦合根据其耦合性由⾼到低分为⼏个级别：模块耦合性越⾼，模块的划分越差，越不利于软件的变更和重⽤。1、2、3不可接受，4、5可以被接受，6最理想</p>
<p>（1）内容耦合（⼀个模块直接修改另⼀个模块的内容，如GOTO语句；某些语⾔机制⽀持直接更改另⼀个模块的代码；改变另⼀个模块的内部数据）</p>
<p>（2）公共耦合（全局变量，模块间共享全局数据，例⼦：全局变量）</p>
<p>（3）重复耦合（模块间有重复代码）</p>
<p>（4）控制耦合（⼀个模块给另⼀个模块传递控制信息，如“显式星期天”）</p>
<p>（5）印记耦合（共享数据结构却只是⽤了⼀个部分）</p>
<p>（6）数据耦合（模块间传参只传需要的数据，最理想）</p>
<p>（重要）<strong>内聚</strong>：表达的是⼀个模块内部的联系的紧密性。</p>
<p>内聚性由⾼到低分为：内聚性越⾼越好，越低越不易实现变更和重⽤，3、4、5等价，1、2最好，6、7不能接受。</p>
<p>（1）信息内聚（模块进⾏许多操作，各有各的入口点，每个操作代码相对独立，而且所有操作都在相同的数据结构上进行：如栈） </p>
<p>（2）功能内聚（只执⾏⼀个操作或达到⼀个⽬的） </p>
<p>（3）通信内聚（对相同数据执⾏不同的操作：查书名、查书作者、查书出版商） </p>
<p>（4）过程内聚（与步骤有关：守门员传球给后卫、后卫传给中场球员、中场球员传给前锋） </p>
<p>（5）时间内聚（与时间有关：起床、刷⽛、洗脸、吃早餐） </p>
<p>（6）逻辑内聚（⼀系列可替换的操作：如坐车、坐飞机） </p>
<p>（7）偶然内聚（多个不相关的操作：修车、烤⾯包、遛狗、看电影） </p>
<p>&nbsp;</p>
<p><strong>软件构造</strong>：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，生产可工作的、有意义的软件的详细创建过程。</p>
<p>软件构造的主要活动包括:详细设计、编程、测试、调试、代码评审、集成与构建、构造管理。</p>
<p><strong>重构</strong>：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。不改变代码的外部表现，是指不改变软件系统的功能。改进代码的内部结构是指提升详细设计结构的质量，使其能够继续演化下去。</p>
<p>重构最早是用来进行软件维护的方法，它用来解决维护中的下列常见问题：</p>
<ul>
<li>因为无法预计到后续数年的修改，导致软件开发阶段的设计方案不能满足修改要求</li>
<li>随着修改次数的增多，软件设计结构的质量越来越脆弱，很难继续维持可修改性</li>

</ul>
<p><strong>测试驱动开发</strong>：测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。 测试代码之后，程序员再编写程序代码，并在编程中重复执⾏测试代码，以验证程序代码的正确性。</p>
<p><strong>结对编程</strong>：两个程序员挨着坐在⼀起，共同协作进⾏软件构造活动，分为Driver(驾驶员)负责 输⼊代码和Observer(观察员)进⾏评审。编程控制权可以转换。</p>
<p><strong>逆向工程</strong>：分析⽬标系统，标识系统的部件及其交互关系，并且使⽤其它形式或者更⾼层的抽象创建系统表现的过程。</p>
<p>逆向⼯程的基本原理是抽取软件系统的需求与设计⽽隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建⽴对系统更加准确和清晰的理解。</p>
<p><strong>再工程</strong>：再工程主要是检查和改造⼀个⽬标系统，⽤新的模式式及其实现复原该⽬标系统。⽬的是对遗留软件系统进⾏分析和重新开发，以便进⼀步利⽤新技术来改善系统或促进现存系统的再利⽤。</p>
<p>主要包括：改进⼈们对软件的理解；改进软件⾃⾝，通常是提⾼其可维护性、可复⽤性和可演化性。</p>
<p>逆向工程的关注点是理解软件，但并不修改软件，再工程恰恰相反，它主要关注如何修改软件，在处理遗留软件时，再工程之前通常需要一个前导的逆向工程。</p>
<p>&nbsp;</p>
<h2 id='简答题'>简答题</h2>
<p><strong>软件工程从1950s—2000s之间的发展特点</strong>：</p>
<p>1950s：科学计算；以机器为中⼼进⾏编程；像⽣产硬件⼀样⽣产软件。</p>
<p>1960s：业务应⽤（批量数据处理和事物计算）；软件不同于硬件；⽤软件⼯艺的⽅式⽣产软件。</p>
<p>1970s：结构化⽅法；瀑布模型；强调规则和纪律。它们奠定了软件⼯程的基础，是后续年代软件⼯程发展的⽀撑。</p>
<p>1980s：追求⽣产⼒最⼤化；现代结构化⽅法/⾯向对象编程⼴泛应⽤；重视过程的作⽤。</p>
<p>1990s：企业为中⼼的⼤规模软件系统开发；追求快速开发、可变更性和⽤户价值；web应⽤出现</p>
<p>2000s：⼤规模web应⽤；⼤量⾯向⼤众的web产品；追求快速开发、可变更性、⽤户价值和创新。</p>
<p>&nbsp;</p>
<p><strong>团队结构主要分为</strong>：主程序员团队；民主团队；开放团队</p>
<p>①主程序员团队:由⼀名技能能⼒出⾊的程序员领导团队完成任务，主程序员负责总体构思设计，然后分配任务给其他团队成员，并监督、验收和整合其他成员的⼯作完成情况。(缺点:如果项⽬过⼤，主程序员能⼒成为瓶颈，团队成员主动性低 优点:⼯作效率 ⾼)</p>
<p>②⺠主团队:项⽬经理负责管理，围绕着项⽬的计划进⾏，没有明确的⼈作为技术领导，所有团队成员都可以在各⾃擅⻓的领域担任技术领导。(缺点:交流成本⾼，容易陷⼊思想混乱。 优点:团队主动性⾼)</p>
<p>③开放团队:团队的成员都是有创造性的产品开发者，团队可以按照⾃⼰认为合适的⽅式进⾏⾃我管理。(缺点:项⽬进展与创新没有可视度 优点:创造性⾼)</p>
<p>如何管理团队：建⽴团队章程；持续沟通；和谐沟通；避免团队杀⼿ </p>
<p>&nbsp;</p>
<p><strong>质量保障活动</strong>主要有评审、测试和质量度量三种</p>
<p>评审：人进行的讨论、扫描、审查
度量：软件产品在特定属性上的量化测度程度
测试：单元测试、集成测试等</p>
<p><img src="image-20221015211714974.png" alt="image-20221015211714974" style="zoom:50%;" /></p>
<p>&nbsp;</p>
<p><strong>配置管理的活动</strong> ：
标识配置项 ：确定唯一标识与特征(基线，创建时间)
版本管理：V0.1，V2.1，Master，release
变更控制：变更需要请求，是以可控、⼀致的⽅式进⾏变更处理
配置审计：确定度量满足需求
状态报告：状态信息的维持
软件发布管理：使用文档、注意事项</p>
<p>&nbsp;</p>
<p><strong>需求获取的方式</strong>：</p>
<ul>
<li><p>⾯谈:面对面的会见，使用问答的方式</p>
</li>
<li><p>集体获取⽅法:通过⽤户们的讨论发现需求，如专题讨论会 </p>
</li>
<li><p>头脑⻛暴:特殊的群体⾯谈⽅法。(⽤于”发明“需求/发现潜在需求)</p>
</li>
<li><p>原型：通过⼀个有形的制品来增 进⽤户和需求⼯程师之间的交流</p>
<p>&nbsp;</p>
</li>

</ul>
<p><strong>区分需求的三个层次</strong>：业务需求，⽤户需求，系统级需求</p>
<p>【题型】给出⼀个实例，给出三个层次的例⼦；对给定的需求⽰例，判断其层次 </p>
<p>【业务需求】——来⾃现实：系统建⽴的战略出发点，表现为⾼层次的⽬标（Objective），它描述了组织为什么要开发系统 ，为了满⾜⽤户的业务需求，需求⼯程师需要描述系统⾼层次的解决⽅案，定义系统应该具备的特性（Feature）</p>
<p>【⽤户需求】——来⾃现实：执⾏实际⼯作的⽤户对系统所能完成的具体任务的期望，描述了系统能够帮助⽤户做些什么。对所有的⽤户需求，都应该有充分的问题域知识作为背景⽀持 </p>
<p>特性：模糊、不清晰 ；多特性混杂 ；多逻辑混杂 </p>
<p>【系统级需求】——来⾃软件：⽤户对系统⾏为的期望，每个系统级需求反映了⼀次外界与系统的交互⾏为，或者系统的⼀个实现细节。描述了开发⼈员需要实现什么 </p>
<p>&nbsp;</p>
<p><strong>掌握需求的分类</strong>：</p>
<ul>
<li><p>功能需求:和系统主要⼯作相关的需求 ，在不考虑物理约束的情况下，⽤户希望系统所能够执⾏的活动，功能需求主要表现为系统和环境之间的⾏为交互。</p>
</li>
<li><p>性能需求:⼀个系统或者其组成部分在限定的约束下，完成指定功能的程序， 例如速度、内存使⽤程度。 </p>
</li>
<li><p>质量属性:隐式的需求.分为可靠性,可⽤性,安全性,可维护性,可移植性,易⽤性 </p>
</li>
<li><p>对外接⼝:指系统和环境中其他系统之间需要建⽴的接⼝。包括硬件接口、软件接口、数据库接口等系统和其他系统之间的软硬件接口</p>
<p>接口的⽤途，接开口的输⼊输出，数据格式，命令格式，异常处理要求；⽤户界⾯ </p>
</li>
<li><p>约束:指系统构造时下需要遵守的约定，常⻅的包括系统开发以及运⾏环境、 问题域内的相关标准和商业规则。 </p>
</li>
<li><p>数据需求:常⽤于与数据库、⽂件等存储数据的描述</p>
</li>

</ul>
<p>&nbsp;</p>
<p><strong>建立用例图</strong> （四要素：用例 参与者 关系 系统边界）（其他看相关整理）</p>
<p>• 参与者是与开发的系统进⾏交互的⽤户或其他系统等⾓⾊ </p>
<p>• ⽤例图中⼀个单⼀的参与者可以代表多个⽤户（或系统） </p>
<p>• ⼀个单⼀的⽤户（或系统）可能扮演多种⾓⾊ </p>
<p>• 参与者不⼀定是⼈，例如，需要从当前系统获取信息的外部系统也是参与者</p>
<p>步骤：1）⽬标分析与解决⽅向确定 2）寻找参与者 3）寻找⽤例 4）细化⽤例</p>
<p>&nbsp;</p>
<p><strong>软件设计的核心思想</strong>：分解和抽象，无论是分解和抽象都具有层次性</p>
<p><strong>分解</strong>：横向上将系统分割为几个相对简单的子系统以及各子系统之间的关系。
			分解之后每次只需关注经过抽象的相对简单的子系统及其相互间的关系，从而降低了复杂度。</p>
<p><strong>抽象</strong>：在纵向上聚焦各子系统的接口。
			抽象可以分离接口与实现，让人更好地关注系统本质，从而降低复杂度。</p>
<p>&nbsp;</p>
<p><strong>软件设计分层</strong>：</p>
<p><strong>高层设计</strong>：基于反映软件⾼层抽象的构件层次，描述系统的⾼层结构，关注点和设计决策</p>
<p><strong>中层设计</strong>：更加关注组成构件的模块的划分、导⼊/导出、过程之间调⽤关系或者类之间的协作。</p>
<p><strong>低层设计</strong>：深⼊模块和类的内部，关注具体的数据结构、算法、类型、控制结构等</p>
<p>&nbsp;</p>
<p><strong>软件设计的方法</strong>：</p>
<p><strong>结构化设计</strong>：采取自下向上、逐步求精的思路，按照功能对系统进行分解</p>
<p><strong>面向对象设计</strong>：源于数据抽象和指责驱动，利用封装、继承等方法提高软件可扩展性和可复用性</p>
<p><strong>数据结构为中心设计</strong>：首先描述输入输出的数据结构和对应的逻辑控制</p>
<p><strong>基于构件设计</strong>：软件构件是具有良好定义的结构和依赖的独立单元，可独立组装和部署。基于构件设计重点在于构件的提供、开发和集成</p>
<p><strong>形式化方法设计</strong>：通过数学方法来对复杂系统进行建模</p>
<p>常见的软件设计视角：</p>
<p><img src="image-20221018214259528.png" alt="image-20221018214259528" style="zoom:80%;" /></p>
<p><strong>软件体系结构的定义</strong>：软件体系结构={部件，连接件，配置}     软件体系结构规定了系统的计算部件和部件之间的交互</p>
<p>部件：承载系统的主要功能，包括处理与数据
连接件：定义了部件间的交互
配置：定义了部件与连接件之间的关联方式</p>
<p>常见体系结构风格以及优缺点见szh复习指导</p>
<p>&nbsp;</p>
<p><strong>软件体系结构设计过程</strong>：</p>
<ol>
<li>分析关键需求和项目约束</li>
<li>选择体系结构风格</li>
<li>进行软件体系结构逻辑(抽象)设计</li>
<li>依赖逻辑设计进行软件体系结构(实现)设计</li>
<li>完善体系结构设计</li>
<li>添加构件接口</li>
<li>迭代过程3-7</li>

</ol>
<p>&nbsp;</p>
<p><strong>集成的策略有哪些</strong>：</p>
<ol>
<li><p><strong>大爆炸式</strong> ：将所有模块一次性组合在一起 
优点：迅速
缺点：一次试运行成功的可能性不大，问题定位和修改困难，许多接口错误很容易躲过测试</p>
</li>
<li><p><strong>自顶向下集成</strong>：先集成和测试上层模块，下层的模块使用伪装的具有相同接口的桩。不断加入下层模块，最终所有模块都被集成进来，集成测试。
优点：1）按深度优先可以首先实现和验证一个完整的功能需求  2）只需最顶端一个驱动  3）利于故障定位
缺点：1）桩的开发量大  2）底层验证被延迟  3）底层测试不充分</p>
<p><img src="image-20221018215240809.png" alt="image-20221018215240809" style="zoom:50%;" /></p>
</li>
<li><p><strong>自底向上集成</strong>：自底向上集成与自顶向下集成的集成顺序相反，是从最底层的模块集成测试起,测试的时候上层的模块使用伪装的相同接口的驱动来替换。
优点：1）对底层组件验证较早  2）底层组件开发可以并行  3）利于故障定位  4）桩的工作量少
缺点：1）驱动的开发量大  2）高层验证被延迟</p>
<p><img src="image-20221018215319252.png" alt="image-20221018215319252" style="zoom:50%;" /></p>
</li>
<li><p><strong>持续集成</strong>：提成尽早集成和频繁集成
尽早集成：不要总是等待一个模块开发完成才集成，在开发之初就利用stub集成起来
频繁集成：每次完成一些开发任务，就用开发结果替换stub中相应的组件
优点：1）防止出现无法集成和发布的情况  2）有利于检查和发现继承缺陷</p>
</li>

</ol>
<p><strong>桩Stub</strong>：依据模块接⼜建⽴桩程序Stub——为了完成程序的编译和连接⽽使⽤的暂时代码，对外模拟和代替承担模块接⼜的关键类，⽐真实程序简单的多，使⽤最为简单的逻辑</p>
<p>模仿下层模块，用于测试上层   例：开发getUserById方法，桩直接返回某一特定的User信息。</p>
<p><strong>驱动Driver</strong>：编写驱动程序，在桩程序帮助下进⾏集成测试，View的测试⽐较特殊，其他层都需要增加Driver进⾏测试，可以基于Junit编写Driver；基于接规口格设计测试⽤例</p>
<p>• 开发View层时：需要logic的stub </p>
<p>• 开发logic层时：需要模仿view的driver，需要data的stub，需要模拟同层调⽤的driver和stub </p>
<p>• 开发data层时：需要模拟logic的driver</p>
<p>&nbsp;</p>
<p><strong>不同用户的任务模型具有差异性</strong>：</p>
<p>按照用户群体自身的特点，可以将其划分为新手用户、专家用户、熟练用户</p>
<p>●新手用户是对业务不熟悉的人，例如新员工或者新接触系统的人。为新手用户设计系统时要关注易学性，进行业务导航，尽量避免出错。。</p>
<p>●专家用户是能够熟练操作计算机完成业务任务的人，--般都是长时间使用软件系统并且计算机操作技能熟练的人。为专家用户设计系统时，要关注效率。</p>
<p>●熟练用户，介于新手用户和专家用户之间的人。为熟练用户设计人机交互系统要在易学性和效率之间进行折中。</p>
<p>好的⼈机交互应该为不同的⽤户群体提供差异化的交互机制。 </p>
<p>既为新⼿⽤户提供易学性⾼的⼈机交互机制（图形界⾯） </p>
<p>又为专家⽤户提供效率⾼的⼈机交互机制（命令⾏、快捷⽅式、热键） </p>
<p>&nbsp;</p>
<p><strong>导航 、反馈</strong>：（详见szh复习文档）</p>
<p>导航：主动将自己的产品和服务简明扼要地告诉用户
反馈：需要对用户行为进行反馈，让用户能够意识到行为的结果</p>
<p><strong>人机交互设计原则</strong>：1）简洁设计  2）一致性设计  3）低出错率设计  4）易记性设计</p>
<p>&nbsp;</p>
<p><strong>详细设计的出发点</strong>：</p>
<p>软件详细设计在软件体系结构设计之后进行，以需求开发的结果(需求规格说明和需求分析模型)和软件体系结构的结果(软件体系结构设计方案与原型)为出发点。</p>
<p>在体系结构设计中主要关注的是高层设计
在详细设计中一般进行中层设计和低层设计。</p>
<p>&nbsp;</p>
<p><strong>面向对象设计的过程</strong>：</p>
<ol>
<li><p>设计模型建立</p>
<ul>
<li>通过职责建立静态设计模型：抽象类的职责、抽象类之间的关系、辅助类</li>
<li>通过协作建立动态设计模型：抽象对象之间协作、明确对象的创建、选择合适的控制风格</li>

</ul>
</li>
<li><p>设计模型重构</p>
<ul>
<li>根据模块化的思想进行重构，目标为高内聚、低耦合</li>
<li>根据信息隐藏的思想重构，目标为隐藏职责与变更</li>
<li>利用设计模式重构</li>

</ul>
</li>

</ol>
<p><strong>控制风格</strong>：为了完成某⼀个⼤的职责，需要对职责的分配做很多决策。控制风格决定了决策由谁来做和怎么做决策 </p>
<p>分散式：没有明确的控制对象，每个对象都只承担一个相对较小的职责</p>
<p>集中式：做决策的往往只有只有一个对象，由这个对象来决定怎么分配职责，怎么来实现大的职责。</p>
<p>委托式（授权式）：做出决策的对象不止一个，各个对象分别承担一定职责，做出一定决策</p>
<p><img src="image-20221019212804620.png" alt="image-20221019212804620" style="zoom:80%;" /></p>
<p><strong>建立设计类图或详细顺序图</strong>：</p>
<p>抽象类的职责-&gt;抽象类之间的关系-&gt;添加辅助类 </p>
<p>辅助类：接口类、记录类（数据类）、 启动类、控制器类、实现数据类型的类、容器类 </p>
<p>&nbsp;</p>
<p><strong>信息隐藏基本思想</strong>：</p>
<p>信息隐藏的核心设计思路是每个模块都隐藏⼀个重要的设计决策——职责。职责体现为模块对外的⼀份契约，并且在这份契约之下隐藏的只有这个模块知道的决策或者说秘密，决策实现的细节仅自己知道。 </p>
<p>模块的信息隐藏：模块的秘密（容易变更的地⽅）：根据需求分配的职责、内部实现机制。 </p>
<p>模块说明重要记录两个方面的四个主题：</p>
<ul>
<li><p>从内部角度说模块所隐藏的秘密：</p>
<ul>
<li>来自需求的主要秘密</li>
<li>根源于实现的次要秘密</li>

</ul>
</li>
<li><p>从外部角度看：</p>
<ul>
<li>模块承担的角色</li>
<li>提供的接口</li>

</ul>
</li>

</ul>
<p><strong>面向对象机制</strong></p>
<p>• 封装：封装类的职责，隐藏职责的实现＋预计将要发⽣的变更</p>
<p>• 抽象类（接⼜）/继承（实现）：抽象它的接⼜，并隐藏其内部实现</p>
<p>&nbsp;</p>
<p>（理解）<strong>面向对象中的关联关系（访问耦合）和继承关系（集成耦合）</strong></p>
<p><strong>访问耦合</strong>：</p>
<p><img src="image-20221019213808494.png" referrerpolicy="no-referrer" alt="image-20221019213808494"></p>
<p>降低访问耦合的方法：</p>
<ol>
<li>针对接口编程</li>
<li>接口分离原则</li>
<li>迪米特法则</li>

</ol>
<p><strong>继承耦合</strong>：</p>
<p><img src="image-20221019213923142.png" referrerpolicy="no-referrer" alt="image-20221019213923142"></p>
<p>（在上述各种类型的继承耦合关系中，修改规格、修改实现、精化规格三种类型是不可接受的。精化实现是可以接受的，也是经常被使用的。扩展是最好的继承耦合，但并非每个继承关系都能达到只扩展不调整的程度。）</p>
<p>降低继承耦合的方法：</p>
<ol>
<li>李氏替换原则</li>
<li>组合替代继承</li>

</ol>
<p>&nbsp;</p>
<p>（理解）<strong>面向对象中的内聚</strong>：</p>
<ul>
<li><p>方法的内聚</p>
<ul>
<li>和结构化方法中的函数内聚一致：功能、通信、过程、时间、逻辑、偶然</li>

</ul>
</li>
<li><p>类的内聚</p>
<ul>
<li>方法和属性是否一致</li>
<li>属性之间是否体现一个职责</li>
<li>属性之间是否可抽象</li>

</ul>
</li>
<li><p>子类与父类的继承内聚</p>
<ul>
<li>继承内聚考虑的则是继承树中类之间的内聚。如果这些类只是为了代码重用将无关的类放人继承树中，则类之间的继承内聚性就比较低。如果类之间具有很好的概念上的联系，则类之间的继承内聚性比较高。</li>

</ul>
</li>

</ul>
<p><img src="image-20221019214215755.png" alt="image-20221019214215755" style="zoom:50%;" /><img src="image-20221019214224076.png" referrerpolicy="no-referrer" alt="image-20221019214224076"></p>
<p><img src="image-20221019214215755.png" alt="image-20221019214215755" style="zoom:50%;" /><img src="image-20221019214224076.png" referrerpolicy="no-referrer" alt="image-20221019214224076"></p>
<p>提高内聚的方法：</p>
<ol>
<li>集中信息与行为</li>
<li>单一职责原则</li>

</ol>
<p>&nbsp;</p>
<p>（重点）<strong>面向对象设计原则</strong>：</p>
<ul>
<li><p>接口分离原则(Interface Segregation Principle/ISP)</p>
<ul>
<li>将一个统一的接口匹配为多个更独立的接口</li>
<li>避免不必要的耦合，实现接口最小化</li>

</ul>
</li>
<li><p>迪米特法则(Demeter Law)</p>
<ul>
<li><p>简单概括</p>
<p>1)每个单元对于其他的单元只能拥有有限的知识，只是与当前单元紧密联系的单元;
2)每个单元只能和它的朋友交谈，不能和陌生单元交谈;
3)只和自己直接的朋友交谈。</p>
</li>

</ul>
</li>
<li><p>里氏替换原则(Liskov Substitution Principle/LSP)</p>
<ul>
<li>子类型必须能够替换掉基类型而起同样的作用。</li>

</ul>
</li>
<li><p>组合替代继承(Composite/Aggregate Reuse Principle/CARP)</p>
<ul>
<li>利用组合关系，既能够复用代码，又能保持接口的灵活性</li>
<li>在希望复用代码又不能满足LSP时，使用组合替代继承</li>

</ul>
</li>
<li><p>单一职责原则(Single Responsibility Principle/SRP)</p>
<ul>
<li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的，也就是说，信息与行为除了要集中之外，还要联合起来表达一个内聚的概念，而不是单纯的堆砌，这就是单一职责原则</li>

</ul>
</li>
<li><p>开闭原则(Open Close Principle/OCP)</p>
<ul>
<li>对“扩展”开放 对“修改”关闭</li>
<li>在发生变更时，好的设计只需要添加新的代码而不需要修改原有的代码，就能够实现变更</li>

</ul>
</li>
<li><p>依赖倒置原则(Dependency Inversion Principle/DIP)</p>
<ul>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。（因为抽象是稳定的，细节是不稳定的）</li>
<li>高层模块不应该依赖于低层模块，而是双方都依赖于抽象。（因为抽象是稳定的，高层模块和低层模块都可能是不稳定的）</li>
<li>为具体类建立抽象接口并分离该接口是实现DIP的基本手段</li>

</ul>
</li>

</ul>
<p>&nbsp;</p>
<p><strong>模块化的原则</strong>：</p>
<p>1)全局变量是有害的</p>
<p>2)显式（代码清晰，不进⾏不必要的隐藏，但可能与可修改性冲突）</p>
<p>3)不要有代码重复</p>
<p>4)针对接⼜编程</p>
<p>5)迪⽶特法则（不要跟陌⽣⼈说话）</p>
<p>6)接⼜分离原则（ISP）</p>
<p>7)Liskov替换原则(LSP:⼦类型可替换掉基类型，⼀棵满⾜lSP的继承树耦合度是1)</p>
<p>8)使⽤组合代替继承（适⽤于不符合LSP但想要进⾏代码复⽤）</p>
<p>9)单⼀职责原则</p>
<p>其中1、2、3针对降低隐式耦合，4、5、6针对降低访问耦合，7、8针对降低继承耦合，9和信息专家原则用于提⾼继承内聚，亦可以看作是降低继承耦合之⽤。</p>
<p>&nbsp;</p>
<p><strong>封装的含义</strong>：</p>
<p>含义1：将数据和行为同时包含在类中</p>
<p>含义2：分离对外接口和内部实现，接口描述了类的职责，需要对外公布，供外界调用，以帮助系统满足最终需求。实现是类的内部实现机制，不需要对外公开，外界也不应该知道其内部细节。 </p>
<p><strong>封装的实现细节</strong></p>
<p>1）封装数据与行为</p>
<p>除非（直接或间接）为满足需求（类型需要），不要将操作设置为public。所有的数据都应该是private的。</p>
<p>2）封装内部结构</p>
<p>不要暴露内部的复杂数据结构，经验表明复杂数据结构是易于发⽣修改的。例如暴露了内部使⽤List数据结构。</p>
<p>3）封装其他对象</p>
<p>委托⽽不是提供⾃⼰拥有的其他对象的引⽤ </p>
<p>4）封装⼦类（LSP：⼦类必须能够替换他们的基类） </p>
<p>5）封装潜在变更</p>
<p>识别应⽤中可能发⽣变化的部分，将其与不变的内容分离开来，封装独⽴出来的潜在变化部分，这样就可以在不影响不变部分的情况下进⾏修改或扩展</p>
<p>（设计模式部分内容请仔细复习）</p>
<p>&nbsp;</p>
<p><strong>契约式设计</strong>：契约式设计又称断⾔式设计，它的基本思想是：如果⼀个函数或⽅法，在前置条件满⾜的情况下开始执⾏，</p>
<p>完成后能够满⾜后置条件，那么这个函数就是正确、可靠的。</p>
<p>1）<strong>异常</strong>：在代码开始执行时，检查前置条件是否满足；在代码执行完之后，再检查后置条件是否满足。</p>
<p><img src="image-20221019220334404.png" alt="image-20221019220334404" style="zoom: 50%;" /></p>
<p>2）<strong>断言方式</strong>：断言方式：assert Expression1(:Expression2);
Expression1是布尔表达式
Expression2是一个值，字符串、Number等</p>
<p><img src="image-20221019220403629.png" alt="image-20221019220403629" style="zoom:50%;" /></p>
<p>两者比较：
断言实现较为简单，但只能抛出AssertionError异常
异常实现较为复杂，但是方式灵活，可使用java自带异常或者自定义异常</p>
<p><strong>防御式编程</strong>：基本思想：在一个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害。</p>
<p>防御式编程可以用异常和断言来实现</p>
<p><strong>防御式、契约式对比</strong>：</p>
<p>共同点：都要检查输入参数的有效性
差异点：防御式编程只检查前置条件，并且将所有与外界的交互都纳入防御范围，包括：输入、外部文件、网络、数据库等等</p>
<p>&nbsp;</p>
<p><strong>软件测试</strong>：</p>
<ul>
<li><p>单元测试</p>
<ul>
<li>单元测试(又称为模块测试)是对程序单元(软件设计的最小单位)进行正确性检验的测试工作。</li>
<li>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是一个函数与过程。在面向对象编程中，一个单元就是类的一个方法。</li>

</ul>
</li>
<li><p>集成测试</p>
<ul>
<li>集成测试又被称为组装测试，即对程序模块一次性或采用增量方式组装起来，对系统的接口进行正确性检验的测试工作。</li>

</ul>
</li>
<li><p>系统测试</p>
<ul>
<li>单元测试、集成测试更加关注技术上的正确性，重在发现设计缺陷和代码缺陷。系统测试则不同，它更关注不符合需求的缺陷和需求自身的内在缺陷。</li>

</ul>
</li>

</ul>
<p><strong>白盒测试与黑盒测试</strong>：</p>
<p>（1）⿊盒测试：基于规格的技术，是把测试对象看做⼀个⿊盒⼦，完全基于输⼊和输出数据来判定测试对象的正确性，测试使⽤测试对象的规格说明来设计输⼊和输出数据。</p>
<p>常见方法：</p>
<ul>
<li><p>等价类划分</p>
<ul>
<li>将输入划分为若干子集，从每一个子集中选取少数具有代表性的数据作为测试用例。需要分有效等价类、无效等价类</li>
<li>例如：消费越高、折扣越高，1000以上打9折，5000以上打8折，10000以上打7折</li>

</ul>
</li>
<li><p>边界值分析</p>
<ul>
<li>边界值分析时对等价划分方法的补充，错误最容易发生在等价类的边界上</li>

</ul>
</li>
<li><p>决策表</p>
<ul>
<li><p>参考表驱动编程 在复杂的应用场景下 为每一种可能的结果，都设计测试用例</p>
<p><img src="image-20221019221021867.png" alt="image-20221019221021867" style="zoom:50%;" /></p>
</li>

</ul>
</li>
<li><p>状态转换</p>
<ul>
<li>专门针对复杂测试对象的测试技术——对象的状态不同，相同的输入可能有不同的输出结果</li>
<li>会员和非会员、节日或非节日，同样是8000的消费，所获得的折扣也都不同</li>

</ul>
</li>

</ul>
<p>（2）⽩盒测试：基于代码的技术，将测试对象看成透明的，不关⼼测试对象的规格，而是按照测试对象内部的程序结构来设计测试⽤例进⾏测试⼯作。</p>
<p><strong>白盒测试的三种方法</strong>：</p>
<p>语句覆盖：确保被测试对象的每⼀⾏程序代码都⾄少执⾏⼀次 </p>
<p>条件覆盖：确保程序中每个判断的每个结果都⾄少满⾜⼀次 </p>
<p>路径覆盖：确保程序中每条独⽴的执⾏路径都⾄少执⾏⼀次</p>
<p>&nbsp;</p>
<p><strong>软件维护</strong>：</p>
<p>软件维护是在交付之后修改软件系统或其部件的活动过程，以修正缺陷、提高性能或其他属性、适应变化的环境。</p>
<p><strong>软件维护的类型</strong></p>
<ul>
<li>完善性维护为了满足用户新的需求、增加软件功能而进行的软件修改活动。</li>
<li>适应性维护为了使软件能适应新的环境而进行的软件修改活动。</li>
<li>修正性维护为了排除软件产品中遗留的缺陷而进行的软件修改活动。</li>
<li>预防性维护为了让软件产品在将来可维护，提升可维护性的软件修改活动。</li>

</ul>
<p><strong>软件维护的重要性</strong>：</p>
<p>（1）由于会出现新的需求，如不维护软件将减⼩甚⾄失去服务⽤户的作⽤。 </p>
<p>（2）随着软件产品的⽣命周期越来越长，在软件⽣存期内外界环境发⽣变化的可能性越来越⼤，因此，软件经常需要修改以适应外界环境的改变 </p>
<p>（3）软件产品或多或少的会有缺陷，当缺陷暴露出来时，必须予以及时的解决</p>
<p><strong>开发可维护软件的方法</strong>：</p>
<ul>
<li><p>考虑软件的可变更性</p>
<ul>
<li>分析需求的易变性</li>
<li>为变更进行设计</li>

</ul>
</li>
<li><p>为降低维护困难而开发</p>
<ul>
<li>编写详细的技术文档并保持及时更新</li>
<li>保证代码的可读性</li>
<li>维护需求跟踪链</li>
<li>维护回归测试基线</li>

</ul>
</li>

</ul>
<p>（重要）<strong>软件演化生命周期模型</strong>：</p>
<p>演化式⽣命周期模型：初步开发—演化—服务—逐步淘汰—停⽌</p>
<p>（1）<strong>初步开发</strong>：按照传统的软件开发⽅式完成第⼀个版本的软件产品开发。</p>
<p>第⼀版的软件产品可以实现全部需求，也可以（通常是）只包含部分需求——对⽤户来说⾮常重要和紧急的最⾼优先级需求。</p>
<p>（2）<strong>演化</strong>：可能会有预先安排的需求增量，也可能完全是对变更请求的处理，它们的共同点都是保持软件产品的持续增值，让软件产品能够满⾜⽤户越来越多的需要，实现更⼤的业务价值。 </p>
<p>该阶段可能的演化增量有：</p>
<ul>
<li>预先安排的需求增量；</li>
<li>因为问题变化或者环境变化产⽣的变更请求；</li>
<li>修正已有的缺陷；</li>
<li>随着⽤户与开发者之间越来越相互熟悉对⽅领域⽽新增加的需求。</li>

</ul>
<p>演化阶段的软件产品要具备两个特征：</p>
<ul>
<li>软件产品具有较好的可演化性。若不满足1但满足2，进入服务阶段</li>
<li>软件产品能够帮助⽤户实现较好的业务价值。产品能够帮助⽤户实现业务价值。若不满足2，就进⼊停⽌阶段。</li>

</ul>
<p>（3）<strong>服务</strong>：服务阶段的产品仍被⽤户使⽤，因为它仍能给⽤户提供⼀定的业务价值，所以开发团队仍需要修正已有缺陷或者进⾏⼀些低程度的需求增量，保证⽤户的正常使⽤。</p>
<p>（4）<strong>逐步淘汰</strong>：在逐步淘汰阶段，开发者已经不再提供软件产品的任何服务，也即不再继续维护该软件。但是⽤户可能会继续使⽤处于该阶段的软件产品，因为它们仍然能够帮助⽤户实现⼀定的业务价值。</p>
<p>（5）<strong>停止</strong>：⼀个软件正式退出使⽤状态之后就进⾏停⽌状态。开发者不再进⾏维护，⽤户也不再使⽤。</p>
<p><img src="image-20221020214426166.png" referrerpolicy="no-referrer" alt="image-20221020214426166"></p>
<p><strong>软件的生命周期模型</strong>：</p>
<p>包含了软件从⽣产到报废的六个阶段</p>
<ul>
<li><p>软件需求⼯程</p>
</li>
<li><p>软件设计</p>
<ul>
<li>软件体系结构设计</li>
<li>软件详细设计</li>
<li>⼈机交互设计</li>

</ul>
</li>
<li><p>软件实现</p>
</li>
<li><p>软件测试</p>
</li>
<li><p>软件交付</p>
</li>
<li><p>软件维护</p>
</li>

</ul>
<p><strong>软件过程模型</strong>：</p>
<p>软件⽣命周期模型只是界定了软件开发的不同阶段之间的顺序关系。</p>
<p>软件过程模型则进一步详细说明各个阶段的任务、活动、对象及其组织、控制过程。与简略的软件生命周期模型不同，软件过程模型可以被看做是网络化的活动组织。</p>
<p>&nbsp;</p>
<p><strong>构建-修复模型</strong>：</p>
<p>开发⼈员依据个⼈分析和理解直接构造软件的第⼀个版本，并提交给⽤户使⽤，并随后修改使⽤过程中发现的缺陷，直到所有发现的缺陷都修复完成，然后进⼊维护阶段。 </p>
<p>特征：</p>
<ul>
<li>没有对开发过程进⾏规范和组织，因此⼀旦开发过程超出个⼈控制能⼒，就会导致开发过程⽆法有效进⾏⽽失败。</li>
<li>对需求的真实性没有进⾏分析</li>
<li>没有考虑软件结构的质量，导致结构在修改中越来越糟，直⾄⽆法修改</li>
<li>没有考虑测试和程序的可维护性，也没有任何⽂档，导致难以维护</li>

</ul>
<p>适⽤场景：</p>
<ul>
<li><p>软件规模很小，只需要几百行程序，其开发复杂度是个⼈能⼒能够胜任的；</p>
</li>
<li><p>软件对质量的要求不⾼，即使出错也⽆所谓；</p>
</li>
<li><p>只关注开发活动，对后期维护的要求不⾼，甚⾄不需要进⾏维护。</p>
<p><img src="image-20221020220438009.png" alt="image-20221020220438009" style="zoom:50%;" /></p>
</li>

</ul>
<p><strong>瀑布模型</strong>（文档驱动）</p>
<p>按照软件⽣命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付、软件维护等基本活动，并规定了他们自下而上， 相互衔接的开发活动次序。</p>
<p>特征：</p>
<ul>
<li>对于软件开发活动有明确阶段划分</li>
<li>每个阶段的结果都必须验证，使得该模型是“⽂档驱动”</li>

</ul>
<p>优点：清晰的阶段划分有利于开发者以关注点分离的⽅式更好的进⾏复杂软件项⽬的开发。</p>
<p>缺点：</p>
<ul>
<li>对⽂档期望过⾼；</li>
<li>对开发活动的线性顺序假设（线性顺序与迭代相反）；</li>
<li>客户、⽤户参与度不够（需求被限制在⼀个时间段）</li>
<li>⾥程碑粒度过粗（软件复杂使得每个阶段时间长，⽆法尽早发现缺陷）</li>

</ul>
<p>适⽤：</p>
<ul>
<li>需求⾮常成熟、稳定，没有不确定的内容，也不会发⽣变化；</li>
<li>所需的技术成熟、可靠，没有不确定的技术难点，也没有开发⼈员不熟悉的技术问题；</li>
<li>复杂度适中，不⾄于产⽣太⼤的⽂档负担和过粗的⾥程碑。</li>

</ul>
<p><img src="image-20221020220428170.png" alt="image-20221020220428170" style="zoom:50%;" /></p>
<p><strong>增量迭代模型</strong>（需求驱动）</p>
<p>在项⽬早期通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，将后续开发活动组织为多个迭代，并⾏的瀑布式开发活动。 </p>
<p>优点：</p>
<ul>
<li>更符合软件开发实践 </li>
<li>并⾏开发可以缩短产品开发时间</li>
<li>渐进交付可以加强⽤户反馈，降低开发风险。</li>

</ul>
<p>缺点：</p>
<ul>
<li>要求⾼：软件需要有开放式的体系结构</li>
<li>不确定性太多，导致难以在项⽬开始就确定前景和范围</li>

</ul>
<p>适⽤：⽐较成熟和稳定的领域</p>
<p><img src="image-20221020220421750.png" referrerpolicy="no-referrer" alt="image-20221020220421750"></p>
<p><strong>演化模型</strong>：（需求驱动）</p>
<p>早期明确系统的核⼼需求，建⽴并交付核⼼系统。依据⽤户反馈迭代并⾏的组织瀑布式开发活动进⾏精化，增强系统。</p>
<p>特点：</p>
<p>更好地应对需求变更，更适⽤于需求变更⽐较频繁或不确定性较多的领域。</p>
<p>将软件开发组织为多个迭代、并⾏的瀑布式开发活动。是迭代＋并⾏＋渐进 </p>
<p>优点：</p>
<ul>
<li>适⽤于需求变更频繁或者不确定性多的系统的开发</li>
<li>并⾏开发可以缩短开发时间</li>
<li>加强⽤户反馈，降低开发风险</li>

</ul>
<p>缺点：</p>
<ul>
<li>⽆法在项⽬早起确定项⽬范围</li>
<li>后续迭代活动以前导迭代为基础，容易使后续迭代忽略分析与设计。退化为构建－修复⽅式。</li>

</ul>
<p>适⽤：不稳定领域的⼤规模软件系统</p>
<p><img src="image-20221020220413996.png" alt="image-20221020220413996" /></p>
<p><strong>原型模型</strong>：（需求驱动）</p>
<p>在真正的产品构造前，通过向⽤户不完整的系统原型⽤于解决需求不确定的问 题，并采⽤逐步求精的思想安排后续开发活动。</p>
<p>特点：⼤量使⽤抛弃式原型（抛弃式原型：通过模拟“未来”的产品，将“未来”的知识置于“现在”进⾏推敲，解决不确定性）。</p>
<p>优点：</p>
<ul>
<li>加强与客户、⽤户的交流，更好的产品满意度</li>
<li>适⽤于不确定性⼤的新颖领域</li>

</ul>
<p>缺点：</p>
<ul>
<li>成本较⾼，有耗尽时间和费⽤的风险</li>
<li>有⼈不舍得抛弃“抛弃式原型”，使得较差代码进⼊产品，降低质量</li>

</ul>
<p>适⽤：有着⼤量不确定性的新颖领域</p>
<p><img src="image-20221020220413996.png" alt="image-20221020220413996" style="zoom:67%;" /></p>
<p><strong>螺旋模型</strong>：（风险驱动）</p>
<p>按照⻛险解决的⽅式来组织软件开发活动。</p>
<p>特点：</p>
<p>基本思想是尽早解决⽐较⾼的风险，如果有些问题实在⽆法解决，那么早发现⽐项⽬结束时再发现要好，⾄少损失要⼩得多。</p>
<p>风险是指因为不确定性（对未来知识了解有限）⽽可能给项⽬带来损失的情况，原型能够澄清不确定性，所以原型能够解决风险。</p>
<p>迭代与瀑布的结合：开发阶段是瀑布式的，风险分析是迭代的</p>
<p>优点：降低风险，减少因风险造成的损失 </p>
<p>缺点：</p>
<ul>
<li>使⽤原型⽅法，为⾃⾝带来风险</li>
<li>模型过于复杂，不利于管理者依据其组织软件开发活动。</li>

</ul>
<p>适⽤性：⾼风险的⼤规模软件系统开发</p>
<p><img src="image-20221020220349038.png" alt="image-20221020220349038" style="zoom:50%;" /></p>
<p><strong>Rational统一过程</strong>（RUP）</p>
<p>RUP没有使用经典的软件生命周期，而是把软件开发的生命周期定义为初始、细化、构造和交付4个阶段。</p>
<ul>
<li>初始阶段定义项目前景、范围和业务用例</li>
<li>细化阶段设计软件体系结构、构建核心体系结构原型</li>
<li>构造阶段完成软件系统的详细设计和实现</li>
<li>交付阶段将软件产品交付给用户</li>

</ul>
<p>在每个生命周期阶段，都可以根据开发工作的需要安排多次迭代。</p>
<p>优点:</p>
<ul>
<li>既适合⼩项⽬⼜适合⼤项⽬。</li>
<li>有软件⼯程⼯具⽀持。</li>
<li>合理有效 </li>

</ul>
<p>缺点</p>
<ul>
<li>没有考虑软件维护问题</li>
<li>RUP裁剪配置⼯作较难</li>

</ul>
<p><img src="image-20221020220349038.png" alt="image-20221020220349038" style="zoom:50%;" /></p>
</body>
</html>