<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>软统复习</title>
</head>
<body><h1 id='软统复习'>软统复习</h1>
<p>简答题+设计题+</p>
<h2 id='软件模式'>软件模式</h2>
<ol start='' >
<li><p>软件模式的定义：将模式的一般概念应用于软件开发领域，即<strong>软件开发的总体指导思路或参照样板</strong>。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，在软件生存期的每一个阶段都存在着一些被认同的模式。</p>
</li>
<li><p>软件模式可以被认为是对软件开发这一特定“问题”的“解法”的某种统一表示，软件模式等于一定条件下的出现的问题以及解法。软件模式的基础结构由4个部分组成：</p>
<ol start='' >
<li>问题描述</li>
<li>前提条件（环境或约束条件）</li>
<li>解法</li>
<li>效果</li>
<li><img src="./assets/imgs/%E6%88%AA%E5%B1%8F2023-06-08%20%E4%B8%8A%E5%8D%883.00.23.png" referrerpolicy="no-referrer" alt="截屏2023-06-08 上午3.00.23"></li>

</ol>
</li>
<li><p>针对每个模式需要知道的：问题描述+前提条件+解法+效果+优缺点+关联解法+其他相关的模式</p>
</li>
<li><p>软件模式与具体的应用领域无关，在模式发现过程中需要遵循大三律（Rule of Three）：只有经过三个以上不同类型（或不同领域）的系统的校验，一个解决方案才能从候选模式升格为模式。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='设计模式'>设计模式</h2>
<ol start='' >
<li><p>设计模式的定义：Design Pattern是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</li>
<li><p>基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，关键元素为：<strong>名称、问题、解决方案、效果</strong>。</p>
</li>
<li><p>设计模式的别名是什么，记住英文名</p>
</li>
<li><p>设计模式的分类：</p>
<ol start='' >
<li><p>根据模式的目的（模式用来干什么），可以分成：</p>
<ol start='' >
<li>创建性（Creational）：主要用于创建对象</li>
<li>结构型（Structural）：处理类或对象的组合</li>
<li>行为型（Behavioral）：描述对类或对象怎样交互和怎样分配职责</li>
<li>分类决定了设计模式能不能联合使用</li>

</ol>
</li>
<li><p>根据范围（模式用于处理类之间的关系还是处理对象之间的关系），分成：</p>
<ol start='' >
<li>类模式：处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被建立下来，属于<strong>静态</strong>的</li>
<li>对象模式：处理对象间的关系，这些关系在运行时刻变化，更具动态性</li>

</ol>
</li>
<li><figure><table>
<thead>
<tr><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead>
<tbody><tr><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模版方法模式</td></tr><tr><td>对象模式</td><td>抽象工厂模式</td><td>（对象）适配器模式<br>组合模式<br>装饰模式<br>外观模式<br>代理模式</td><td>命令模式<br>迭代器模式<br>中介者模式<br>观察者模式<br>状态模式<br>策略模式</td></tr></tbody>
</table></figure>
</li>

</ol>
</li>
<li><p>策略模式</p>
<ol start='' >
<li><p>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。</p>
</li>
<li><p>前提条件：可以对算法进行封装，将算法的责任和算法本身分割开，委派给不同的对象管理。</p>
</li>
<li><p>效果：策略模式让算法独立于使用它的客户而变化，也称为<strong>政策模式</strong>。</p>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</p>
</li>
<li><p>策略模式的三个角色：</p>
<ol start='' >
<li>环境类：在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例。</li>
<li>抽象策略类：为所支持的算法声明了抽象方法，是所有策略类的父类。</li>
<li>策略类：实现了在抽象策略类中定义的算法。</li>

</ol>
</li>

</ol>
</li>
<li><p>优点：对“开闭原则”的完美支持，可以在不修改原本代码的情况下更换或添加算法，提高代码复用率，是一种替换继承。</p>
</li>
<li><p>缺点：客户端必须知道所有的策略类并理解其区别，一定程度上增加了系统中类的个数，可能会存在很多策略类。增加隔阂、方法调用，降低软件运行的效率。（但是这两个是大部分模式的通用缺点）</p>
</li>
<li><p>效果：生成子类化的替代方法和策略消除条件语句。</p>
</li>
<li><p>关联解法：</p>
</li>
<li><p>适用场景：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</p>
</li>

</ol>
</li>
<li><p>简单工厂模式（Simple Factory——静态工厂模式-Static Factory）</p>
<ol start='' >
<li><p>问题描述：我们需要很多源自同一个基类的子类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的特性，如果我们希望在使用这些子类时，不需要知道这些具体子类的标签，只需要知道表示该子类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的对象，此时，就可以使用简单工厂模式。</p>
</li>
<li><p>前提条件：</p>
<ol start='' >
<li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li>

</ol>
</li>
<li><p>解法：</p>
<ol start='' >
<li><p>专门定义一个类来负责创建其他类的实例，可以根据参数的不同返回不同类的实例，被创建的实例通常有共同的父亲。</p>
</li>
<li><p>三个角色：</p>
<ol start='' >
<li>工厂角色：负责实现创建所有实例的内部逻辑。</li>
<li>抽象产品角色：所创建的所有对象的父亲，负责描述所有实例所共有的公共接口。</li>
<li>具体产品角色：创建目标，所有创建的对象是这个角色的某个具体的实例。</li>

</ol>
</li>

</ol>
</li>
<li><p>效果：满足了单一职责原则(封装变化)<strong>将对象的创建和使用分离</strong>(创建本质上和使用上强耦合)，将复杂度降低，并将变化的部分和不变的部分分离开。但是对开闭原则的支持不太好。</p>
</li>
<li><p>优点：实现对象的创建和对象的使用分离。通过提供专门的工厂类用于创建对象，客户端可以免除直接创建产品对象的责任，实现了对责任的分割。通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
</li>
<li><p>缺点：工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构+<strong>那两个传统的缺点</strong>。</p>
</li>
<li><p>适用场景：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</p>
</li>

</ol>
</li>
<li><p>工厂方法模式（Factory Pattern）——针对Simple Factory的改进</p>
<ol start='' >
<li><p>问题描述：简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这<strong>违背了“开闭原则”</strong>。这也导致工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重<strong>影响了系统的灵活性和扩展性</strong>。</p>
</li>
<li><p>前提条件：和简单工厂类似。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>让工厂父类负责创建产品对象的公共接口，工厂子类负责生产具体的产品对象。</p>
</li>
<li><p>四个角色：</p>
<ol>
<li>抽象产品是定义产品的接口。</li>
<li>具体产品实现了抽象产品接口，某种具体类型的产品有专门的具体工厂建造，之间一一对应。</li>
<li>抽象工厂声明了具体的工厂方法。</li>
<li>具体工厂是抽象工厂的子类，实现了抽象工厂中定义的工厂方法，有客户调用返回一个具体产品类的实例。</li>

</ol>
</li>

</ol>
</li>
<li><p>效果：保持了简单工厂的优点，并克服了缺点，可以在允许系统不修改工厂角色情况下引进新产品。</p>
</li>
<li><p>优点：增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性，符合开闭原则。</p>
</li>
<li><p>缺点：为了实现可扩展性引入了抽象层，客户端代码也是用抽象层定义，增加了系统的抽象性和理解难度+老两样。</p>
</li>
<li><p>适用场景：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p>
</li>

</ol>
</li>
<li><p>抽象工厂模式（Abstract Factory）——<strong>Kit模式</strong></p>
<ol>
<li><p>问题描述：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>前提条件：需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>提供一个创建一系列相关或互相依赖对象的接口，而无需制定他们具体的类。</p>
</li>
<li><p>四个角色</p>
<ol>
<li>抽象工厂生命生成抽象产品的方法。</li>
<li>具体工厂实现了抽象工厂声明的生成抽象产品的方法。</li>
<li>抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。</li>
<li>具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/https://camo.githubusercontent.com/2eeaf05248a2265c65186ac744723148acf685fbbb2c484300b4debb9a9c3db7/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330332f31312e706e67" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：隔离了具体类的生成，客户不需要知道什么被创建，可以通过修改具体工厂类实现修改，增加和替换产品族方便，以实现高内聚低耦合的设计目的。</p>
</li>
<li><p>缺点：难以增加新的产品等级结构，抽象工厂中定义了所有的抽象产品，增加产品需要修改抽象工厂和其子类+老两样。</p>
</li>
<li><p>适用场景：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
</li>

</ol>
</li>
<li><p>状态模式（State Pattern）——状态对象（Object for States）</p>
<ol>
<li><p>问题描述：需要通过改变一个对象的状态改变对象的行为。</p>
</li>
<li><p>前提条件：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>封装变化——封装+委托</p>
</li>
<li><p>三个角色：</p>
<ol>
<li>环境类：也叫上下文类，是拥有状态的对象，维护抽象状态State，定义当前状态。</li>
<li>抽象状态类：定义一个接口以封装与环境类的状态相关的行为。</li>
<li>具体状态类：每一个类是抽象类的子类，实现对应环境的一个具体行为。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330352f322e706e67.png" referrerpolicy="no-referrer" alt="img"><img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330352f342e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：封装了转换规则，枚举可能的状态，方便的增加新的状态，可以通过让多个环境对象共享状态减少对像个数。</p>
</li>
<li><p>缺点：对“开闭原则”不友好。状态的结构和实现复杂，容易导致程序和代码的混乱+老两样。</p>
</li>
<li><p>适用情况：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性 变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</p>
</li>

</ol>
</li>
<li><p>命令模式（Command Pattern）——动作模式（Action）——事务模式（Transaction）</p>
<ol>
<li><p>问题描述：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁<strong>，</strong>也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可。</p>
</li>
<li><p>前提条件：</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>将请求封装为对象。</p>
</li>
<li><p>四个角色：</p>
<ol>
<li>抽象命令类：声明用于执行请求的execute等方法，通过方法调用接收者。</li>
<li>具体命令类：实现抽象命令类中的方法，对应具体的接受者对象，将接受者对象的动作绑定其中。（命令类本身不执行请求的操作内容）</li>
<li>调用者：请求的发起者。</li>
<li>接收者：执行与请求相关的操作，<strong>具体实现对请求的业务处理</strong>。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330352f372e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</p>
</li>
<li><p>优点：降低系统耦合度，增加新命令很方便。容易设计一个命令队列和宏命令。</p>
</li>
<li><p>缺点：可能会导致某些系统有过多的具体命令类+老两样。</p>
</li>
<li><p>适用情况：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作；需要将一组操作组合在一起，即支持宏命令。</p>
</li>

</ol>
</li>
<li><p>观察者模式（Behavioral）——<strong>发布-订阅</strong>（Publish/Subscribe）模式、<strong>模型-视图</strong>（Model/View）模式、<strong>源-监听器</strong>（Source/Listener）模式或<strong>从属者</strong>（Dependents）模式</p>
<ol>
<li><p>问题描述：</p>
</li>
<li><p>前提条件：</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p>
</li>
<li><p>四个角色：</p>
<ol>
<li>目标：即主题，指的是被观察的对象</li>
<li>具体目标：包含发生改变的数据，状态改变时向观察者发出通知。</li>
<li>观察者：对观察目标的改变作出反应。</li>
<li>具体观察者：维护一个指向具体目标对象的引用，储存具体观察者的状态，状态和具体目标一致。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330362f322e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p>
</li>
<li><p>优点：实现表示层和数据逻辑层的分离，在目标和观察者之间建立一个抽象耦合。</p>
</li>
<li><p>缺点：一个目标可能有多个观察者，全部通知会花费很多时间。可能会有循环依赖，导致系统崩溃。</p>
</li>
<li><p>适用情况：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</p>
</li>

</ol>
</li>
<li><p>中介者模式（Mediator）——调停者模式</p>
<ol>
<li><p>问题描述：用户对象之间的关联性过强。</p>
</li>
<li><p>前提条件：对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>用一个中介对象封装一系列对象的交互，中介者使得各对象不需要显式地相互引用，又可以独立的改变之间的交互。</p>
</li>
<li><p>四个角色</p>
<ol>
<li>抽象中介者：定义一个接口，用于各对象之间的通信。</li>
<li>具体终结者：协调各个同事对象来实现协作行为。</li>
<li>抽象同事类：定义各同事的公有方法。</li>
<li>具体同事类：每个对象引用一个中介者对象，通过与中介者通信间接完成与其他同事类的通信。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330362f31312e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</p>
</li>
<li><p>优点：简化了对象之间的交互，将各同事解耦，减少子类的生成。简化各同事类的设计。</p>
</li>
<li><p>缺点：中介者类包含了交互细节，导致中介者类的设计复杂，难以维护。</p>
</li>
<li><p>适用情况：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
</li>

</ol>
</li>
<li><p>模版方法模式（Template Methods）</p>
<ol>
<li><p>问题描述：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</li>
<li><p>前提条件：</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>将相同的代码放在父类中，而将不同的方法实现放在不同的子类中。</p>
</li>
<li><p>两个角色：</p>
<ol>
<li>抽象类：在其中定义一系列基本操作，可以是具体的也可以是抽象的。并定义一个算法的框架。</li>
<li>具体子类：抽象类的子类，实现在父类中定义的抽象基本操作，也可以覆盖。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330362f31332e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来让子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。</p>
</li>
<li><p>优点：子类定义详细的算法不会改变算法结构，实现了代码复用。子类扩展也可以增加新行为，符合“开闭原则”。</p>
</li>
<li><p>缺点：不同的实现都需要子类，导致类的个数增加，系统庞大，设计抽象。</p>
</li>
<li><p>适用情况：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法，而一些可以改变的细节由其子类来实现；通过模板方法模式还可以控制子类的扩展。</p>
</li>

</ol>
</li>
<li><p>适配器模式（Adapter）——包装器（Wrapper）</p>
<ol>
<li><p>问题描述：通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</p>
</li>
<li><p>前提条件：现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>适配器提供客户类需要的接口，把客户类的请求转化为对适配者的相应接口的调用。当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。</p>
</li>
<li><p>四个角色：</p>
<ol>
<li>目标抽象类定义客户要用的特定领域的接口。</li>
<li>适配器类：调用另一个接口，对适配者和抽象目标进行适配——核心。</li>
<li>适配者类：被适配的角色，定义一个已经存在的接口。</li>
<li>客户类：针对目标抽象类进行编程。</li>

</ol>
</li>
<li><p>结构（<code>注意这里两种模式下Adapter和Adaptee之间关系的区别</code>）：</p>
<ol>
<li>对象适配器<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330372f322e706e67.png" referrerpolicy="no-referrer" alt="imng"></li>
<li>类适配器<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330372f332e706e67.png" referrerpolicy="no-referrer" alt="img"></li>

</ol>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：将目标类和适配者类解耦，增加了类的透明性和复用性，系统的灵活性和扩展性好，符合“开闭原则”。</p>
</li>
<li><p>缺点：难以置换适配者类的方法。</p>
</li>
<li><p>适用情况：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</p>
</li>

</ol>
</li>
<li><p>组合模式（composite）——整体-部分(Part-Whole)模式</p>
<ol>
<li><p>问题描述：由于容器对象和叶子对象在功能上的区别，在使用这些对象的客户端代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。</p>
</li>
<li><p>前提条件：用于组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p>
</li>
<li><p>三个角色：</p>
<ol>
<li>抽象构件：叶子构件和容器构件对象声明接口，包含所有子类共同的行为声明和实现。</li>
<li>叶子构件：容器节点对象。</li>
<li>容器构件：表示容器节点对象。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330372f31312e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：便于对层次结构进行控制，客户端调用简单，简化客户端代码。</p>
</li>
<li><p>缺点：设计更加抽象，增加新构件会增加问题，很难对容器中的构件进行限制。</p>
</li>
<li><p>适用情况：需要表示一个对象整体或部分层次；让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节；对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</p>
</li>

</ol>
</li>
<li><p>装饰模式（Decorator0）——包装器(Wrapper)——油漆工模式</p>
<ol>
<li><p>问题描述：</p>
</li>
<li><p>前提条件：动态地给一个对象增加一些额外的职责。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>四个角色</p>
<ol>
<li>抽象构件：定义了对象的接口，可以给对象动态增加职责。</li>
<li>具体构件：定义具体的构件对象，实现抽象构件中声明的方法，装饰器可以给他增加额外的职责。</li>
<li>抽象装饰器：抽象构件类的子类，用于给具体构件增加职责。</li>
<li>具体装饰类：实现职责并负责向构件添加新职责。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330382f392e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：具有比继承更多的灵活性，用户可以根据需要增加新的具体构件类和具体装饰类。</p>
</li>
<li><p>缺点：产生很多小对象，比继承更容易出错，也更难排错，尤其是经过多次装饰的对象。</p>
</li>
<li><p>适用情况：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
</li>

</ol>
</li>
<li><p>外观模式（Facade）——门面模式</p>
<ol>
<li><p>问题描述：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面。</p>
</li>
<li><p>前提条件：要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>两个角色</p>
<ol>
<li>外观角色：客户端直接调用的角色，将从客户端发来的请求委派到子系统中去，可以同时有多个子系统角色。</li>
<li>子系统角色：实现子系统的功能，可以不是一个单独的类而是类集合。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330392f322e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：对客户系统屏蔽子系统组件，减少客户处理对象，实现了松散耦合关系，降低了大型系统中的编译依赖性，简化了系统在不同平台之间的移植过程。</p>
</li>
<li><p>缺点：不能很好的限制客户使用子系统类。没有抽象外观类，增加新子系统需要修改代码，违背“开闭原则”。</p>
</li>
<li><p>适用情况：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</p>
</li>

</ol>
</li>
<li><p>代理模式（Proxy——Surrogate）</p>
<ol>
<li><p>问题描述：一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p>
</li>
<li><p>前提条件：要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</li>
<li><p>解法：</p>
<ol>
<li><p>通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象。</p>
</li>
<li><p>三个角色</p>
<ol>
<li>抽象主题角色：声明真实主题和代理主题的共同接口。</li>
<li>代理主题：包含对真实主题的引用，操作真实主题对象。</li>
<li>真实主题：定义真实对象，实现真实的业务操作。</li>

</ol>
</li>
<li><p>结构：<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656330392f31372e706e67.png" referrerpolicy="no-referrer" alt="omg"></p>
</li>

</ol>
</li>
<li><p>效果：</p>
</li>
<li><p>优点：协调调用者和被调用者，降低系统耦合度。</p>
</li>
<li><p>缺点：增加了代理对象，导致处理变慢，实现代理增加了工作量，有些代理实现复杂。</p>
</li>
<li><p>适用情况：远程代理、虚拟代理、保护代理。</p>
</li>

</ol>
</li>
<li><p>迭代器模式随便看看</p>
</li>
<li><p>设计原则（考试的重点）</p>
<ol start='' >
<li><p>设计原则的目的：支持可维护的复用，即在支持可维护性的同时，需要提高系统的可复用性。</p>
</li>
<li><p>目标：</p>
<ol start='' >
<li>开闭原则（Open Closed Principle）：要求一个软件实体应该对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</li>

</ol>
</li>
<li><p>指导：</p>
<ol start='' >
<li>最小知识原则（The Least Knowledge Principle，又叫作迪米特法则（Law of Demeter）：一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。</li>

</ol>
</li>
<li><p>基础：</p>
<ol start='' >
<li>单一职责原则（Single responsibility principle）：要求在软件系统中，一个类只负责一个功能领域中的相应职责。</li>
<li>可变性封装原则：</li>

</ol>
</li>
<li><p>实现：</p>
<ol start='' >
<li>依赖倒转原则（Dependence Inversion Principle）：要求抽象不应该依赖于细节而细节应该依赖于抽象，要针对接口编程不是针对实现编程。</li>
<li>合成复用原则（Composite Reuse Principle）：要求复用时尽量使用对象组合，而不使用继承。</li>
<li>里氏代换原则（Liskov Substitution Principle）：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li>
<li>接口隔离原则（Interface Segregation Principle）：要求客户端不应该依赖于那些他不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</li>

</ol>
</li>

</ol>
</li>
<li><p>原则之间的关系，目的都是开闭原则</p>
</li>

</ol>
<h2 id='表驱动法table-driven-methods）'>表驱动法（Table-Driven Methods）</h2>
<ol start='' >
<li><p>掌握表驱动法本身的内容，要么直接考表驱动，要么给数据然后识别出分离成表。</p>
</li>
<li><p>表驱动法是一种编程模式(scheme)：从表里面查找信息而不使用逻辑语句(if和case)，因此表驱动法适用于复杂的逻辑。表驱动法的另一个好处是可以将复杂逻辑从代码中独立出来，以便于单独维护。</p>
</li>
<li><p>表中一般存放数据，某些特殊情况也可以存放动作。</p>
</li>
<li><p>如何快速从表中查询条目</p>
<ol start='' >
<li><p>直接访问</p>
</li>
<li><p>索引访问</p>
<ol start='' >
<li><p>无法直接从表中查询需要的条目，需要借助其他办法先获取表键值。</p>
</li>
<li><p>先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据。</p>
</li>
<li><p>索引表是一种间接访问的技术。</p>
</li>
<li><p>优点：</p>
<ol start='' >
<li>如果主查询表中的每一条记录都很大，那么索引数组就 可以节省很多空间。</li>
<li>即使你用了索引以后没有节省内存空间， 操作位于索引中的记录有时也要比操作位于主表中的记录更方便更廉价。</li>
<li>编写到表里面的数据比嵌入代码中的数据更容易维护。</li>

</ol>
</li>

</ol>
</li>
<li><p>阶梯访问</p>
<ol start='' >
<li>阶梯访问方法不像索引结构那样直接， 但是它要比索引访问方法节省空间。</li>
<li>基本思想：通过确定每项命中的阶梯层次确定其归类。</li>

</ol>
</li>

</ol>
</li>

</ol>
<h2 id='软件体系结构'>软件体系结构</h2>
<p>4+1视图必考，考纯背诵</p>
<ol>
<li><p>什么是软件体系结构</p>
<ol>
<li><p>定义1:程序或计算系统的软件架构是系统的一个或多个结构，其中包括软件组件、组件的外部可见属性以及它们之间的关系。</p>
</li>
<li><p>系统的基本组织体现在其组件、组件之间的相互关系、环境以及支配其设计和演进的原则。</p>
</li>
<li><p>Module和Component的区别</p>
<ol>
<li>Component是已经实现的软件部分</li>
<li>Module是还未实现的软件部分</li>
<li>Element包含了Component和Module</li>

</ol>
</li>
<li><p>体系结构强调非功能性需求（Non- functional requirements）</p>
<ol>
<li>功能性需求定义系统能做什么，NFA定义了能做多好。</li>
<li>NFA很少在功能性需求中被发现，必须由体系结构引出，包括：技术约束、商业约束、质量属性</li>

</ol>
</li>

</ol>
</li>
<li><p>软件体系结构能做什么：倾听用户理解需求、检查灵活性、形成实际结构版本创建蓝图、监督构建过程保证计划符合规范、引导暴风雨式的设计变更、危机和歧义。</p>
</li>
<li><p>软件体系结构的来源：NFRs、ASRs、质量需求、涉众、组织、技术环境、业务目标、商业与技术决策组合</p>
</li>
<li><p>4+1视图（<em>重中之重</em>）</p>
<ol>
<li>逻辑视图：描述了体系结构中重要元素和他们之间的关系。</li>
<li>过程视图：描述了体系结构的并发和元素之间的交流。</li>
<li>物理视图：描述了主要过程和组件是如何被映射到硬件上的。</li>
<li>发展视图：描述了组件的内部组织联系。</li>
<li>架构用例：捕获体系结构的需求，与超过一个常规视图关联。</li>

</ol>
</li>
<li><p>软件体系结构的活动和过程</p>
<ol>
<li><p>活动：</p>
<figure><table>
<thead>
<tr><th>活动</th><th>输入</th><th>输出</th></tr></thead>
<tbody><tr><td>创建商业案例</td><td>问题域</td><td>商业案例</td></tr><tr><td>了解用户需求</td><td>用户的模糊需求</td><td>架构攸关需求</td></tr><tr><td>创建或选择体系结构</td><td>策略、模式和备选场景</td><td>被选中的策略、模式和场景</td></tr><tr><td>沟通体系结构</td><td>架构设计文档</td><td>&nbsp;</td></tr><tr><td>分析和评估体系结构</td><td>架构设计文档</td><td>&nbsp;</td></tr><tr><td>实现体系结构</td><td>架构设计文档</td><td>架构设计的具体实现</td></tr><tr><td>保证体系结构的一致性</td><td>架构设计的具体实现</td><td>保持一致的架构设计具体实现</td></tr></tbody>
</table></figure>
</li>
<li><p>过程（Possess）：</p>
<figure><table>
<thead>
<tr><th style='text-align:center;' >过程</th><th style='text-align:left;' >输入</th><th>输出</th></tr></thead>
<tbody><tr><td style='text-align:center;' >识别ASRs</td><td style='text-align:left;' >&nbsp;</td><td>优化的质量属性场景</td></tr><tr><td style='text-align:center;' >架构设计</td><td style='text-align:left;' >优化的质量属性场景、需求和约束、模式和决策</td><td>一组候选视图的草图</td></tr><tr><td style='text-align:center;' >架构文档话</td><td style='text-align:left;' >一组候选视图的草图</td><td>View&amp;Beyond</td></tr><tr><td style='text-align:center;' >架构评估</td><td style='text-align:left;' >View&amp;Beyond、优化的质量属性场景</td><td>View&amp;Beyond</td></tr></tbody>
</table></figure>
<p>&nbsp;</p>
</li>

</ol>
</li>
<li><p>软件体系结构的知识领域</p>
</li>
<li><p>Architecture，structure和Design的区别</p>
<ol>
<li>Design 包含 Architecture，Architecture 包含 Structure</li>
<li>结构是静态的、逻辑的，是关于系统如何构成的</li>
<li>体系结构除包含架构，还会包含组件之间的相关的关系结构，并定义一些动态的行为。</li>
<li>体系结构是关于软件设计的，所有体系结构都是设计，但是不是所有的设计都是体系结构，体系结构是软件设计的一个部分</li>

</ol>
</li>

</ol>
<h2 id='质量属性'>质量属性</h2>
<p>考纯背诵</p>
<ol>
<li><p>功能性需求</p>
<ol>
<li>FR定义了系统必须做什么并且强调了系统如何提供价值给涉众，即表示系统的行为，系统能做什么。</li>
<li>功能在很大程度上与结构无关，因为它可以作为单个整体系统存在而没有任何内部结构。</li>

</ol>
</li>
<li><p>质量需求/质量属性/NFRs/体系结构需求</p>
<ol>
<li><p>质量需求是系统应在其功能要求之上提供的整个系统的合乎需要的特性(又称质量属性)，即对FR和整体系统的限制要求。</p>
</li>
<li><p>NFRs的分类</p>
<ol>
<li>在执行过程中可观察（External）：performance、security、availability、usability等</li>
<li>在执行过程中不可观察（Internal）：modifiability、portability、reusability、testability等</li>

</ol>
</li>

</ol>
</li>
<li><p>约束：具有零自由度的设计决策，即已经做出的预先指定的设计决策，通过接受设计决策并将其与其他受影响的设计决策进行协调，可以满足约束条件。</p>
</li>
<li><p>质量属性</p>
<ol>
<li><p>质量属性建模（modeling）</p>
<ol>
<li>刺激（Stimulus）：到达系统是需要考虑的条件。</li>
<li>刺激元（Source of Stimulus）：产生刺激的实体。</li>
<li>响应（Response）：刺激到来后工件开展的行为。</li>
<li>响应度量（Response Measure）：对刺激的响应的测量方法，以便可以测试需求。</li>
<li>环境（Environment）：发生刺激时系统的状态。</li>
<li>工件（Artifact）：完成需求的整个系统或者系统的一部分。</li>
<li>建模方法<img src="./assets/imgs/eb82852a9eb0c77496ccf4e477c537b3.png" referrerpolicy="no-referrer" alt="img"></li>

</ol>
</li>

</ol>
</li>
<li><p>质量设计决策：</p>
<ol>
<li><p>架构是设计决策的集合。</p>
</li>
<li><p>七类设计决策(可能重叠)：</p>
<ol>
<li><p><strong>职责分配</strong> Allocation of responsibilities：将大的职责进行分配</p>
</li>
<li><p><strong>协调模型</strong> Coordination model：各部分之间的沟通、交互</p>
</li>
<li><p><strong>数据模型</strong> Data model：数据格式、存储方式(缓存等)</p>
</li>
<li><p><strong>资源管理</strong> Management of resources：CPU、网络、内存、<strong>时间(部分时间敏感的场景)等资源</strong></p>
</li>
<li><p><strong>架构元素之间的映射</strong> Mapping among architecture elements：将架构元素如何映射到软件的实现上</p>
</li>
<li><p><strong>绑定时间决策</strong>Binding time decisions：</p>
<ol>
<li>系统的变化可以在什么时间点前需要固定下来，也就是这个时间前，系统还是可以变化的，但是这个时间之后就不可以变化了</li>
<li>比如选择安装环境是需要在一个时间点前完成的，技术是否添加、编译时间、初始化时间，运行时绑定，但运行时是弹性最大的</li>
<li>实际上我们希望绑定时间越往后越好，但是也就要付出相应的代价。</li>

</ol>
</li>
<li><p><strong>技术选择</strong> Choice of technology：前面的部分都确定后，我们可以选择技术栈相对比较局限，解空间已经被压缩了。</p>
</li>

</ol>
</li>

</ol>
</li>
<li><p>质量属性</p>
<ol>
<li><p>可用性</p>
<ol>
<li><p>应用程序的关键需求，保证程序可以正常使用，但是不保证正确。</p>
</li>
<li><p>发现故障-纠正故障-重启应用</p>
</li>
<li><p>策略：消除单点故障、复制和故障转移、自动检测和重启</p>
</li>
<li><p>计算可用性的标准为在指定时间间隔内系统能在要求的范围内提供指定服务的概率</p>
<ol>
<li>MTBF：平均无故障时间</li>
<li>MTTR：平均维修时间</li>
<li><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="12.608ex" height="2.896ex" role="img" focusable="false" viewBox="0 -877 5572.9 1279.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.912ex;"><defs><path id="MJX-25-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-25-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-25-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path><path id="MJX-25-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-25-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-25-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(1632.8,394) scale(0.707)"><g data-mml-node="mi"><use data-c="1D440" xlink:href="#MJX-25-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(1051,0)"><use data-c="1D447" xlink:href="#MJX-25-TEX-I-1D447"></use></g><g data-mml-node="mi" transform="translate(1755,0)"><use data-c="1D435" xlink:href="#MJX-25-TEX-I-1D435"></use></g><g data-mml-node="mi" transform="translate(2514,0)"><use data-c="1D439" xlink:href="#MJX-25-TEX-I-1D439"></use></g></g><g data-mml-node="mrow" transform="translate(220,-345) scale(0.707)"><g data-mml-node="mi"><use data-c="1D440" xlink:href="#MJX-25-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(1051,0)"><use data-c="1D447" xlink:href="#MJX-25-TEX-I-1D447"></use></g><g data-mml-node="mi" transform="translate(1755,0)"><use data-c="1D435" xlink:href="#MJX-25-TEX-I-1D435"></use></g><g data-mml-node="mi" transform="translate(2514,0)"><use data-c="1D439" xlink:href="#MJX-25-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(3263,0)"><use data-c="2B" xlink:href="#MJX-25-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(4041,0)"><use data-c="1D440" xlink:href="#MJX-25-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(5092,0)"><use data-c="1D447" xlink:href="#MJX-25-TEX-I-1D447"></use></g><g data-mml-node="mi" transform="translate(5796,0)"><use data-c="1D447" xlink:href="#MJX-25-TEX-I-1D447"></use></g><g data-mml-node="mi" transform="translate(6500,0)"><use data-c="1D445" xlink:href="#MJX-25-TEX-I-1D445"></use></g></g><rect width="5332.9" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><script type="math/tex">\frac{MTBF}{MTBF+MTTR}</script></li>

</ol>
</li>

</ol>
</li>
<li><p>互操作性（Interoperability）</p>
<ol>
<li><p>两个或多个系统在特定的上下文中通过接口完全改拜年有意义的信息的程度。</p>
<ol>
<li>交换数据的能力——语法互操作性（syntactic）</li>
<li>能够正确解释数据——语义互操作性（semantic）</li>

</ol>
</li>
<li><p>两个要点：发现服务的位置、身份和接口；处理回应。</p>
</li>

</ol>
</li>
<li><p>可修改性（Modifiability）</p>
<ol>
<li>更改以及更改所花费的成本，包括更改可能影响其他功能或质量属性的程度。</li>
<li>四个问题：可以改变什么；改变的可能性；什么时候谁来更改；更改的费用。</li>
<li>N * 不使用机械装置进行更改的成本 ≤ 安装机械装置的成本 +(N *使用机械装置进行更改的成本)</li>

</ol>
</li>
<li><p>性能（Performance）</p>
<ol>
<li>软件与系统满足时序要求的能力</li>
<li>两个基本要素：处理时间（系统正在响应）；阻塞时间（系统无法响应）</li>

</ol>
</li>
<li><p>安全性（Security）</p>
<ol>
<li>系统保护数据和信息免遭未授权访问的能力。</li>
<li>三个特征（CIA）：机密性（Confidentiality），完整性（Integrity），可用性。</li>

</ol>
</li>
<li><p>可测试性</p>
<ol>
<li>软件通过测试证明其故障的难易程度</li>
<li>手段：限制复杂度，控制和观察系统状态</li>

</ol>
</li>
<li><p>易用性（Usability）</p>
<ol>
<li>用户完成所需任务的难易程度和系统提供的用户支持的类型。</li>
<li>包括：学习系统功能，有效使用系统，最小化错误的影响，是系统适应用户的需求，增强信心和满意度。</li>

</ol>
</li>

</ol>
</li>
<li><p>架构攸关需求（Architecturally Significant Requirements——ASRs，<em>重点</em>）</p>
<ol>
<li><p>ASR：<strong>对体系结构产生深远影响的需求</strong>，如果没有这些要求，体系结构可能会发生巨大变化。</p>
</li>
<li><p>识别ASR和来源和方法：</p>
<ol>
<li>需求文档中收集ASR：MoScoW方法和用户故事</li>
<li>采访涉众收集ASR：质量属性工作坊(QAW)</li>
<li>了解业务目标（Business goals）收集ASR</li>
<li>通过质量属性实体树(Utility Tree)来管理ASR</li>

</ol>
</li>

</ol>
</li>

</ol>
<h2 id='架构模式'>架构模式</h2>
<p>和设计模式类似，考架构模式的特点、联系、区别等</p>
<ol>
<li><p>架构模式：</p>
<ol>
<li><p>架构模式是一组架构设计决策，适用于重复出现的设计问题，并进行了参数化处理以解决出现该问题的不同软件开发环境。</p>
</li>
<li><p>架构模式与DSSA类似，但是适用于较低级别，范围更窄。</p>
</li>
<li><p> <img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331342f312e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>
<li><p>DSSA是软件组件的组合</p>
<ol>
<li>专门用于特定类型的任务</li>
<li>普遍适用于该领域的有效使用</li>
<li>有效构建成功应用程序的标准化结构组成。</li>
<li>DSSA是最大限度地重用知识和进行先期开发并因此开发新的架构设计的卓越手段。</li>

</ol>
</li>
<li><p>架构模式是在实践中反复发现的一套设计决策，具有允许重复使用的已知属性，并且描述了一类架构。</p>
</li>
<li><p>架构模式关联了三种角色</p>
<ol>
<li>背景、上下文：世界上经常发生问题的场景。</li>
<li>问题：在给定上下文中出现经过适当概括的问题。</li>
<li>解决方案（Element+Relations+Constraints）：针对问题的成功的经过适当抽象的解决方案。</li>

</ol>
</li>

</ol>
</li>
<li><p>分层模式（Layered）</p>
<ol>
<li>意义：分层模式用来构造可以分解为子任务组的程序，每个字任务都处于一个特定的抽象级别，每层都为下一层提供更高层次的服务。</li>
<li>关键点在于<strong>确定依赖</strong>，核心是<strong>关注点分离</strong>（必须逐层访问）。</li>
<li>上下文：一般桌面应用、Web</li>
<li>优点：高内聚、低耦合、易于维护</li>
<li>缺点：降低性能，导致级联修改增加开发成本。</li>

</ol>
</li>
<li><p>代理模式（Broker）</p>
<ol>
<li>意义：用于构建分布式软件系统，其中具有通过RMI交互的分离组件，代理组件负责协调通信。</li>
<li>上下文：多个同步或异步交互的远程对象组成的系统。</li>
<li>解决方案：通过提供隔离通信相关的代理，将系统通信功能与主应用程序分开。</li>
<li>优点：提高了客户端和服务端的交互行，提高scalability和expandability。整体大集群性能可能会提高。</li>
<li>缺点：局部单点性能下降，代理增加前期复杂度，可能成为通信的屏障，代理可能成为安全攻击的目标，难以测试。</li>

</ol>
</li>
<li><p>模型-视图-控制器模式（MVC）——组件-连接器模式</p>
<ol>
<li>意义：使用运行时、动态、相互之间的关系来审视，集成到了开发框架中，也是分层模式的变种，分为model（业务逻辑）、view（处理用户展示、接受用户操作）、controller（对用户操作进行处理，通知给model）。</li>
<li>优点：耦合性低，重用性高，生命周期成本低，部署快，可维护性高，方便管理。</li>
<li>缺点：没有明确定义，不适用于中小型应用程序，增加复杂度，view和controller过于紧密，view对model访问低效。</li>

</ol>
</li>
<li><p>管道-过滤模式（Pipe-and-Filter）——组件-连接器模式</p>
<ol>
<li>意义：管道和过滤器模式应用在顺序处理结构中，有一系列filter体现依赖关系，管道是过滤器之间数据流动的通道。</li>
<li>Filter：相当于Component，进行数据处理、计算作用，每个Filter有input和多个output，将数据处理后传输给后续部分。</li>
<li>Pipe：相当于Connector，连接Filter，将output导入到其他Filter的input中去，不会独立存在。</li>
<li>缺点：不适用于互动式系统，过多的过滤器导致大量的计算开销。</li>
<li> <img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331342f31312e706e67.png" referrerpolicy="no-referrer" alt="img"></li>

</ol>
</li>
<li><p>客户端-服务端模式（Client- Server）</p>
<ol>
<li>意义：一种分布式应用程序结构，在服务端和服务请求者之间划分任务和工作负载。客户端和服务端通过网络和计算机硬件进行通信，两者可能处于同一系统中。客户端不共享服务端任何资源，只请求服务器的内容和功能，如电子邮件、网络打印。</li>
<li>上下文：Windows的客户端应用。</li>
<li>缺点：服务器成为性能瓶颈，可能会单点失效，决定在哪里实现功能的决定是复杂的且难以修正。</li>

</ol>
</li>
<li><p>点对点模式（Peer-to-Peer）</p>
<ol>
<li><p>意义：点对点模式中的组件的提供者和消费者的身份不固定，且两者身份是对等的。点对点模式不仅提供服务，还提供物流，每个peer可能有一个规定对的连接数。</p>
</li>
<li><p>上下文：分布式应用程序体系结构，在对等体之间划分任务或工作负载。</p>
</li>
<li><p>优点：可以多个节点同时服务，性能好。</p>
</li>
<li><p>缺点：安全性管理，数据持久化，数据可用性，备份，修复和更改。</p>
</li>
<li><p>P2P和CS模式的区别</p>
<ol>
<li>CS模式的服务器通常设计为为客户端提供服务的集中式系统运行。</li>
<li>P2P模式的对等体是非分层网络中的同等节点或等效节点，对等体之间可以直接通信。同时也不要求节点的可用性，只要有冗余节点即可。</li>

</ol>
</li>

</ol>
</li>
<li><p>面向服务模式（Service- Oriented）</p>
<ol>
<li><p>意义：SOA的服务通过应用程序组件，通过网络上的通信协议提供给其他组件，基本原则是<strong>独立于供应商、产品和技术</strong>，服务是一个独立的功能单元。</p>
</li>
<li><p>缺点：结构复杂、无法管理独立服务的演化、服务可能成为性能瓶颈、使用中间件的性能开销。</p>
</li>
<li><p>连接器：SOAP、REST、异步消息传递。</p>
</li>
<li><p>SOA和其他架构的区别</p>
<ol>
<li>SOA有Broker的优势，但是又不继承Broker。</li>
<li>更高的互操作性和伸缩性。</li>
<li>商业模式的变化和技术可用性。</li>

</ol>
</li>

</ol>
</li>
<li><p>发布-订阅模式（Publish- Subscribe）</p>
<ol>
<li>意义：Subscribe队Publish进行注册，某个Publish发布自己的消息可能订阅其他消息。是一种消息模式，其中发布者不将消息直接发送到称为订阅者的特定接收者，而是将发布的消息送到连接器中（不知道有哪些订阅者）。类似地，订阅者表达对一个或多个类的兴趣并且仅接收感兴趣的消息，会接受到连接器的通知，而不知道发布者的存在。</li>
<li>优点：松耦合、可伸缩性、更高的可扩展性和动态网络拓扑。</li>
<li>缺点：增加延迟、降低可预测性、对消息的控制较少、降低灵活性。</li>

</ol>
</li>
<li><p>共享数据模式（Shared-Data）</p>
<ol>
<li>意义：中间安全数据供多人共享登陆访问。</li>
<li>由于CAP原则（一致性、可用性、分区容错性的平衡），仅保证最终一致性，导致设计难度大。</li>
<li>缺点：共享数据模型存在性能瓶颈、可能会单点失效、数据生产者和消费者紧耦合、中心点安全风险。</li>

</ol>
</li>
<li><p>分配模式（Map-Reduce）</p>
<ol>
<li>意义：Mao负责抽取数据中需要的信息，完成信息转换，可以有很多互相独立的Map。Reduce负责进行合并，产出最终的答案，如词频统计。</li>
<li>缺点：在数据量不够大的情况下MR模式的开销极大，不可接受。如果数据不能切分成相似的大小，则并行的收益会消失。难以编排多次归纳。</li>

</ol>
</li>
<li><p>多层模式（Multi-Tier）</p>
<ol>
<li>意义：许多系统的执行结构被组织成一组逻辑组件。每个分组被称为一个层。将组件分组到层中可能基于各种标准，例如组件的类型、执行环境等。Layer是真实存在的，这里的层是逻辑的组合，没有层次模式的强依赖关系，在不同环境中分层不同，但是软件完成内容一致。</li>
<li>缺点：大量的前期成本和复杂性。</li>

</ol>
</li>
<li><p>架构模式与策略</p>
<ol>
<li>椭圆形表示一个tactic，添加一个tactic可能会对某个质量属性有收益，但也可能有其他的负面影响。</li>
<li>圆角矩形表示添加策略后的后果。</li>
<li> <img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331342f33312e706e67.png" referrerpolicy="no-referrer" alt="img"></li>

</ol>
</li>

</ol>
<h2 id='架构设计'>架构设计</h2>
<ol>
<li><p>通用设计策略（Generic/General Design Strategy）——2022年考了，直接考原题背诵</p>
<ol>
<li>Abstraction：使用抽象让设计师关注本身结构而不关心实现，比如将系统抽象为组件和连接件或抽象为模块。</li>
<li>分解（Decomposition）：质量属性需求可以分解，针对系统某个关注点进行分解后处理，比如将整个系统分解或将某个模块分解。</li>
<li>分而治之（Divide &amp; Conquer）：将每个模块分别处理</li>
<li>生成与测试（Generation &amp; Test）：将一个特定的设计看作是一个假设；根据测试路径生成测试用例。</li>
<li>迭代与细化（Iteration &amp; Refinement）：使用迭代的方法，ADD方法多次迭代直到满足所有ASR</li>
<li>复用元素（Reuse Elements）：重用在设计过程中出现了可以复用的元素，重用现有架构</li>

</ol>
</li>
<li><p>Attribute- Driven Design（ADD）——一般是偶数年考，但是22年没考，所以23年感觉应该要么考ATAM+ADD或者都不考</p>
<ol>
<li><p>ADD的输入和输出</p>
</li>
<li><p>ADD的步骤</p>
<ol>
<li><p>步骤1：确认有足够的需求信息</p>
</li>
<li><p>步骤2：选择要分解的系统元素</p>
</li>
<li><p>步骤3：确定所选元素的ASR</p>
</li>
<li><p>步骤4：选择符合ASR的设计概念</p>
<ol>
<li>步骤4.1：找出设计问题</li>
<li>步骤4.2：列出替代模式，下属关注的策略</li>
<li>步骤4.3：从清单中选择模式/策略</li>
<li>步骤4.4：确定模式/策略与ASR之间的关系</li>
<li>步骤4.5：捕获初步的架构视图</li>
<li>步骤4.6：评估并解决不一致问题</li>

</ol>
</li>
<li><p>步骤5：实例化架构元素并分配职责</p>
</li>
<li><p>步骤6：为实例化元素定义接口</p>
</li>
<li><p>步骤7：验证和完善需求，并使其成为实例化元素的约束</p>
</li>
<li><p>步骤8：重复进行，直到满足所有ASR</p>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h2 id='架构文档化'>架构文档化</h2>
<ol>
<li><p>为什么要文档化架构</p>
<ol>
<li>交流和社交化架构设计决策</li>
<li>帮助理解和评估架构设计决策</li>
<li>刷新设计师对某些决策的记忆</li>
<li>培训架构设计人员</li>
<li>支持地理位置分散的团队</li>

</ol>
</li>
<li><p>架构文档的用途</p>
<ol>
<li>架构设计分析</li>
<li>工作分解和分配</li>
<li>部署后的维护</li>
<li>提供维护和修改决策的框架</li>

</ol>
</li>
<li><p>架构文档记录的内容</p>
<ol>
<li>组件的接口和依赖项</li>
<li>子系统的约束</li>
<li>测试场景</li>
<li>围绕设计决策的上下文信息</li>

</ol>
</li>
<li><p>架构文档化的挑战</p>
<ol>
<li>缺少普遍接受的记录软件架构的标准或方法</li>
<li>记录大型系统的架构可能会非常耗时和困难</li>
<li>对于记录架构的视图的数量和质量没有共识</li>
<li>逼近的DDL和不断发展的架构性质不利于文档的流通（这句话什么狗屁）</li>
<li>缺乏全面的符号和工具</li>

</ol>
</li>
<li><p>架构文档化的规则</p>
<ol>
<li>从读者角度撰写文档</li>
<li>避免无意义的重复</li>
<li>避免模糊性</li>
<li>适用标准的文档组织方式</li>
<li>记录理由</li>
<li>保持文档最新但不要太新</li>
<li>审查文件是否适合用途</li>

</ol>
</li>
<li><p>视图和视图之外的部分（View &amp; Beyond）</p>
<ol>
<li><p>Views 视图</p>
<ol>
<li><p>架构风格分类</p>
<ol>
<li>它是如何构建为一组实现单元的？</li>
<li>它是如何构建为一组运行时行为和交互的元素的？</li>
<li>它与环境中的非软件结构有何关系？</li>

</ol>
</li>
<li><p>架构风格（Styles vs. Patterns）</p>
<ol>
<li>架构风格是元素和关系类型的特殊化，以及关于如何使用他们的一组约束。</li>
<li>架构风格侧重于架构方法，对特定风格何时有用或无用提供更轻量级的指导。</li>

</ol>
</li>
<li><p>架构模式（Styles vs. Patterns）</p>
<ol>
<li>架构模式表达了软件系统的基本结构组织模式。</li>
<li>架构模式的一个重要部分是关注问题和上下文，以及如何在上下文中解决问题。</li>
<li>架构模式：{问题，上下文}-&gt;架构方法</li>

</ol>
</li>

</ol>
</li>
<li><p>结构关系视图</p>
<ol>
<li><p>模块视图（Module Views）</p>
<ol>
<li>模块是提供一组连贯职责的实现单元。</li>
<li>一个完整的架构文档至少有一个模块视图</li>
<li>视图示例：分解视图 Decomposition vie，使用视图 Uses view，泛化视图 Generalization view，分层视图 Layered view，领域视图 Aspects View，数据模型视图 Data model view。</li>

</ol>
</li>
<li><p>组件和连接器视图（Component- Connector Views）</p>
<ol>
<li>组件和连接器视图显示具有某些<strong>运行时存在</strong>的元素，例如进程、对象、客户端、服务器和数据存储（称为“组件”）。</li>
<li>附件说明哪些连接器连接到哪些组件。</li>
<li>通过将连接器的端点连接到组件的端口来显示附件。</li>
<li>视图示例：管道和过滤器视图 Pipe-and-filter view，客户端-服务器视图 Client-server view，点对点视图 Peer-to-peer view，面向服务的架构 (SOA) 视图 Service-oriented architecture (SOA) view，发布订阅视图 Publish-subscribe view，共享数据视图Shared-data view，多层视图 Multi-tier view。</li>

</ol>
</li>
<li><p>分配视图（Allocation Views）</p>
<ol>
<li>分配视图描述了软件单元到软件开发或执行环境元素的映射 。</li>
<li>分配视图的通常目标是将软件元素所需的属性与环境元素提供的属性进行比较，以确定分配是否成功。</li>
<li>分配视图可以描绘静态或动态视图。</li>
<li>视图示例：部署视图 Deployment view，安装视图 Install view，工作分配视图 Work assignment view，其他分配视图 Other allocation views。</li>

</ol>
</li>
<li><p>质量视图（Quality Views）</p>
<ol>
<li>安全视图 Security view</li>
<li>性能视图 Performance view</li>
<li>可靠性视图 Reliability view</li>
<li>沟通视图 Communication View</li>
<li>异常(错误处理)视图Exception view (error-handling) view</li>

</ol>
</li>

</ol>
</li>
<li><p>文档化视图（Documenting Views）</p>
<ol>
<li>步骤一：构件涉众/视图表（stakeholder/view table）</li>
<li>步骤二：合并视图（combine views）</li>
<li>步骤三：确定优先级和阶段（prioritize and stage）</li>

</ol>
</li>
<li><p>组合视图（Combing Views）：各种视图的组合，通过一张视图说明整个系统的部署信息。</p>
</li>
<li><p>视图之外的信息（Beyond views）</p>
<ol>
<li><p>这部分包含如下六个部分，此外还包含了文档控制信息（Document Control Information）</p>
<p><img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331372f31312e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>
<li><p>文档路线图（Documentation Roadmap）：说明文档中的信息，以及可以在哪里找到</p>
<ol>
<li><p>范围和总结</p>
</li>
<li><p>文档的组织方式</p>
<ol>
<li>简短的摘要</li>
<li>带注释的目录</li>

</ol>
</li>
<li><p>查看概览</p>
</li>
<li><p>涉众如何使用本文档</p>
</li>

</ol>
</li>
<li><p>视图间映射（Mapping Between View）</p>
<p><img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331372f31332e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>

</ol>
</li>

</ol>
</li>
<li><p>文档包（Documentation Package）<img src="./assets/imgs/68747470733a2f2f73707269636f6465722e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f323032312d536f6674776172652d53797374656d2d44657369676e2f696d672f6c656331372f31342e706e67.png" referrerpolicy="no-referrer" alt="img"></p>
</li>
<li><p>软件架构视图</p>
<ol>
<li><p>为什么要使用视图：</p>
<ol>
<li>视图是为了应对软件不可见的问题，屏蔽其他没有影响的部分，将关注点分离。</li>
<li>不同视图支持不同的目标和用户，突出不同的系统元素和关系。</li>
<li>不同视图将不同质量属性暴露出不同的程度。</li>

</ol>
</li>
<li><p>4个视图的目的</p>
<ol>
<li>Module View：提供一组连贯职责的实现单元。</li>
<li>Components and Connectors View：显示具有某些运行时存在的元素</li>
<li>Allocation View：描述了软件单元到软件开发或执行环境元素的映射。</li>
<li>Quality View：安全视图、性能视图、可靠性视图、沟通视图、异常（错误处理）视图。</li>
<li>组合视图：以上视图的组合</li>

</ol>
</li>

</ol>
</li>

</ol>
<h2 id='架构评估'>架构评估</h2>
<ol>
<li><p>为什么需要评估架构</p>
<ol>
<li>大型项目经常延迟交付和超出预算。</li>
<li>项目后期需要大量返工。</li>
<li>架构评估可以缓解这些问题。</li>
<li>在问题修复代价较低时尽早定位问题。</li>
<li>传播架构/设计最佳实践</li>
<li>提供更好的技术和项目信息给管理层。</li>
<li>确定培训可以对常见问题领域产生广泛影响的领域。</li>
<li>改善与商业组件供应商的互动。</li>

</ol>
</li>
<li><p>什么时候评估架构</p>
<ol>
<li>期望选择不合适的商业组件最小化风险时、涉及收购方和供应商时。</li>
<li>设计时：新架构适合需求的早期“验证”。</li>
<li>演化和升级时：评估变化的影响。</li>
<li>构建时：实际架构是否按预期构建、是否被很好的构建。</li>
<li>尽早地进行评估，因为还有时间来修复、修复错误的决定的成本相对比较小、这是最有效的质量保证和风险缓解技术之一。</li>

</ol>
</li>
<li><p>如何让评估方法更有效</p>
<ol>
<li>帮助涉众尽早问正确的问题。</li>
<li>发现趋势。</li>
<li>通过进一步分析、设计或原型制作来减轻风险。</li>
<li>所做的权衡和支持他们的理由可以适当的记录下来以供参考。</li>

</ol>
</li>
<li><p>常见的基于场景的软件体系架构评估方法：Software Architecture Analysis Method (SAAM)、Architecture Level Modifiability Analysis (ALMA)、Performance Assessment of Software Architecture (PASA)、Architecture Trade-off Analysis Method (ATAM)。</p>
</li>
<li><p>ATAM（架构权衡分析方法，Architecture Tradeoff Analysis Method）——考试一般直接默写</p>
<ol>
<li><p>重点：Stakeholders involved in ATAM+Input and Output of ATAM</p>
</li>
<li><p>阶段0：准备和建立团队</p>
<ol>
<li>参与者：评估团队领导和关键项目决策者。</li>
<li>输入：架构设计文档。</li>
<li>输出：评估计划</li>
<li>职责：根据架构设计文档生成评估计划，包括谁参加评估、如何何时何地开展评估、最后评估报告会被呈递给谁。</li>

</ol>
</li>
<li><p>阶段1：评估1</p>
<ol>
<li><p>参与者：评估团队和项目决策者。</p>
</li>
<li><p>输入：不知道。</p>
</li>
<li><p>输出：</p>
<ol>
<li>架构的简明介绍</li>
<li>业务目标（驱动因素）的说明</li>
<li>作为场景实现的特定质量属性要求的优先列表</li>
<li>效用树（Utility Tree）</li>
<li>风险和无风险部分</li>
<li>敏感点和权衡点</li>

</ol>
</li>
<li><p>职责：</p>
<ol>
<li>评估负责人介绍ATAM方法。</li>
<li>项目经理或客户从业务角度介绍业务驱动因素。</li>
<li>首席架构师介绍体系结构。</li>
<li>评估团队确定架构方法。</li>
<li>评估团队和项目决策者生成质量属性效用树(Utiltiy Tree)。</li>
<li>评估团队分析架构方法。</li>

</ol>
</li>

</ol>
</li>
<li><p>阶段2：评估2</p>
<ol>
<li><p>参与者：评估团队、项目决策者和架构涉众。</p>
</li>
<li><p>输入：不知道</p>
</li>
<li><p>输出：</p>
<ol>
<li>涉众们的优先场景列表</li>
<li>风险主题和业务驱动因素各自受到的威胁</li>

</ol>
</li>
<li><p>职责：</p>
<ol>
<li>评估负责人介绍ATAM方法和之前已经取得的成果。</li>
<li>涉众头脑风暴并确定场景优先级。</li>
<li>评估团队分析架构方法，类似第六步。</li>
<li>评估团队展示评估结果，并呈递给涉众。</li>

</ol>
</li>

</ol>
</li>
<li><p>阶段3：后续（Follow-up）</p>
<ol>
<li><p>参与者：评估团队和主要涉众。</p>
</li>
<li><p>输入：不知道。</p>
</li>
<li><p>输出：最终评估报告</p>
</li>
<li><p>职责</p>
<ol>
<li>评估团队制作一份书面最终报告，分发给主要涉众以供审核。</li>
<li>审查结束后，将报告提交给委托评估的人。</li>

</ol>
</li>

</ol>
</li>

</ol>
</li>

</ol>
</body>
</html>