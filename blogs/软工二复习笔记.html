<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href=".././css/main.css">
  <link rel="stylesheet" href=".././css/style.css">
  <title>软工二复习笔记</title>
</head>

<body>
  <header>
    <section class="header-icons-container">
      <div class="icons">
        <a href="https://space.bilibili.com/382240311">
          <span class="icon-bilibili">&#xe75d;</span>
        </a>
        <a href="https://www.yuque.com/wbw2333">
          <span class="icon-yuque">&#xeab5;</span>
        </a>
        <a href="https://tieba.baidu.com/home/main?id=tb.1.6433fdbf.2FqWgzyIaGR2BKenx54Wzw&fr=userbar">
          <span class="icon-tieba">&#xe632;</span>
        </a>
      </div>
    </section>
    <nav>
      <section class="nav-logo-container">
        <a href=".././index.html">
          <img src=".././assets/img/logo.png" alt="Logo blog">
        </a>
      </section>
      <section class="profile-link">
        <a href=".././profile.html">关于我</a>
      </section>
    </nav>
  </header>
  <main>
    <section class="grid-container blogpost-img-container">
      <img src="../assets/img/软工二封面.png" alt="future city">
    </section>
    <section class="blogpost-main-container">
      <div class="grid-container">
        <h3>软工二笔记</h3>
        <article>
          <h1 id='软工2笔记'>软工二笔记</h1>
<h2 id='需求工程'>需求工程</h2>
<p>概念：是所有需求处理活动的总和，包括<strong>收集信息、分析问题、整合观点、记录需求并验证其正确性</strong>，最终描述出软件被应用后与其环境互动形成的<strong>期望效应</strong>。</p>
<p>三个主要任务：</p>
<ol start='' >
<li>说明软件系统被应用的应用环境和目标，说明用来达成目标的软件功能（即同时说明软件“做什么”和“为什么做”）。</li>
<li>需求工程需要把目标和功能反映到软件系统中，映射为<strong>可行的软件行为</strong>，并对这些软件行为作出准确的<strong>规格说明</strong>。</li>
<li>现实世界在不断变化，因此需求工程还需要妥善处理目标和功能随着时间演化的变动情况。</li>

</ol>
<p>&nbsp;</p>
<p>利益相关人问题：</p>
<p>&nbsp;</p>
<h3 id='需求获取'>需求获取</h3>
<ul>
<li>从人、文档或者环境中获取需求的过程。</li>
<li>要利用各种方法和技术来<strong>发现</strong>需求。</li>
<li>目标分析——（1）根据问题确定目标；（2）通过分析利害关系人确定目标。</li>

</ul>
<p>需求获取的常见困难：</p>
<ol start='' >
<li>用户和开发者的背景、立场等不同</li>
<li>普通用户缺乏概括性、综合性的描述能力</li>
<li>用户存在认知困境</li>
<li>用户越俎代庖（需求时开发人员研究出来的，不是用户提出的）</li>
<li>缺乏用户参与</li>

</ol>
<p>用户需求获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型、民族志、竞品分析。</p>
<p>&nbsp;</p>
<h3 id='需求分析'>需求分析</h3>
<ul>
<li>通过<strong>建模</strong>来整合各种信息，以使人们更好的理解问题。</li>
<li>为问题提出一个需求集合，为问题界定一个有效的解决方案。</li>
<li>检查需求当中的错误、遗漏、不一致性等错误。</li>

</ul>
<p>一、 边界分析</p>
<ul>
<li>定义项目的范围</li>
<li>系统边界的定义要保证能够和周围环境形成有效的互动。</li>
<li>系统用例图通常用于定义系统边界。</li>

</ul>
<p>二、需求建模</p>
<ul>
<li>建模是为了展现和解释信息而进行的抽象描述活动。</li>
<li>常用的技术包括类图、顺序图、状态图等建模技术。</li>

</ul>
<p>需求规格说明</p>
<ul>
<li>在系统用户之间交流需求信息</li>
<li>编写文档使用模型预言（保证信息传递的准确性）+自然语言（保证文档的可读性）</li>
<li>要求简洁、精确、一致、易于理解</li>

</ul>
<h3 id='需求管理'>需求管理</h3>
<p>保证需求作用的持续、稳定和有效发挥。</p>
<p>进行变更控制：纳入和实现合理的变更请求，拒绝不合理的，控制变更的成本和影响范围。</p>
<p>&nbsp;</p>
<p>需求的表述：作为一种期望，需求通常被描述为“系统应该···”、“在···时，系统应该···”。“用户可以通过系统···”等（如：系统允许用户退回已购买的商品）。</p>
<p>&nbsp;</p>
<h4 id='问题域'>问题域</h4>
<ul>
<li>现实世界运行规律的一种反映</li>
<li>需求的产生地，也是需求的解决地</li>
<li>最终的软件产品在现实中部署，能够部分影响问题域，但不能改变现实（软件开发必须尊重问题域，不能因为技术原因修改现实世界的实际情况）</li>

</ul>
<h2 id='需求分类p71）'>需求分类（P71）</h2>
<h3 id='业务需求'>业务需求</h3>
<ul>
<li>系统建立的战略出发点，表现为高层次的目标，描述了组织为什么要开发系统</li>
<li>为了满足用户的业务需求，需求工程时需要描述系统高层次的解决方案，定义为系统应该具备的特性</li>
<li>参与各方必须要对高层次的解决方案达成一致，以建立一个共同的前景</li>
<li>特性说明了系统为用户提供的各项功能，限定了系统的范围</li>

</ul>
<h3 id='用户需求'>用户需求</h3>
<ul>
<li>执行实际工作的用户对<strong>系统所能完成的具体任务的期望</strong>，描述了系统能够帮助用户做什么——直接用户、间接用户</li>
<li>对所有的用户需求，都应该有充分的问题域只是作为背景支持</li>
<li>特性：（1）模糊、不清晰；（2）多特性混杂；（3）多逻辑混杂。</li>

</ul>
<h3 id='系统需求'>系统需求</h3>
<ul>
<li>用户对<strong>系统行为的期望</strong>，每个系统及需求反映了一次外界与系统的交互行为，或者系统的一个实现细节</li>
<li>描述了开发人员需要实现什么</li>
<li>将用户的需求转化为系统需求的过程是一个复杂的过程</li>

</ul>
<p>&nbsp;</p>
<h2 id='chapter7-需求文档'>Chapter7 需求文档</h2>
<ol start='' >
<li>需求文档最常见的两种是用例文档和软件需求规格说明文档，用例文档从用户出发、软件需求规格说明文档从软件产品的角度出发。</li>
<li>为什么需要需求规格说明：软件开发过程及其子任务与人员之间存在着错综复杂的关系，存在大量的沟通与交流，所以软件系统开发过程中需要编写以描述软件系统的解决方案。</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter8-软件设计基础'>Chapter8 软件设计基础</h2>
<ol start='' >
<li>软件设计：是针对软件对象的设计，是一种设计活动，具有设计的普遍特性。</li>
<li>软件设计的核心思想是：分解和抽象</li>
<li>分解：横向上将系统分成几个简单的子系统和子系统之间的关系。</li>
<li>抽象：在纵向上聚焦子系统之间的关系。</li>
<li>软件设计分为高层、中层、低层三个层次。高层主要思想：体系结构设计，关注部件、连接件和配置；中层主要思想：关注组成构建的模块的划分、导入/导出、过程之间调用关系或者类之间的协作；低层主要思想：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</li>
<li>软件设计的方法：结构化设计、面向对象设计、数据结构为中心设计、基于构件的设计、形式化方法设计</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter9-软件体系结构基础'>Chapter9 软件体系结构基础</h2>
<ol start='' >
<li><p>软件体系结构={部件，连接件，配置}，一个软件系统的体系结构规定了系统的计算部件和部件之间的互动。</p>
</li>
<li><p>软件体系结构风格：</p>
<p>（1） 主程序/子程序风格：适用于按层次分解为多个顺序执行步骤的系统；</p>
<p>			优点：流程清晰、易于理解；强控制型（能够保障程序的正确性）；</p>
<p>			缺点：强耦合，依赖交互双方接口规范，难以修改和复用；产生不必要的公共耦合。</p>
<p>（2）面向对象式：适用于能够<strong>基于数据信息分解和组织</strong>的软件系统；</p>
<p>			 优点：内部实现带来的可修改性；易开发、易理解、易复用的组织结构；</p>
<pre><code>		缺点：接口的耦合性；标识的耦合性；面向对象的副作用。
</code></pre>
<p>（3）分层风格：能够在不同抽象层次上进行任务分解的复杂处理；能够建立不同抽象层次之间的稳定交互协议；<strong>没有很高的实时性要求</strong>，能够容许少许的延迟；</p>
<p>			优点：设计机制清晰、易于理解；支持并行开发（不同层次不干扰，可以让不同的团队开发）；更好的可复用性和可修改行；</p>
<p>			缺点：交互协议难以修改；性能损失；难以确定层次数量和粒度。</p>
<p>（4）MVC（Model-View- Control）风格：适用于<strong>网络系统</strong>的开发；</p>
<p>			优点：易开发性；视图和控制的可修改性；适用于网络系统开发；</p>
<p>			缺点：复杂性；模型修改困难（视图和控制都依赖于模型）。</p>
</li>

</ol>
<h2 id='chapter10-软件体系结构设计与构建'>Chapter10 软件体系结构设计与构建</h2>
<ol start='' >
<li><p>体系结构设计过程</p>
<p>（1）分析关键需求和项目约束；（2）选择体系结构风格：（3）进行软件体系结构逻辑（抽象）设计；（4）依赖逻辑设计进行软件体系结构物理设计（实现）；（5）完善软件体系结构设计；（6）定义构件接口；（7）迭代（3）～（6）。</p>
</li>
<li><p>包的设计原则：</p>
</li>

</ol>
<p>				（1）REP（Reuse-Release Equivalency Principle）-复用发布等价原则：别人打开也能使用，考虑别人复用的可能性。</p>
<p>				（2）CCP（Common Closure Principle）-共同封闭原则：如果要进行修改，最好涉及一个包而不是多个，只有一个修改原因而不是多个。把相似的包放在一起，减少包发布频率，减少编程者工作量。</p>
<p>				（3）CRP（Common Reuse Principle）-共同复用原则：10个库别人只是用了一个，侧重组合减少关联。</p>
<p>				（4）ACP（Acyclic Dependencies Principle）-非循环依赖（单向依赖）：会影响编译和链接的复杂度。</p>
<p>				（5）SDP（ Stable Dependencies Principle）-稳定依赖原则：被依赖的包尽量稳定并不发生修改，不稳定的包可以分解。</p>
<p>				（6）SAP（Stable Abstract Principle）-稳定抽象原则：稳定的包应该是抽象的，不稳定的包包含需求。</p>
<ol start='3' >
<li><p>体系结构之间接口的定义</p>
<p>	提供的服务（供接口）：语法，前置条件，后置条件；</p>
<p>	需要的服务（需接口）：服务名，服务。</p>
</li>
<li><p>集成：当体系结构中各个模块的代码都经过单元测试以后，将所有的模块组合起来形成整个软件原型系统，这就是集成。</p>
</li>
<li><p>集成策略：大爆炸式；增量式；</p>
</li>
<li><p>大爆炸式</p>
<ol start='' >
<li>优点：一次性组合，短时间内迅速完成集成测试。</li>
<li>缺点：问题的定位和修改比较困难。</li>
<li>适合应用于一个维护型项目或被测试系统较小的情况。</li>

</ol>
</li>
<li><p>自顶向下式</p>
<ol start='' >
<li>优点：按深度优先可以首先实现和验证一个完整的功能需求；只需要最顶端的一个驱动（driver）；有利于故障定位。</li>
<li>缺点：桩的开发量大；低层验证被推迟底层组件验证不充分。</li>
<li>适用于控制结构比较清晰和稳定、高层接口变化比较小、底层接口未定义或经常可能被修改、控制组件具有较大的技术风险的软件系统。</li>

</ol>
</li>
<li><p>自底向上式</p>
<ol start='' >
<li>优点：对底层组件验证较早；底层组件开发可以并行；桩的工作量少；有利于故障定位。</li>
<li>缺点：驱动的开发量大；对高层的验证推迟，高层组件验证不足，错误无法及时发现。</li>
<li>适用于底层接口比较稳定、高层接口变化频繁、底层组件较早被完成的软件系统。</li>

</ol>
</li>
<li><p>持续集成：提倡尽早集成（不等待模块开发完就集成，在开发之初就用stub集成起来）和频繁集成（每次完成一部分开发，就用成果替代stub中的组件进行测试）</p>
<ol start='' >
<li>优点：防止软件开发中出现无法继承与发布的情况；有利于检查和发现继承缺陷。</li>
<li>缺点：必须使用版本持续工具和持续集成工具。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter11人机交互设计'>Chapter11人机交互设计</h2>
<ol start='' >
<li><p>人机交互设计的目标：“透明”，即易用性——易学性、易记性、效率、出错率、主观满意度。</p>
</li>
<li><p>人类因素</p>
<p>	精神模型（隐喻设计）：用户在进行人机交互时头脑中的人物模型，在设计时需要根据精神模型进行隐喻设计。优点是直观生动</p>
<p>	差异性：不同的用户群体存在差异，要根据用户群体的特点进行设计（新手用户-易学性、专家用户-效率、熟练用户-折中）。好的人机交互可以同时为不同的群体提供不同的服务。</p>
</li>
<li><p>计算机因素</p>
</li>

</ol>
<p>					可视化设计：要点是按照任务模型设计界面隐喻，不要把软件系统的内部构造机制暴露给用户。</p>
<ol start='4' >
<li><p>人机交互设计的交互性</p>
<p>	导航：有全局结构和局部结构。</p>
<p>	反馈：目的是提示用户交互行为的结果，不能打断用户工作的意识流。</p>
</li>
<li><p>人机交互设计原则</p>
<p>	简洁设计：不要使用太大的菜单、太多的信息、色彩等；</p>
<p>	一致性设计：一个系统中不能有完全不一致的交互机制（如cancel、ok健位置相反）；</p>
<p>	低出错率设计：避免人们犯错，提供错误回复和故障解决手册；</p>
<p>	易记性设计：减少用户的记忆负担（减少短期记忆、逐层递进方式展示信息、直观快捷、设置有意义的默认值）。</p>
</li>
<li><p><strong>协作式设计</strong>：人和计算机是人机交互的两方，其中人的因素是比较固定的，一定时期内不会发生大的变化，所以要让二者交互顺畅，就需要 <strong>让计算机更多地适应人的因素</strong>，这也是人机交互设计以用户为中心的根本原因。这种调整计算机因素以更好地适应并帮助用户的设计方式被称为协作式设计。</p>
</li>

</ol>
<h2 id='chapter12详细设计的基础'>Chapter12详细设计的基础</h2>
<ol start='' >
<li><p>详细设计的出发点：详细设计在软件体系结构设计之后开始，以需求设计和软件体系结构设计的成果为出发点。</p>
</li>
<li><p>通过职责建立静态模型：面向对象分解中，系统包含很多的对象，通过对象的职责（属性职责和方法职责）建模，他们之间的关系：依赖&lt;关联&lt;聚合&lt;组合&lt;继承。</p>
<p>1）抽象对象的职责（属性职责和方法职责）</p>
<p>2）抽象类之间的关系（依赖、关联、聚合、组合、继承）（类图 P204）</p>
<p>3）添加辅助类</p>
</li>
<li><p>通过协作建立动态模型：通过（1）从小到大，将对象的小职责聚合成大职责（2）从大到小，将大职责分配给各个小对象。两种方法同时运用，共同完成对协作的抽象。</p>
<p>1）抽象对象之间的协作（顺序图、状态图 P207）</p>
<p>2）明确对象的创建</p>
<p>3）选择合适的控制风格：集中式、委托式、分散式（P209-210）</p>
</li>
<li><p>用图：DFD、类图、顺序图、包图。</p>
</li>
<li><p>控制风格：</p>
<p>集中式：多决策的只有一个对象，有这个对象来决定分配职责，其余对象与这个对象交互；</p>
<p>委托式：多个做出决策的对象，分别承担一定的职责。</p>
<p>分散式：无明确的控制对象，每个对象承担一个小职责，完全靠各个对象自治。</p>
</li>
<li><p>类间协作：常常以协作图为线索开发模块内部的集成测试用例。类间协作的桩程序被称为Mock Object，不同于stub，MO要求自身测试代码更简单，不用测试就能保证正确性。</p>
</li>
<li><p>详细设计的目的是实现所有功能性需求和非功能性需求。</p>
<p>详细设计文档中需要明确定义：模块以及接口、类结构、类的协作、类接口、控制结构与函数结构、重要的数据结构与算法。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter13详细设计的模块化与信息隐藏'>Chapter13详细设计的模块化与信息隐藏</h2>
<ol start='' >
<li><p>人们希望分解出相对“独立”的模块，方法就是衡量内聚性和耦合性，希望建立高内聚、低耦合的模块。</p>
</li>
<li><p>耦合：两个模块之间关系的复杂程度。</p>
</li>
<li><p>耦合类型（高-&gt;低）：</p>
<p>	内容耦合：一个模块直接修改或者依赖于另一个模块的内容</p>
<p>	公共耦合：模块之间共享全局的数据</p>
<p>	重复耦合：模块之间有同样逻辑的重复代码</p>
<p>		<strong>以上三个耦合是不可以接受的</strong></p>
<p>	控制耦合：一个模块给另一个模块传递控制信息</p>
<p>	印记耦合：共享一个数据结构，但是却只使用其中一部分</p>
<p>	数据耦合：两个模块的所有参数是同类型的数据项</p>
</li>
<li><p>内聚：一个模块内部联系的紧密性。</p>
</li>
<li><p>内聚类型（低-&gt;高）：</p>
<p>	偶然内聚：模块执行多个不相关的操作</p>
<p>	逻辑内聚：模块执行一系列相关操作，每个操作的调用由其他模块决定（一系列逻辑上相似但没有直接关联的操作）</p>
<p>		<strong>以上两个内聚是不可以接受的</strong></p>
<p>	时间内聚：模块执行一系列与时间有关的操作</p>
<p>	过程内聚：模块执行一系列与步骤顺序相关的操作</p>
<p>	通信内聚：模块执行一系列与步骤相关的操作，并且这些操作在相同的数据上进行（针对同一个数据进行操作）</p>
<p>	功能内聚：模块只执行一个操作或达到一个单一的目的（如程序只是计算一个平方根）</p>
<p>	信息内聚：模块进行许多操作，各自都有不同的入口点、操作代码相对独立，而且所有操作都在相同的数据结构上完成</p>
</li>
<li><p>信息隐藏：核心设计思路就是每个模块都隐藏一个重要的设计决策，抽象出类的关键细节。即抽象出接口，隐藏细节。</p>
</li>
<li><p>信息隐藏决策：职责的实现、实现的变更</p>
</li>
<li><p>软件设计的质量标准：可理解、易修改、易复用 </p>
<p>7±2原则：人们直觉上能够同时处理的主题数量上限为5~9</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter14模块化'>Chapter14模块化</h2>
<ol start='' >
<li><p>模块化原则：</p>
<ol start='' >
<li>全局变量有害；</li>
<li>明确；</li>
<li>不要重复；</li>
<li>针对接口编程：</li>
<li>接口最小化/接口分离原则：</li>
<li>访问耦合的合理范围（迪米特法则）：</li>
<li>LSP（Liskov Substitution Principle）：子类型必须要能替换掉基类型而起相同的作用；</li>
<li>组合替代继承：使用继承时一定要符合LSP，否则应该倾向于使用组合；</li>
<li>集中信息与行为：类的信息和行为应该关联，信息能支撑行为，行为又来操控信息（信息内聚）；</li>
<li>单一职责原则（SRP-Single Responsibility Principle）：信息和行为不仅要集中，还要联合表达一个内聚的概念，即类的职责要和行为和信息匹配（行为内聚）</li>

</ol>
</li>
<li><p>耦合的度量</p>
<ol start='' >
<li><p>方法调用耦合-CBO（Coupling Between Objects）：该类调用其他类成员方法的数量；其他类（不包括子类）访问这个类的成员方法的数量。<strong>越小越好</strong></p>
</li>
<li><p>访问耦合-DAC（Data Abstraction Couling）：一个类包含其他类的实例的数量。<strong>越小越好</strong></p>
</li>
<li><p>继承耦合-NOC（Number of Children）：直属子类的数量。<strong>越大越好</strong>。DIT（Depth of the Inheritance Tree）：继承树的高度。<strong>越大越好</strong></p>
<p>注意一下继承耦合的NOC和DIT的限制</p>
</li>

</ol>
</li>
<li><p>内聚的度量：LCOM（Lack of Cohesion in Methods）：方法和信息为一个连通图</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter15信息隐藏'>Chapter15信息隐藏</h2>
<ol start='' >
<li><p>信息隐藏的含义：（1）封装类的职责，隐藏职责的实现；（2）预计将会发生的变更，抽象他的接口，隐藏他的内部机制。</p>
</li>
<li><p>封装：（1）将数据和行为同时包含在类中；（2）分离对外接口和内部实现。</p>
</li>
<li><p>封装变更/开闭原则-OCP（Open Close Principle）-是对面向对象设计的一个指导性、方针性原则：好的设计应该对“扩展”开放，好的设计应该对“修改”关闭。简单的来说就是发生变更时应该仅添加代码即可，无需修改原有代码。</p>
</li>
<li><p>依赖倒置原则-DIP（Dependency Inversion Principle）：（1）抽象不应该依赖于细节，细节应该依赖于抽象；（2）高层模块不应该依赖于低层模块，而是双方都依赖于抽象。</p>
<p>实现DIP的基本手段：为具体类建立抽象接口并分离该接口。</p>
</li>
<li><p>多态：不同类型的值能通过统一的接口来操纵。</p>
</li>
<li><p>没有任何一个软件是100%封闭的</p>
<p>DIP是有代价的，增加了系统的复杂度。不要强行使用DIP，否则会导致过度的设计</p>
</li>
<li><p>封装实现细节：</p>
<p>封装数据和行为</p>
<p>封装内部结构	·</p>
<p>封装其他对象的引用</p>
<p>封装类型信息</p>
<p>封装潜在变更</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter16设计模式'>Chapter16设计模式</h2>
<ol start='' >
<li><p>可修改性：可修改性（狭义的，对已有实现的修改）；可扩展性；灵活性（对实现的动态配置）。</p>
</li>
<li><p>实现：将接口与实现分离，（1）通过接口和实现该接口的类完成接口与实现的分离；（2）通过子类继承父类，将父类的接口和子类的实现相分离。</p>
</li>
<li><p>策略模式（将策略抽象出来）</p>
<ol start='' >
<li>设计原则：减少耦合（减少策略的使用类和实现类直接的耦合）；依赖倒置（策略的使用类依赖的是策略的接口，而非实现类）。</li>
<li>优点：减少算法类与使用算法类之间的耦合；提供可重用的方法；简化单元测试；可扩展性好。</li>
<li>缺点：策略类增多；策略需要向外暴露。</li>

</ol>
</li>
<li><p>抽象工厂模式（工厂思路，将工厂的生产功能抽象出来）</p>
<ol start='' >
<li>设计原则：职责抽象（抽象对于对象创建的职责）；接口重用（提供对于对象创建的接口）。</li>
<li>优点：易于交换产品系列；对象的实际创建与客户端分离；符合OCP。</li>
<li>缺点：扩充困难。</li>
<li>工厂的接口是固定的，如汽车工厂，创建车身、车轮等接口是固定的，</li>

</ol>
</li>
<li><p>单件模式</p>
<ol start='' >
<li>设计原则：职责抽象（隐藏单件创建的实现）；信息隐藏。</li>

</ol>
</li>
<li><p>迭代器模式（将迭代器抽象出来）</p>
<ol start='' >
<li>设计原则：减少耦合（减少遍历的使用类和遍历的实现类直接的耦合）；依赖倒置（便利的使用类依赖的是策略的接口，而非遍历的实现类）。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter17软件构造'>Chapter17软件构造</h2>
<ol start='' >
<li><p>软件构造的活动：详细设计、编程、测试、调试、代码评审、集成与构建、构造管理。</p>
</li>
<li><p>软件构造的实践方法</p>
<ol start='' >
<li>重构：修改软件系统的严谨方法，在不改变代码外部表现的情况下改进其内部结构。（P289，什么时候重构）</li>
<li>测试驱动开发：程序员在编写一段代码之前，优先完成该段代码的测试代码。完成测试代码之后，程序员再编写程序代码，并在编程中反复测试代码，以验证程序的正确性。（P291，优点）</li>
<li>结对编程：两个程序员挨着坐在一起，共同协作进行软件构造活动，driver &amp; observer。</li>

</ol>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter18代码设计'>Chapter18代码设计</h2>
<ol start='' >
<li><p>代码设计的目的：编写高质量的代码；包括：易读性、易维护性、可靠性。</p>
</li>
<li><p>易读性</p>
<ol start='' >
<li>格式：使用缩进和对齐表达逻辑结构、将相关逻辑组织在一起、使用空行分割逻辑、语句分行；</li>
<li>命名：使用有意义的名称命名；名称与实际符合；遵守惯例；临时变量命名符合常规；不要太长；不要使用易混字符；不要仅仅使用不易区分的多个名称；不要使用没有逻辑的字母缩写。</li>
<li>注释：文档注释（包的总结和描述，类和接口的描述，方法、字段的描述）、内部注释（注释要有意义、重视对数据类型的注释、重视对复杂控制结构的注释）。</li>

</ol>
</li>
<li><p>易维护性</p>
<ol start='' >
<li>小型任务：将程序分解为多个高内聚、低耦合的小任务。</li>
<li>复杂决策：使用布尔变量简化复杂决策（如增加判断语句的变量和次数）；使用有意义的名称封装复杂决策（可以将复杂的、长的语句封装到函数里）；表驱动编程（打表）。</li>
<li>数据使用：不要把变量用于与命名不符合的地方；单个变量不要用于多个目的；限制全局变量；不要使用突兀的数字/字符。</li>
<li>明确依赖关系：对模糊的依赖关系进行注释。</li>

</ol>
</li>
<li><p>设计可靠的代码</p>
<ol start='' >
<li><p>契约式设计：如果一个函数或方法，在前置条件满足的情况下开始执行，完成后能满足后置条件，那么就是正确、可靠的。两种编程方式：</p>
<ol start='' >
<li>异常：开始执行时检查前置条件，执行后检查后置条件，不满足就抛出异常。</li>
<li>断言：</li>

</ol>
</li>
<li><p>防御式编程：思想是在一个方法与其他方法等外界环境交互的时候，不能保证外界都是正确的，所以要在外界发生错误的时候保护方法内部不受侵害。会增加整体代码的复杂度，降低可读性和性能，但是能显著提高可靠性，对于人机交互非常重要。</p>
</li>
<li><p>使用辅助模型设计复杂代码：决策表；伪代码；程序流程图。</p>
</li>

</ol>
</li>
<li><p>单元测试用例</p>
<ol start='' >
<li>为方法开发测试用例主要使用方法的规格、方法代码的逻辑结构两种线索。</li>
<li>使用Mock Object测试类方法：使用Mock Object创建桩程序测试调用其他类方法的类方法。</li>
<li>为类开发测试用例：开发复杂类时所有方法正确也无法保证类的质量，还要测试类不同方法之间的影响。</li>

</ol>
</li>
<li><p>代码复杂度度量-McCabe：应用程序的复杂度有控制流来定义，控制结构最大的影响了程序的复杂度。衡量圈的复杂度的基本思路是计算程序的独立路径的最大数量。</p>
</li>
<li><p>问题代码：</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter19软件测试'>Chapter19软件测试</h2>
<ol start='' >
<li><p>软件开发的验证（Verification）与确认（Validation）主要使用：静态分析与动态测试。</p>
</li>
<li><p>软件测试的目标：（1）向开发者和用户展示软件满足了需求，表明软件产品是一个合格的产品（有效性测试）；（2）找出软件中的缺陷与不足（缺陷测试）。</p>
</li>
<li><p>黑盒测试：把测试对象看作一个黑盒子，完全基于输入和输出数据来判定测试对象的正确性。</p>
<ol start='' >
<li>等价类划分（重要的、常用的）：把程序的输入域分成若干个子集，在每个子集中选取少数有代表性的数据测试。</li>
<li>边界值分析（对等价类划分的补充）：针对边界情况设计用例。</li>
<li>决策表：由条件声明、行动声明、规则选项、行动选项组成，用于复杂逻辑判断。</li>
<li>状态转换：专门针对复杂测试对象，用于测试对象的输出与状态相关的，还需要建立状态图。</li>

</ol>
<p>优点：（1）比较简单，不需要知道软件内部的表现；（2）与软件内部无关；（3）从用户角度出发，容易知道用户会遇到哪些问题；（4）基于软件开发文档，知道软件实现了哪些功能；（5）在做软件自动化测试时比较方便。</p>
<p>缺点：不能覆盖所有代码。</p>
</li>
<li><p>白盒测试：将对象看作透明的，不关心对象的规格，而是按测试对象内部的程序结构来设计测试用例进行测试工作。</p>
<ol start='' >
<li>语句覆盖：确保测试对象的每一条代码都至少被执行一次。</li>
<li>条件覆盖：确保程序中的每个判断的每个结果都至少被满足一次。</li>
<li>路径覆盖：确保程序中的每条独立的执行路径都至少被执行一次。</li>

</ol>
<p>优点：帮助软件测试人员加大代码的覆盖率。</p>
<p>缺点：（1）不能覆盖所有代码；（2）系统庞大时，测试开销巨大；（3）测试基于代码，只能知道开发人员做的对不对，不知道设计的正确性，可能会遗漏功能需求。</p>
</li>
<li><p>测试层次</p>
<p>按测试对象：</p>
<p>	单元测试：对程序单元进行正确性检验的测试工作。一个单元就是类的一个方法</p>
<p>	集成测试（组装测试）：对程序模块一次性或采用增量方式组装起来，对系统的接口进行正确性检验的测试工作</p>
<p>	系统测试：更关注不符合需求的缺陷和需求自身的内在缺陷，系统测试关注整个系统的行为，可分为：功能测试、非功能测试、验收测试、安装测试</p>
<p> </p>
<p>按测试目标：</p>
<p>	功能测试：被测试软件的行为是否遵从软件需求规格的说明</p>
<p>	α测试和β测试：在软件发布前，让小规模、有代表性的潜在客户试用。开发机构中进行（α），或用户处进行（β）</p>
<p>	易用性测试：评价终端用户使用学习软件的难易程度、软件功能支持用户任务的有效程度，从用户的错误中恢复的能力</p>
<p>	恢复测试：软件在“灾难”后的重启动能力</p>
<p>	压力测试：以设计的最大负载运行软件，并超过最大负载运行软件，验证软件的负载能力</p>
<p>	回归测试：变更系统后进行，重新执行已经测试过的系统用例子集，确保变更没有造成未预期的副作用</p>
<p> </p>
<p>	性能测试：针对性能需求进行验证</p>
<p>	配置测试：分析软件在规格说明下的不同配置的行为</p>
<p>	可靠性测试：验证和评价系统可靠性的测试</p>
<p>	安全测试：验证系统内的安全保护机制不受非法入侵的能力</p>
<p>	验收测试：按照客户的需求检查系统</p>
<p>	安装测试：在目标环境中通过安装来验证软件</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter20-软件交付'>Chapter20 软件交付</h2>
<ol start='' >
<li></li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter21软件维护'>Chapter21软件维护</h2>
<ol start='' >
<li><p>软件维护：在交付之后修改软件系统或其部件的活动过程，以修正缺陷、提高性能或其他属性、适应变化的环境。</p>
</li>
<li><p>软件维护的高代价性来源：变更的频繁性；维护的困难性。</p>
</li>
<li><p>开发可维护的软件</p>
<ol start='' >
<li>考虑软件的可变更性。</li>
<li>为降低维护困难而开发。</li>

</ol>
</li>
<li><p>演化生命周期模型</p>
<p><img src="https://img-blog.csdnimg.cn/20200217190404531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzAyMjE5,size_16,color_FFFFFF,t_70" referrerpolicy="no-referrer" alt="img"></p>
</li>
<li><p>逆向工程：分析目标系统，标识系统的部件及其交互关系，并且使用其他形式或者更高层的抽象创建系统表现的过程。基本原理是抽取软件系统的需求设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</p>
</li>
<li><p>再工程：检查和改造一个目标系统，用新的模式及其实现复原该目标系统。目的是对遗留软件系统进行分析和重新开发，以便进一步利用新技术来改善系统或促进现存系统的再利用。</p>
<ol start='' >
<li>改进人们对软件的理解。</li>
<li>改进软件自身、通常是提高可维护性、可复用性和可演化性。</li>

</ol>
<p>活动：重新文档化；重组系统结构；更换系统为新的编程语言；修改数据组织结构。</p>
</li>

</ol>
<p>&nbsp;</p>
<h2 id='chapter22软件过程模型'>Chapter22软件过程模型</h2>
<ol start='' >
<li><p>软件生命周期模型：需求工程-&gt;软件设计-&gt;软件实现-&gt;软件测试-&gt;软件交付-&gt;软件维护。</p>
</li>
<li><p>构建-修复模型</p>
<p>	适用于：软件规模很小、质量要求不高、后期维护要求不高的程序。</p>
<p>	缺点：没有考虑最基本的生命周期；没有分析需求的真实性；没有考虑软件结构的质量；没有考虑测试和程序的可维护性。</p>
<p>	要求：完全依赖个人能力开发。</p>
</li>
<li><p>瀑布模型</p>
<p>	要求：将开发活动分为不同的阶段，保证每一个阶段工作的正确性和有效性，按照“从一个阶段到另一个阶段的有序的转换序列”的方式来组织开发活动。</p>
<p>	适用于：需求非常成熟、稳定；所需的技术成熟可靠；复杂度适中，不需要太大的文档负担和过于复杂的里程碑。</p>
<p>	优点：（1）为软件开发活动定义了清晰的阶段划分，让开发者能以关注点分离的方式更好地进行复杂的软件项目开发活动。</p>
<p>	缺点：（1）对文档多高的期望；（2）对开发活动的线性预期；（3）客户、用户参与不够；（4）里程碑粒度过粗。</p>
</li>
<li><p>增量迭代模型</p>
<p>	要求：将一个很长的开发周期分成多个迭代，每个迭代结束的时候提交产品的一个部分，所有迭代集合起来共同交付完整的产品。将开发活动组织为 <strong>多个迭代、并行的瀑布式开发活动</strong>。“ <strong>需求驱动</strong>”。</p>
<p>	目的：迭代，渐进交付，并行开发。</p>
<p>	适用于：大规模软件系统的开发；比较成熟和稳定的领域。</p>
<p>	优点：（1）迭代开发更符合软件开发的实践情况，有更好的适用性；（2）并行开发可以帮助缩短软件产品的开发时间；（3）渐进交付可以加强用户反馈，降低开发风险。</p>
<p>	缺点：（1）各个构建是逐渐加入已有的软件体系，加入的构件不能破坏以构造好的部分；（2）需要一个完备、清晰的项目前景和范围以进行并行开发规划。</p>
</li>
<li><p>演化模型</p>
<p>	要求：和迭代模型比较相似，但是迭代适用于比较成熟的领域，演化模型适用于需求变更比较频繁和不确定性多的领域。将开发活动分成多个迭代、并行的瀑布式开发活动。“需求驱动”。演化模型新的需求来自上一次演化。额</p>
<p>	适用于：不稳定领域的大规模软件系统开发。</p>
<p>	优点：（1）使用了迭代开发，有较好的适用性；（2）并行开发能缩短开发时间；（3）渐进交付能加强用户反馈，降低开发风险。</p>
<p>	缺点：（1）无法在早期确定项目范围；（2）后去迭代的开发在前期工作上进行，容易让后续迭代忽略分析与设计，蜕变成构建-修复模式。</p>
</li>
<li><p>原型模型</p>
<p>	要求： 注重使用抛弃式原型而不是演化式模型。“需求驱动”/“风险驱动”</p>
<p>	适用于：存在着大量不确定性的新颖领域的开发活动。</p>
<p>	优点：（1）对原型的使用加强了用户与客户的交流，使产品获得更好的满意度；（2）适用于非常新颖的领域。</p>
<p>	缺点：（1）原型能解决风险，自身也带来风险（如成本高）；（2）实践中，开发者不舍得抛弃原型，是的质量差的代码进入最终产品降低质量。</p>
</li>
<li><p>螺旋模型</p>
<p>	思想：尽早解决比较高的风险，如果实在无法解决，提前发现也好于后发现。</p>
<p>	要求：按照风险解决的方式组织软件开发活动，确定目标、解决方案和约束-&gt;评估方案，发现风险-&gt;寻找解决方法-&gt;落实解决方案</p>
<p>	-&gt;下一个迭代。“风险驱动”</p>
<p>	适用于：高风险的大规模软件系统开发。</p>
<p>	优点：降低风险，减少项目因风险造成的损失。</p>
<p>	缺点：（1）需要使用原型，与原型相同；（2）模型过于复杂，不利于管理者依据其组织开发活动。</p>
</li>
<li><p>软件工程体系的知识域</p>
</li>

</ol>
<p>软件⼯工程知识体系的知识域：（SWEBOK）
第二版：（10个）
	软件 生命周期知识：（5个）
		软件 需求
		软件 设计
		软件 构造
		软件 测试
		软件 维护
	软件工程的 工程知识：（5个）（ 工程 配置工具管理 过程和 质量）
		软件 工程管理
		软件 配置管理
		软件 工程过程
		软件工程 工具和方法
		软件 质量
	第三版：（新增5个）（ 职业软件工程师需要学习 概率论， 线性代数， 高等数学和软件 工程）
		软件工程 职业实践
		工程经济学基础
		计算基础
		数学基础
		工程基础</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>画图</p>
<p>用例图：用例、参与者、关系、系统边界。</p>
<p>类图：对象，类，链接，关联（聚合），继承。</p>
        </article>
      </div>
    </section>
    <section class="contact-main-container">

    </section>
  </main>
  <footer>
    <p>如有任何问题，请通过QQ：1254783510联系我</p>
  </footer>
</body>

</html>